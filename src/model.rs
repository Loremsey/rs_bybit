#![allow(unused_imports)]
use crate::errors::BybitError;
use core::f64;
use serde::{Deserialize, Deserializer, Serialize};
use serde_json::{from_value, Value};
use std::{borrow::Cow, collections::BTreeMap};
use thiserror::Error;

/// An empty struct used as a placeholder for API responses where no additional data is returned.
///
/// This is commonly used in Bybit API responses for fields like `ret_ext_info` where the API may return an empty object (`{}`) to maintain a consistent response structure. For trading bots, this struct is typically ignored unless you need to verify the presence of an empty object for error handling or response validation.
#[derive(Serialize, Default, Deserialize, Clone, Debug)]
pub struct Empty {}

/// ----------------------------------------
/// RESPONSE STRUCTS FOR MARKET REQUESTS
/// ----------------------------------------

/// Represents the response from Bybit's server time endpoint.
///
/// This struct is returned when querying the server time via the Bybit API (`/v5/market/time`). It provides the current server time, which is critical for synchronizing trading bot operations with Bybit's server to avoid timestamp-related errors in API requests.
#[derive(Serialize, Deserialize, Clone, Debug)]
#[serde(rename_all = "camelCase")]
pub struct ServerTimeResponse {
    /// The return code indicating the success or failure of the request.
    ///
    /// A value of `0` indicates success, while non-zero values correspond to specific error codes as defined in the Bybit API documentation (e.g., `10001` for invalid parameters). Trading bots should check this field to handle errors gracefully, such as retrying requests or logging issues for debugging.
    pub ret_code: i32,

    /// A human-readable message describing the result or error.
    ///
    /// For successful requests, this is typically `"OK"`. For errors, it provides a description of the issue (e.g., `"invalid timestamp"`). Bots should log this field for debugging and user feedback, especially when `ret_code` is non-zero.
    pub ret_msg: String,

    /// The server time details.
    ///
    /// Contains the actual server time in seconds and nanoseconds. This is crucial for ensuring that API requests include a valid timestamp within the acceptable window (typically ±5 seconds of server time) to avoid rejections.
    pub result: ServerTime,

    /// Additional information, typically an empty object.
    ///
    /// This field is usually an empty `Empty` struct (`{}`) and can be ignored in most cases. However, bots should verify its presence to ensure response consistency.
    pub ret_ext_info: Empty,

    /// The timestamp of the response in milliseconds.
    ///
    /// This represents the time the response was generated by Bybit's server. Trading bots can use this to measure latency or further synchronize operations, though `result.time_second` is typically more relevant for timestamp validation.
    pub time: u64,
}

/// Contains the server time in seconds and nanoseconds.
///
/// This struct is part of the `ServerTimeResponse` and provides high-precision server time, which is essential for timestamp-sensitive API requests in trading bots.
#[derive(Serialize, Deserialize, Clone, Debug)]
#[serde(rename_all = "camelCase")]
pub struct ServerTime {
    /// The server time in seconds since the Unix epoch.
    ///
    /// This is the primary timestamp used for validating API request timestamps. Trading bots must ensure their request timestamps are within a small window (e.g., ±5 seconds) of this value to avoid `10004` (timestamp error) rejections. For example, if `time_second` is `1697051234`, the bot's request timestamp should be very close to this value.
    #[serde(with = "string_to_u64")]
    pub time_second: u64,

    /// The nanosecond component of the server time.
    ///
    /// Provides sub-second precision for the server time. While not typically used directly in API requests, it can be useful for high-frequency trading bots requiring precise timing for latency measurements or event ordering. For most bots, this can be ignored unless nanosecond precision is critical.
    #[serde(with = "string_to_u64")]
    pub time_nano: u64,
}

/// Parameters for requesting Kline (candlestick) data.
///
/// Kline data represents price movements over fixed time intervals (e.g., 1-minute, 1-hour) and is used for technical analysis in trading. This struct defines the parameters for querying Kline data via Bybit's `/v5/market/kline` endpoint. Perpetual futures on Bybit, unlike traditional futures, have no expiry date and are funded via a funding rate mechanism, making Kline data critical for analyzing price trends in these instruments.
#[derive(Clone, Default)]
pub struct KlineRequest<'a> {
    /// The product category (e.g., Spot, Linear, Inverse, Option).
    ///
    /// Specifies the type of instrument for the Kline data. For perpetual futures, `Linear` (USDT-margined) or `Inverse` (coin-margined) are most relevant. Bots should set this to match the trading pair (e.g., `Linear` for `BTCUSDT`). If unset, the API may return an error or default to an unexpected category.
    pub category: Option<Category>,

    /// The trading pair symbol (e.g., "BTCUSDT").
    ///
    /// Identifies the specific perpetual futures contract or other instrument. For perpetuals, this is typically a USDT pair (e.g., `BTCUSDT`) for linear contracts or a coin pair (e.g., `BTCUSD`) for inverse contracts. Bots must ensure the symbol is valid for the chosen `category` to avoid errors.
    pub symbol: Cow<'a, str>,

    /// The time interval for each candlestick (e.g., "1m", "1h", "1d").
    ///
    /// Specifies the granularity of the Kline data, such as `1m` (1 minute), `5m` (5 minutes), `1h` (1 hour), or `1d` (1 day). The choice depends on the trading strategy: short-term bots may use smaller intervals (e.g., `1m`), while long-term strategies may use `1d`. Invalid intervals will result in an API error.
    pub interval: Cow<'a, str>,

    /// The start time for the Kline data (Unix timestamp in milliseconds).
    ///
    /// Defines the beginning of the time range for the Kline data. For perpetual futures, this is useful for fetching historical data to backtest trading strategies. If unset, the API may return data from the most recent period, which may not suit historical analysis needs.
    pub start: Option<Cow<'a, str>>,

    /// The end time for the Kline data (Unix timestamp in milliseconds).
    ///
    /// Defines the end of the time range for the Kline data. Bots should set this to limit the data to a specific period, especially for performance optimization when processing large datasets. If unset, the API typically returns data up to the current time.
    pub end: Option<Cow<'a, str>>,

    /// The maximum number of Kline records to return (1-200, default: 200).
    ///
    /// Controls the number of candlesticks returned in the response. For trading bots, setting a lower limit can reduce latency and memory usage, especially for high-frequency strategies. However, for comprehensive analysis, bots may need to paginate through multiple requests to fetch all desired data.
    pub limit: Option<u64>,
}

impl<'a> KlineRequest<'a> {
    /// Creates a default Kline request with preset values.
    ///
    /// Returns a `KlineRequest` with `symbol` set to `"BTCUSDT"` and other fields as defaults. Useful for quick testing or prototyping trading bots but should be customized for production to match specific trading pairs and intervals.
    pub fn default() -> KlineRequest<'a> {
        KlineRequest::new(None, "BTCUSDT", "", None, None, None)
    }

    /// Constructs a new Kline request with specified parameters.
    ///
    /// Allows full customization of the Kline request. Trading bots should use this to specify exact parameters for their strategy, ensuring the `symbol`, `interval`, and `category` align with the perpetual futures contract being traded.
    pub fn new(
        category: Option<Category>,
        symbol: &'a str,
        interval: &'a str,
        start: Option<&'a str>,
        end: Option<&'a str>,
        limit: Option<u64>,
    ) -> KlineRequest<'a> {
        KlineRequest {
            category,
            symbol: Cow::Borrowed(symbol),
            interval: Cow::Borrowed(interval),
            start: start.map(Cow::Borrowed),
            end: end.map(Cow::Borrowed),
            limit,
        }
    }
}

/// Response structure for Kline (candlestick) data requests.
///
/// Returned by the `/v5/market/kline` endpoint, this struct contains Kline data for a specified trading pair and interval. For perpetual futures, Kline data is essential for technical indicators (e.g., moving averages, RSI) used in trading bots.
#[derive(Serialize, Deserialize, Clone, Debug)]
#[serde(rename_all = "camelCase")]
pub struct KlineResponse {
    /// The return code indicating the success or failure of the request.
    ///
    /// As with other responses, `0` indicates success. Non-zero values require error handling in bots, such as retrying the request or adjusting parameters (e.g., invalid `interval` or `symbol`).
    pub ret_code: i32,

    /// A human-readable message describing the result or error.
    ///
    /// Provides context for the `ret_code`. Bots should log this for debugging, especially for errors like `"invalid symbol"` or `"interval not supported"`.
    pub ret_msg: String,

    /// The Kline data summary.
    ///
    /// Contains the actual candlestick data, including the symbol, category, and a list of Kline records. Bots use this for technical analysis, trend identification, and strategy execution in perpetual futures trading.
    pub result: KlineSummary,

    /// Additional information, typically an empty object.
    ///
    /// Usually an `Empty` struct and can be ignored unless verifying response structure integrity.
    pub ret_ext_info: Empty,

    /// The timestamp of the response in milliseconds.
    ///
    /// Indicates when the response was generated. Bots can use this to ensure data freshness, especially for real-time trading strategies where stale data could lead to poor decisions.
    pub time: u64,
}

/// Summarizes Kline data for a trading pair.
///
/// Part of the `KlineResponse`, this struct organizes the Kline data by symbol, category, and a list of candlesticks. It’s the primary container for the data used in technical analysis for perpetual futures.
#[derive(Serialize, Deserialize, Clone, Debug)]
#[serde(rename_all = "camelCase")]
pub struct KlineSummary {
    /// The trading pair symbol (e.g., "BTCUSDT").
    ///
    /// Confirms the trading pair for which the Kline data was requested. Bots should verify this matches the requested `symbol` to ensure data integrity.
    pub symbol: String,

    /// The product category (e.g., "linear", "spot").
    ///
    /// Indicates the type of instrument (e.g., `linear` for USDT-margined perpetuals). Bots should check this to ensure the data aligns with the intended trading strategy.
    pub category: String,

    /// A list of Kline (candlestick) records.
    ///
    /// Contains the actual candlestick data, each representing a time interval with open, high, low, close prices, and volume. This is the core data used by trading bots for technical analysis and strategy execution.
    pub list: Vec<Kline>,
}

/// Represents a single Kline (candlestick) record.
///
/// Each Kline record corresponds to a time interval and includes price and volume data. For perpetual futures, this data is used to analyze price trends, volatility, and trading volume to inform trading decisions.
#[derive(Serialize, Deserialize, Clone, Debug)]
#[serde(rename_all = "camelCase")]
pub struct Kline {
    /// The start time of the candlestick (Unix timestamp in milliseconds).
    ///
    /// Marks the beginning of the time interval for this candlestick. Bots use this to align data with their internal timelines and ensure chronological order when processing multiple Klines.
    #[serde(with = "string_to_u64")]
    pub start_time: u64,

    /// The opening price of the candlestick.
    ///
    /// The price at the start of the interval. For perpetual futures, this is critical for calculating price changes and indicators like moving averages. Stored as a string to preserve precision, so bots must parse it to `f64` for calculations.
    pub open_price: String,

    /// The highest price during the candlestick interval.
    ///
    /// Indicates the peak price within the interval. Used in volatility analysis and for indicators like Bollinger Bands. Bots should parse this string to `f64` for numerical computations.
    pub high_price: String,

    /// The lowest price during the candlestick interval.
    ///
    /// Indicates the trough price within the interval. Essential for identifying support levels and calculating indicators like the Average True Range (ATR). Requires parsing to `f64`.
    pub low_price: String,

    /// The closing price of the candlestick.
    ///
    /// The price at the end of the interval. Critical for trend analysis and indicators like MACD or candlestick pattern recognition. Bots must parse this string to `f64`.
    pub close_price: String,

    /// The trading volume during the candlestick interval.
    ///
    /// Represents the total quantity of the base asset traded (e.g., BTC in `BTCUSDT`). For perpetual futures, high volume often indicates strong market interest or liquidity, which bots can use to confirm trade signals. Parse to `f64` for analysis.
    pub volume: String,

    /// The quote asset volume during the candlestick interval.
    ///
    /// Represents the total value traded in the quote asset (e.g., USDT in `BTCUSDT`). Useful for assessing market activity and liquidity in perpetual futures. Bots should parse this to `f64` for financial calculations.
    pub quote_asset_volume: String,
}

/// Response structure for Mark Price Kline data requests.
///
/// Returned by the `/v5/market/mark-price-kline` endpoint, this struct provides Kline data based on the mark price, which is a reference price used in perpetual futures to avoid manipulation and ensure fair liquidation. Mark price Klines are critical for bots to assess funding rates and liquidation risks.
#[derive(Serialize, Deserialize, Clone, Debug)]
#[serde(rename_all = "camelCase")]
pub struct MarkPriceKlineResponse {
    /// The return code indicating the success or failure of the request.
    ///
    /// A `0` indicates success. Non-zero codes require error handling, such as checking for invalid symbols or intervals. Bots should implement robust error handling to manage API issues.
    pub ret_code: i32,

    /// A human-readable message describing the result or error.
    ///
    /// Provides context for the `ret_code`. Bots should log this for debugging and to inform users of issues like `"symbol not found"`.
    pub ret_msg: String,

    /// The Mark Price Kline data summary.
    ///
    /// Contains the mark price candlestick data, including symbol, category, and a list of Mark Price Klines. Bots use this to monitor funding rates and avoid unexpected liquidations in perpetual futures.
    pub result: MarkPriceKlineSummary,

    /// Additional information, typically an empty object.
    ///
    /// Usually an `Empty` struct and can be ignored unless verifying response structure.
    pub ret_ext_info: Empty,

    /// The timestamp of the response in milliseconds.
    ///
    /// Indicates when the response was generated. Bots can use this to ensure data freshness for real-time strategies.
    pub time: u64,
}

/// Summarizes Mark Price Kline data for a trading pair.
///
/// Part of the `MarkPriceKlineResponse`, this struct organizes the Mark Price Kline data by symbol, category, and a list of candlesticks. It’s used to analyze the mark price, which drives funding rates and liquidations in perpetual futures.
#[derive(Serialize, Deserialize, Clone, Debug)]
#[serde(rename_all = "camelCase")]
pub struct MarkPriceKlineSummary {
    /// The trading pair symbol (e.g., "BTCUSDT").
    ///
    /// Confirms the trading pair for the Mark Price Kline data. Bots should verify this matches the requested symbol.
    pub symbol: String,

    /// The product category (e.g., "linear").
    ///
    /// Indicates the instrument type (e.g., `linear` for USDT-margined perpetuals). Bots should ensure this aligns with their trading strategy.
    pub category: String,

    /// A list of Mark Price Kline records.
    ///
    /// Contains the mark price candlestick data, each representing a time interval with open, high, low, and close mark prices. Bots use this for funding rate analysis and liquidation risk assessment.
    pub list: Vec<MarkPriceKline>,
}

/// Represents a single Mark Price Kline record.
///
/// Each record provides mark price data for a time interval. In perpetual futures, the mark price is a smoothed price used to calculate funding rates and trigger liquidations, making this data critical for risk management in trading bots.
#[derive(Serialize, Deserialize, Clone, Debug)]
#[serde(rename_all = "camelCase")]
pub struct MarkPriceKline {
    /// The start time of the candlestick (Unix timestamp in milliseconds).
    ///
    /// Marks the beginning of the time interval. Bots use this to align mark price data with other time-series data (e.g., regular Klines).
    #[serde(with = "string_to_u64")]
    pub start_time: u64,

    /// The opening mark price of the candlestick.
    ///
    /// The mark price at the start of the interval. Used to track funding rate trends and liquidation thresholds. Parse to `f64` for calculations.
    pub open_price: String,

    /// The highest mark price during the candlestick interval.
    ///
    /// Indicates the peak mark price. Useful for assessing potential liquidation risks during volatile periods. Parse to `f64`.
    pub high_price: String,

    /// The lowest mark price during the candlestick interval.
    ///
    /// Indicates the trough mark price. Helps bots identify safe price levels relative to liquidation thresholds. Parse to `f64`.
    pub low_price: String,

    /// The closing mark price of the candlestick.
    ///
    /// The mark price at the end of the interval. Critical for real-time funding rate calculations and liquidation monitoring. Parse to `f64`.
    pub close_price: String,
}

/// Response structure for Index Price Kline data requests.
///
/// Returned by the `/v5/market/index-price-kline` endpoint, this struct provides Kline data based on the index price, which tracks the underlying asset’s spot price across multiple exchanges. For perpetual futures, the index price is used to anchor the mark price, ensuring it reflects market conditions.
#[derive(Serialize, Deserialize, Clone, Debug)]
#[serde(rename_all = "camelCase")]
pub struct IndexPriceKlineResponse {
    /// The return code indicating the success or failure of the request.
    ///
    /// A `0` indicates success. Non-zero codes require error handling for issues like invalid symbols. Bots should implement retry logic for transient errors.
    pub ret_code: i32,

    /// A human-readable message describing the result or error.
    ///
    /// Provides context for the `ret_code`. Bots should log this for debugging.
    pub ret_msg: String,

    /// The Index Price Kline data summary.
    ///
    /// Contains the index price candlestick data. Bots use this to understand the underlying spot market trends that influence perpetual futures pricing.
    pub result: IndexPriceKlineSummary,

    /// Additional information, typically an empty object.
    ///
    /// Usually an `Empty` struct and can be ignored.
    pub ret_ext_info: Empty,

    /// The timestamp of the response in milliseconds.
    ///
    /// Indicates response generation time. Bots can use this to ensure data freshness.
    pub time: u64,
}

/// Summarizes Index Price Kline data for a trading pair.
///
/// Part of the `IndexPriceKlineResponse`, this struct organizes the Index Price Kline data by symbol, category, and a list of candlesticks. It’s used to analyze the spot market trends affecting perpetual futures.
#[derive(Serialize, Deserialize, Clone, Debug)]
#[serde(rename_all = "camelCase")]
pub struct IndexPriceKlineSummary {
    /// The trading pair symbol (e.g., "BTCUSDT").
    ///
    /// Confirms the trading pair for the Index Price Kline data. Bots should verify this matches the requested symbol.
    pub symbol: String,

    /// The product category (e.g., "linear").
    ///
    /// Indicates the instrument type. Bots should ensure this aligns with their strategy.
    pub category: String,

    /// A list of Index Price Kline records.
    ///
    /// Contains the index price candlestick data. Bots use this to monitor spot market trends that influence perpetual futures pricing and funding rates.
    pub list: Vec<IndexPriceKline>,
}

/// Represents a single Index Price Kline record.
///
/// Each record provides index price data for a time interval. In perpetual futures, the index price reflects the spot market, helping bots predict mark price movements and funding rate changes.
#[derive(Serialize, Deserialize, Clone, Debug)]
#[serde(rename_all = "camelCase")]
pub struct IndexPriceKline {
    /// The start time of the candlestick (Unix timestamp in milliseconds).
    ///
    /// Marks the beginning of the time interval. Bots use this to align index price data with other data sources.
    #[serde(with = "string_to_u64")]
    pub start_time: u64,

    /// The opening index price of the candlestick.
    ///
    /// The index price at the start of the interval. Used to track spot market trends. Parse to `f64`.
    pub open_price: String,

    /// The highest index price during the candlestick interval.
    ///
    /// Indicates the peak index price. Useful for understanding spot market volatility. Parse to `f64`.
    pub high_price: String,

    /// The lowest index price during the candlestick interval.
    ///
    /// Indicates the trough index price. Helps bots assess spot market support levels. Parse to `f64`.
    pub low_price: String,

    /// The closing index price of the candlestick.
    ///
    /// The index price at the end of the interval. Critical for predicting mark price and funding rate trends. Parse to `f64`.
    pub close_price: String,
}

/// Response structure for Premium Index Price Kline data requests.
///
/// Returned by the `/v5/market/premium-index-price-kline` endpoint, this struct provides Kline data based on the premium index price, which reflects the premium or discount of the perpetual futures price relative to the spot index price. This is key for understanding funding rate dynamics.
#[derive(Serialize, Deserialize, Clone, Debug)]
#[serde(rename_all = "camelCase")]
pub struct PremiumIndexPriceKlineResponse {
    /// The return code indicating the success or failure of the request.
    ///
    /// A `0` indicates success. Non-zero codes require error handling. Bots should retry or adjust parameters for errors.
    pub ret_code: i32,

    /// A human-readable message describing the result or error.
    ///
    /// Provides context for the `ret_code`. Bots should log this for debugging.
    pub ret_msg: String,

    /// The Premium Index Price Kline data summary.
    ///
    /// Contains the premium index price candlestick data. Bots use this to analyze funding rate drivers in perpetual futures.
    pub result: PremiumIndexPriceKlineSummary,

    /// Additional information, typically an empty object.
    ///
    /// Usually an `Empty` struct and can be ignored.
    pub ret_ext_info: Empty,

    /// The timestamp of the response in milliseconds.
    ///
    /// Indicates response generation time. Bots can use this for data freshness checks.
    pub time: u64,
}

/// Summarizes Premium Index Price Kline data for a trading pair.
///
/// Part of the `PremiumIndexPriceKlineResponse`, this struct organizes the Premium Index Price Kline data. It’s used to analyze the premium/discount in perpetual futures pricing.
#[derive(Serialize, Deserialize, Clone, Debug)]
#[serde(rename_all = "camelCase")]
pub struct PremiumIndexPriceKlineSummary {
    /// The trading pair symbol (e.g., "BTCUSDT").
    ///
    /// Confirms the trading pair. Bots should verify this matches the requested symbol.
    pub symbol: String,

    /// The product category (e.g., "linear").
    ///
    /// Indicates the instrument type. Bots should ensure alignment with their strategy.
    pub category: String,

    /// A list of Premium Index Price Kline records.
    ///
    /// Contains the premium index price candlestick data. Bots use this to predict funding rate changes and optimize trading strategies.
    pub list: Vec<PremiumIndexPriceKline>,
}

/// Represents a single Premium Index Price Kline record.
///
/// Each record provides premium index price data for a time interval. This data helps bots understand the funding rate’s directional pressure in perpetual futures.
#[derive(Serialize, Deserialize, Clone, Debug)]
#[serde(rename_all = "camelCase")]
pub struct PremiumIndexPriceKline {
    /// The start time of the candlestick (Unix timestamp in milliseconds).
    ///
    /// Marks the beginning of the time interval. Bots use this for data alignment.
    #[serde(with = "string_to_u64")]
    pub start_time: u64,

    /// The opening premium index price of the candlestick.
    ///
    /// The premium/discount at the start of the interval. A positive value indicates a premium, driving positive funding rates. Parse to `f64`.
    pub open_price: String,

    /// The highest premium index price during the candlestick interval.
    ///
    /// Indicates the peak premium/discount. Useful for assessing funding rate volatility. Parse to `f64`.
    pub high_price: String,

    /// The lowest premium index price during the candlestick interval.
    ///
    /// Indicates the trough premium/discount. Helps bots evaluate funding rate stability. Parse to `f64`.
    pub low_price: String,

    /// The closing premium index price of the candlestick.
    ///
    /// The premium/discount at the end of the interval. Critical for real-time funding rate predictions. Parse to `f64`.
    pub close_price: String,
}

/// Parameters for requesting instrument information.
///
/// This struct defines the parameters for querying instrument details via the `/v5/market/instruments-info` endpoint. For perpetual futures, instrument info includes leverage, price filters, and lot size filters, which are critical for configuring trading bot parameters.
#[derive(Clone, Default)]
pub struct InstrumentRequest<'a> {
    /// The product category (e.g., Linear, Inverse, Spot, Option).
    ///
    /// Specifies the instrument type. For perpetual futures, use `Linear` or `Inverse`. Bots must set this to filter relevant instruments.
    pub category: Category,

    /// The trading pair symbol (e.g., "BTCUSDT").
    ///
    /// Optionally specifies a single trading pair. If unset, the API returns data for all instruments in the category, which may be voluminous. Bots should set this for specific pairs to reduce response size and latency.
    pub symbol: Option<Cow<'a, str>>,

    /// The trading status of the instrument (true for trading, false for not trading).
    ///
    /// Filters instruments by their trading status. Useful for bots to exclude delisted or inactive perpetual futures contracts. If unset, all statuses are returned.
    pub status: Option<bool>,

    /// The base coin of the instrument (e.g., "BTC").
    ///
    /// Filters instruments by their base asset. For example, setting `base_coin` to `"BTC"` returns all BTC-based perpetuals (e.g., `BTCUSDT`, `BTCUSD`). Useful for bots targeting specific assets.
    pub base_coin: Option<Cow<'a, str>>,

    /// The maximum number of instruments to return (1-1000, default: 500).
    ///
    /// Controls the response size. Bots should set a reasonable limit to balance data completeness and performance, especially when querying all instruments in a category.
    pub limit: Option<u64>,
}

impl<'a> InstrumentRequest<'a> {
    /// Creates a default Instrument request.
    ///
    /// Returns a request with `category` set to `Linear` and `symbol` set to `"BTCUSDT"`. Suitable for testing but should be customized for production to match specific trading needs.
    pub fn default() -> InstrumentRequest<'a> {
        InstrumentRequest::new(Category::Linear, Some("BTCUSDT"), None, None, None)
    }

    /// Constructs a new Instrument request with specified parameters.
    ///
    /// Allows full customization. Bots should use this to tailor requests to their strategy, ensuring `category` and `symbol` align with the perpetual futures being traded.
    pub fn new(
        category: Category,
        symbol: Option<&'a str>,
        status: Option<bool>,
        base_coin: Option<&'a str>,
        limit: Option<u64>,
    ) -> InstrumentRequest<'a> {
        InstrumentRequest {
            category,
            symbol: symbol.map(Cow::Borrowed),
            status,
            base_coin: base_coin.map(Cow::Borrowed),
            limit,
        }
    }
}

/// Response structure for instrument information requests.
///
/// Returned by the `/v5/market/instruments-info` endpoint, this struct provides details about trading instruments, including perpetual futures contracts. Bots use this to configure trading parameters like leverage and order sizes.
#[derive(Serialize, Deserialize, Clone, Debug)]
#[serde(rename_all = "camelCase")]
pub struct InstrumentInfoResponse {
    /// The return code indicating the success or failure of the request.
    ///
    /// A `0` indicates success. Non-zero codes require error handling for issues like invalid categories. Bots should implement retry logic.
    pub ret_code: i32,

    /// A human-readable message describing the result or error.
    ///
    /// Provides context for the `ret_code`. Bots should log this for debugging.
    pub ret_msg: String,

    /// The instrument information.
    ///
    /// Contains the actual instrument data, which varies by category (Futures, Spot, Options). For perpetual futures, this includes leverage and filter details critical for bot configuration.
    pub result: InstrumentInfo,

    /// Additional information, typically an empty object.
    ///
    /// Usually an `Empty` struct and can be ignored.
    pub ret_ext_info: Empty,

    /// The timestamp of the response in milliseconds.
    ///
    /// Indicates response generation time. Bots can use this for data freshness checks.
    pub time: u64,
}

/// Enum representing different types of instrument information.
///
/// This untagged enum allows the API to return different instrument details based on the category (Futures, Spot, Options). For perpetual futures, the `Futures` variant is most relevant, containing details like leverage and funding intervals.
#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(untagged)]
pub enum InstrumentInfo {
    /// Instrument information for futures (including perpetuals).
    ///
    /// Contains details for perpetual futures contracts, such as leverage filters and funding intervals. Bots use this to configure trading parameters and manage risk.
    Futures(FuturesInstrumentsInfo),

    /// Instrument information for spot markets.
    ///
    /// Contains details for spot trading pairs. Less relevant for perpetual futures but included for completeness.
    Spot(SpotInstrumentsInfo),

    /// Instrument information for options.
    ///
    /// Contains details for options contracts. Not typically used for perpetual futures trading.
    Options(OptionsInstrument),
}

/// Contains instrument information for futures contracts.
///
/// Part of the `InstrumentInfo` enum, this struct provides details for futures, including perpetual futures. It’s critical for bots trading perpetuals to understand leverage, price, and lot size constraints.
#[derive(Serialize, Deserialize, Clone, Debug)]
#[serde(rename_all = "camelCase")]
pub struct FuturesInstrumentsInfo {
    /// The product category (e.g., "linear", "inverse").
    ///
    /// Confirms the type of futures contract. For perpetuals, this is `linear` (USDT-margined) or `inverse` (coin-margined). Bots should verify this matches their trading strategy.
    pub category: String,

    /// A list of futures instrument details.
    ///
    /// Contains the actual instrument data for each futures contract. Bots iterate over this list to extract parameters like leverage and funding intervals for perpetual futures.
    pub list: Vec<FuturesInstrument>,

    /// The cursor for pagination.
    ///
    /// Indicates the next page of results for large datasets. Bots should use this for paginated requests to fetch all instruments when `limit` is reached.
    #[serde(skip_serializing_if = "String::is_empty")]
    pub next_page_cursor: String,
}

/// Represents a single futures instrument (e.g., a perpetual futures contract).
///
/// Contains detailed information about a futures contract, such as leverage, funding rates, and trading constraints. For perpetual futures, this is critical for configuring trading bots to comply with Bybit’s rules and manage risk.
#[derive(Serialize, Deserialize, Clone, Debug)]
#[serde(rename_all = "camelCase")]
pub struct FuturesInstrument {
    /// The trading pair symbol (e.g., "BTCUSDT").
    ///
    /// Identifies the specific perpetual futures contract. Bots must use this to match the instrument to their trading strategy.
    pub symbol: String,

    /// The type of futures contract (e.g., "perpetual").
    ///
    /// Indicates whether the contract is a perpetual futures contract or another type (e.g., quarterly futures). For perpetuals, this is typically `"perpetual"`. Bots should verify this to ensure they’re trading the correct instrument.
    pub contract_type: String,

    /// The trading status of the instrument (e.g., "Trading", "Settling").
    ///
    /// Indicates whether the contract is actively trading. Bots should only trade instruments with `"Trading"` status to avoid errors or unsupported operations.
    pub status: String,

    /// The base coin of the contract (e.g., "BTC").
    ///
    /// The underlying asset of the contract (e.g., BTC in `BTCUSDT`). Useful for bots filtering instruments by asset type.
    pub base_coin: String,

    /// The quote coin of the contract (e.g., "USDT").
    ///
    /// The currency used to quote the contract price (e.g., USDT in `BTCUSDT`). For linear perpetuals, this is typically USDT; for inverse, it’s the base coin (e.g., USD for `BTCUSD`). Bots should verify this for correct pricing calculations.
    pub quote_coin: String,

    /// The launch time of the contract (Unix timestamp in milliseconds).
    ///
    /// Indicates when the contract was listed on Bybit. Less critical for trading but useful for bots analyzing historical performance or contract maturity.
    #[serde(with = "string_to_u64")]
    pub launch_time: u64,

    /// The delivery time for non-perpetual futures (empty for perpetuals).
    ///
    /// For perpetual futures, this is an empty string since they have no expiry. Bots can ignore this for perpetuals but should check it for quarterly futures to understand settlement dates.
    #[serde(skip_serializing_if = "String::is_empty")]
    pub delivery_time: String,

    /// The delivery fee rate for non-perpetual futures.
    ///
    /// For perpetual futures, this is typically empty or irrelevant since there’s no delivery. Bots can ignore this unless trading quarterly futures.
    pub delivery_fee_rate: String,

    /// The price scale (number of decimal places for price).
    ///
    /// Defines the precision for price quotes (e.g., `"2"` for two decimal places). Bots must use this to format order prices correctly to avoid rejection due to invalid precision.
    pub price_scale: String,

    /// The leverage constraints for the contract.
    ///
    /// Specifies the minimum, maximum, and step size for leverage. Bots must adhere to these constraints when setting leverage to avoid API errors and manage risk in perpetual futures.
    pub leverage_filter: LeverageFilter,

    /// The price constraints for the contract.
    ///
    /// Defines the minimum, maximum, and tick size for prices. Bots must use this to ensure order prices are within valid ranges and increments.
    pub price_filter: PriceFilter,

    /// The lot size constraints for the contract.
    ///
    /// Specifies the minimum, maximum, and step size for order quantities. Bots must comply with these to place valid orders and manage position sizes in perpetual futures.
    pub lot_size_filter: LotSizeFilter,

    /// Whether the contract supports unified margin trading.
    ///
    /// Indicates if the contract can be traded under Bybit’s unified margin account, which allows cross-margining across assets. Bots should check this to understand margin requirements and risk management options.
    pub unified_margin_trade: bool,

    /// The funding interval in minutes (e.g., 480 for 8 hours).
    ///
    /// Specifies how often funding rates are settled for perpetual futures (typically every 8 hours). Bots must monitor this to calculate funding costs, as frequent settlements can impact profitability for long-term positions.
    pub funding_interval: u64,

    /// The settlement coin for the contract (e.g., "USDT").
    ///
    /// The currency used for margin and settlement. For linear perpetuals, this is typically USDT; for inverse, it’s the base coin. Bots should use this to manage account balances and margin requirements.
    pub settle_coin: String,

    /// Indicates if copy trading is supported.
    ///
    /// Specifies whether the contract supports Bybit’s copy trading feature. Less relevant for bots unless integrating with social trading features.
    pub copy_trading: String,

    /// The upper bound for the funding rate.
    ///
    /// The maximum funding rate that can be applied during a funding interval. Bots should use this to estimate worst-case funding costs for long or short positions in perpetual futures.
    pub upper_funding_rate: String,

    /// The lower bound for the funding rate.
    ///
    /// The minimum funding rate (can be negative). Bots should use this to estimate funding costs or benefits, especially for short positions when rates are negative.
    pub lower_funding_rate: String,
}

/// Contains instrument information for spot markets.
///
/// Part of the `InstrumentInfo` enum, this struct provides details for spot trading pairs. Less relevant for perpetual futures but included for completeness.
#[derive(Serialize, Deserialize, Clone, Debug)]
#[serde(rename_all = "camelCase")]
pub struct SpotInstrumentsInfo {
    /// The product category (e.g., "spot").
    ///
    /// Confirms the instrument type as spot. Bots trading perpetuals can ignore this.
    pub category: String,

    /// A list of spot instrument details.
    ///
    /// Contains data for each spot trading pair. Not relevant for perpetual futures.
    pub list: Vec<SpotInstrument>,

    /// The cursor for pagination.
    ///
    /// Used for paginated requests. Bots can ignore this unless querying spot instruments.
    #[serde(skip_serializing_if = "String::is_empty")]
    pub next_page_cursor: String,
}

/// Represents a single spot instrument.
///
/// Contains details about a spot trading pair. Not relevant for perpetual futures but included for completeness.
#[derive(Serialize, Deserialize, Clone, Debug)]
#[serde(rename_all = "camelCase")]
pub struct SpotInstrument {
    /// The trading pair symbol (e.g., "BTCUSDT").
    ///
    /// Identifies the spot trading pair. Bots trading perpetuals can ignore this.
    pub symbol: String,

    /// The base coin (e.g., "BTC").
    ///
    /// The underlying asset of the spot pair. Not relevant for perpetuals.
    pub base_coin: String,

    /// The quote coin (e.g., "USDT").
    ///
    /// The currency used to quote the spot pair. Not relevant for perpetuals.
    pub quote_coin: String,

    /// Indicates if the pair is an innovation token (0 or 1).
    ///
    /// Marks new or experimental tokens. Not relevant for perpetuals.
    #[serde(with = "string_to_u64")]
    pub innovation: u64,

    /// The trading status (e.g., "Trading").
    ///
    /// Indicates if the spot pair is tradable. Not relevant for perpetuals.
    pub status: String,

    /// Indicates if margin trading is supported.
    ///
    /// Specifies whether the spot pair supports margin trading. Not relevant for perpetuals.
    pub margin_trading: String,

    /// A tag for the spot pair (e.g., for special tokens).
    ///
    /// Used for categorization. Not relevant for perpetuals.
    #[serde(with = "string_to_u64")]
    pub st_tag: u64,

    /// The lot size constraints.
    ///
    /// Defines order quantity constraints for spot trading. Not relevant for perpetuals.
    pub lot_size_filter: LotSizeFilter,

    /// The price constraints.
    ///
    /// Defines price constraints for spot trading. Not relevant for perpetuals.
    pub price_filter: PriceFilter,

    /// Risk parameters for the spot pair.
    ///
    /// Specifies risk-related constraints. Not relevant for perpetuals.
    pub risk_parameters: RiskParameters,
}

/// Represents an options instrument.
///
/// Contains details about an options contract. Not relevant for perpetual futures but included for completeness.
#[derive(Serialize, Deserialize, Clone, Debug)]
#[serde(rename_all = "camelCase")]
pub struct OptionsInstrument {
    /// The trading pair symbol (e.g., "BTC-30DEC22-50000-C").
    ///
    /// Identifies the options contract. Not relevant for perpetuals.
    pub symbol: String,

    /// The trading status (e.g., "Trading").
    ///
    /// Indicates if the options contract is tradable. Not relevant for perpetuals.
    pub status: String,

    /// The base coin (e.g., "BTC").
    ///
    /// The underlying asset of the options contract. Not relevant for perpetuals.
    pub base_coin: String,

    /// The quote coin (e.g., "USDT").
    ///
    /// The currency used to quote the options contract. Not relevant for perpetuals.
    pub quote_coin: String,

    /// The settlement coin (e.g., "USDT").
    ///
    /// The currency used for settlement. Not relevant for perpetuals.
    pub settle_coin: String,

    /// The type of option (e.g., "Call", "Put").
    ///
    /// Specifies whether the option is a call or put. Not relevant for perpetuals.
    pub option_type: String,

    /// The launch time of the options contract (Unix timestamp in milliseconds).
    ///
    /// Indicates when the contract was listed. Not relevant for perpetuals.
    #[serde(with = "string_to_u64")]
    pub launch_time: u64,

    /// The delivery time of the options contract (Unix timestamp in milliseconds).
    ///
    /// Indicates the expiry date of the option. Not relevant for perpetuals.
    #[serde(with = "string_to_u64")]
    pub delivery_time: u64,

    /// The delivery fee rate for the options contract.
    ///
    /// Specifies the fee for settlement. Not relevant for perpetuals.
    pub delivery_fee_rate: String,

    /// The price constraints.
    ///
    /// Defines price constraints for options trading. Not relevant for perpetuals.
    pub price_filter: PriceFilter,

    /// The lot size constraints.
    ///
    /// Defines order quantity constraints for options trading. Not relevant for perpetuals.
    pub lot_size_filter: LotSizeFilter,
}

/// Contains pre-listing information for an instrument.
///
/// Provides details about instruments in the pre-listing phase (e.g., auctions). Not typically relevant for perpetual futures, which are already listed, but included for completeness.
#[derive(Serialize, Deserialize, Clone, Debug)]
#[serde(rename_all = "camelCase")]
pub struct PreListingInfo {
    /// The current auction phase (e.g., "DutchAuction").
    ///
    /// Indicates the stage of the pre-listing auction. Not relevant for perpetuals.
    pub cur_auction_phase: String,

    /// A list of pre-listing phases.
    ///
    /// Details the schedule of the auction phases. Not relevant for perpetuals.
    pub phases: Vec<PreListingPhase>,

    /// Auction fee information.
    ///
    /// Specifies fees for the pre-listing auction. Not relevant for perpetuals.
    pub auction_fee_info: AuctionFeeInfo,
}

/// Represents a single pre-listing phase.
///
/// Details a phase in the pre-listing auction process. Not relevant for perpetual futures.
#[derive(Serialize, Deserialize, Clone, Debug)]
#[serde(rename_all = "camelCase")]
pub struct PreListingPhase {
    /// The phase name (e.g., "DutchAuction").
    ///
    /// Identifies the auction phase. Not relevant for perpetuals.
    pub phase: String,

    /// The start time of the phase (Unix timestamp in milliseconds).
    ///
    /// Marks the beginning of the phase. Not relevant for perpetuals.
    #[serde(with = "string_to_u64")]
    pub start_time: u64,

    /// The end time of the phase (Unix timestamp in milliseconds).
    ///
    /// Marks the end of the phase. Not relevant for perpetuals.
    #[serde(with = "string_to_u64")]
    pub end_time: u64,
}

/// Contains fee information for a pre-listing auction.
///
/// Specifies fees for the auction process. Not relevant for perpetual futures.
#[derive(Serialize, Deserialize, Clone, Debug)]
#[serde(rename_all = "camelCase")]
pub struct AuctionFeeInfo {
    /// The auction fee rate.
    ///
    /// The fee charged for participating in the auction. Not relevant for perpetuals.
    pub auction_fee_rate: String,

    /// The taker fee rate for the auction.
    ///
    /// The fee for taking liquidity during the auction. Not relevant for perpetuals.
    pub taker_fee_rate: String,

    /// The maker fee rate for the auction.
    ///
    /// The fee for providing liquidity during the auction. Not relevant for perpetuals.
    pub maker_fee_rate: String,
}

/// Risk parameters for a spot instrument.
///
/// Specifies risk-related constraints for spot trading. Not relevant for perpetual futures.
#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct RiskParameters {
    /// The limit order risk parameter.
    ///
    /// Defines risk constraints for limit orders in spot trading. Not relevant for perpetuals.
    pub limit_parameter: String,

    /// The market order risk parameter.
    ///
    /// Defines risk constraints for market orders in spot trading. Not relevant for perpetuals.
    pub market_parameter: String,
}

/// Leverage constraints for a futures instrument.
///
/// Specifies the allowable leverage settings for a perpetual futures contract. Bots must adhere to these to set valid leverage levels and manage risk.
#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct LeverageFilter {
    /// The minimum leverage allowed.
    ///
    /// The lowest leverage setting for the contract (e.g., `"1"` for 1x). Bots must ensure leverage settings are at least this value to avoid API errors. Low leverage reduces risk but also potential returns.
    pub min_leverage: String,

    /// The maximum leverage allowed.
    ///
    /// The highest leverage setting (e.g., `"100"` for 100x). High leverage amplifies gains and losses in perpetual futures, increasing liquidation risk. Bots should use this to cap leverage based on risk tolerance.
    pub max_leverage: String,

    /// The leverage step size.
    ///
    /// The increment for leverage adjustments (e.g., `"0.1"`). Bots must set leverage in multiples of this step to comply with Bybit’s rules.
    pub leverage_step: String,
}

/// Price constraints for an instrument.
///
/// Defines the allowable price ranges and increments for orders. Bots must use these to place valid orders in perpetual futures.
#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct PriceFilter {
    /// The minimum price allowed (optional).
    ///
    /// The lowest price at which orders can be placed. If `None`, there’s no lower bound. Bots should check this to avoid rejected orders due to prices being too low.
    #[serde(skip_serializing_if = "is_empty_or_none")]
    pub min_price: Option<String>,

    /// The maximum price allowed (optional).
    ///
    /// The highest price at which orders can be placed. If `None`, there’s no upper bound. Bots should ensure order prices are below this to avoid rejections.
    #[serde(skip_serializing_if = "is_empty_or_none")]
    pub max_price: Option<String>,

    /// The price tick size.
    ///
    /// The increment for price changes (e.g., `0.01` for two decimal places). Bots must round order prices to this increment to comply with Bybit’s precision rules, avoiding rejection.
    #[serde(with = "string_to_float")]
    pub tick_size: f64,
}

/// Lot size constraints for an instrument.
///
/// Defines the allowable order quantity ranges and increments. Bots must use these to place valid orders in perpetual futures.
#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct LotSizeFilter {
    /// The base asset precision (optional).
    ///
    /// The precision for the base asset quantity (e.g., `"0.001"` for BTC). Bots should use this to format order quantities correctly.
    #[serde(skip_serializing_if = "is_empty_or_none")]
    pub base_precision: Option<String>,

    /// The quote asset precision (optional).
    ///
    /// The precision for the quote asset amount. Useful for calculating order values in USDT for linear perpetuals.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub quote_precision: Option<String>,

    /// The maximum market order quantity (optional).
    ///
    /// The largest quantity allowed for market orders. Bots should check this to avoid oversized market orders, which could be rejected or cause slippage.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_mkt_order_qty: Option<String>,

    /// The minimum order quantity.
    ///
    /// The smallest quantity allowed for orders. Bots must ensure order sizes are at least this value to avoid rejections.
    #[serde(with = "string_to_float")]
    pub min_order_qty: f64,

    /// The maximum order quantity.
    ///
    /// The largest quantity allowed for orders. Bots should cap order sizes to this value to comply with Bybit’s rules.
    #[serde(with = "string_to_float")]
    pub max_order_qty: f64,

    /// The minimum order amount (optional).
    ///
    /// The smallest order value in the quote asset (e.g., USDT). Bots should verify order values meet this threshold.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub min_order_amt: Option<String>,

    /// The maximum order amount (optional).
    ///
    /// The largest order value in the quote asset. Bots should ensure order values are below this to avoid rejections.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_order_amt: Option<String>,

    /// The quantity step size (optional).
    ///
    /// The increment for order quantities. Bots must round order sizes to this step to comply with Bybit’s rules.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub qty_step: Option<String>,

    /// The maximum post-only order quantity (optional).
    ///
    /// The largest quantity for post-only orders. Bots using post-only orders (maker-only) should respect this limit.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub post_only_max_order_qty: Option<String>,

    /// The minimum notional value (optional).
    ///
    /// The smallest notional value (price × quantity) for orders. Bots should verify orders meet this to avoid rejections.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub min_notional_value: Option<String>,
}

/// Parameters for requesting order book data.
///
/// This struct defines the parameters for querying the order book via the `/v5/market/orderbook` endpoint. The order book shows current bid and ask prices and quantities, critical for liquidity analysis and order placement in perpetual futures.
#[derive(Clone, Default)]
pub struct OrderbookRequest<'a> {
    /// The trading pair symbol (e.g., "BTCUSDT").
    ///
    /// Identifies the perpetual futures contract. Bots must specify a valid symbol to fetch the correct order book.
    pub symbol: Cow<'a, str>,

    /// The product category (e.g., Linear, Inverse).
    ///
    /// Specifies the instrument type. For perpetual futures, use `Linear` or `Inverse`. Bots must set this correctly to avoid errors.
    pub category: Category,

    /// The maximum number of order book levels to return (1-500, default: 50).
    ///
    /// Controls the depth of the order book (number of bid/ask levels). Bots should balance depth with performance: deeper books provide more liquidity data but increase latency and memory usage.
    pub limit: Option<u64>,
}

impl<'a> OrderbookRequest<'a> {
    /// Creates a default Orderbook request.
    ///
    /// Returns a request with `symbol` set to `"BTCUSDT"` and `category` set to `Linear`. Suitable for testing but should be customized for production.
    pub fn default() -> OrderbookRequest<'a> {
        OrderbookRequest::new("BTCUSDT", Category::Linear, None)
    }

    /// Constructs a new Orderbook request with specified parameters.
    ///
    /// Allows customization. Bots should use this to specify the exact symbol and category for their perpetual futures strategy.
    pub fn new(symbol: &'a str, category: Category, limit: Option<u64>) -> OrderbookRequest<'a> {
        OrderbookRequest {
            symbol: Cow::Borrowed(symbol),
            category,
            limit,
        }
    }
}

/// Response structure for order book data requests.
///
/// Returned by the `/v5/market/orderbook` endpoint, this struct provides the current order book for a trading pair, including bid and ask levels. Bots use this for liquidity analysis and to optimize order placement in perpetual futures.
#[derive(Serialize, Deserialize, Clone, Debug)]
#[serde(rename_all = "camelCase")]
pub struct OrderBookResponse {
    /// The return code indicating the success or failure of the request.
    ///
    /// A `0` indicates success. Non-zero codes require error handling for issues like invalid symbols. Bots should retry or adjust parameters.
    pub ret_code: i32,

    /// A human-readable message describing the result or error.
    ///
    /// Provides context for the `ret_code`. Bots should log this for debugging.
    pub ret_msg: String,

    /// The order book data.
    ///
    /// Contains the actual bid and ask levels for the trading pair. Bots use this to assess liquidity and determine optimal order prices.
    pub result: OrderBook,

    /// Additional information, typically an empty object.
    ///
    /// Usually an `Empty` struct and can be ignored.
    pub ret_ext_info: Empty,

    /// The timestamp of the response in milliseconds.
    ///
    /// Indicates response generation time. Bots can use this to ensure data freshness for real-time trading.
    pub time: u64,
}

/// Represents the order book for a trading pair.
///
/// Contains the current bid and ask levels, along with metadata like the update ID. Bots use this to analyze market depth and liquidity in perpetual futures.
#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct OrderBook {
    /// The trading pair symbol (e.g., "BTCUSDT").
    ///
    /// Confirms the trading pair for the order book. Bots should verify this matches the requested symbol.
    #[serde(rename = "s")]
    pub symbol: String,

    /// A list of ask (sell) orders.
    ///
    /// Contains the current ask prices and quantities. Bots use this to assess selling pressure and determine resistance levels in perpetual futures.
    #[serde(rename = "a")]
    pub asks: Vec<Ask>,

    /// A list of bid (buy) orders.
    ///
    /// Contains the current bid prices and quantities. Bots use this to assess buying support and determine support levels in perpetual futures.
    #[serde(rename = "b")]
    pub bids: Vec<Bid>,

    /// The timestamp of the order book snapshot (Unix timestamp in milliseconds).
    ///
    /// Indicates when the order book data was captured. Bots should use this to ensure the data is recent, as stale order book data can lead to poor trading decisions.
    #[serde(rename = "ts")]
    pub timestamp: u64,

    /// The update ID of the order book.
    ///
    /// A unique identifier for the order book snapshot. Bots can use this to track updates and ensure they’re processing the latest data, especially in WebSocket streams.
    #[serde(rename = "u")]
    pub update_id: u64,
}

/// Represents an ask (sell) order in the order book.
///
/// Each ask contains a price and quantity at which sellers are willing to sell. Bots use this to assess selling pressure and optimize order placement.
#[derive(Serialize, Deserialize, Clone, Debug)]
#[serde(rename_all = "camelCase")]
pub struct Ask {
    /// The ask price.
    ///
    /// The price at which the seller is offering to sell. Bots use this to determine resistance levels and calculate slippage for buy orders in perpetual futures.
    #[serde(with = "string_to_float")]
    pub price: f64,

    /// The ask quantity.
    ///
    /// The quantity available at the ask price. Bots use this to assess liquidity and estimate the impact of large buy orders on the market.
    #[serde(with = "string_to_float")]
    pub qty: f64,
}

/// Represents a bid (buy) order in the order book.
///
/// Each bid contains a price and quantity at which buyers are willing to buy. Bots use this to assess buying support and optimize order placement.
#[derive(Serialize, Deserialize, Clone, Debug)]
#[serde(rename_all = "camelCase")]
pub struct Bid {
    /// The bid price.
    ///
    /// The price at which the buyer is offering to buy. Bots use this to determine support levels and calculate slippage for sell orders in perpetual futures.
    #[serde(with = "string_to_float")]
    pub price: f64,

    /// The bid quantity.
    ///
    /// The quantity available at the bid price. Bots use this to assess liquidity and estimate the impact of large sell orders on the market.
    #[serde(with = "string_to_float")]
    pub qty: f64,
}

impl Bid {
    /// Constructs a new Bid with specified price and quantity.
    ///
    /// Useful for testing or simulating order book data. Bots typically receive this from the API rather than constructing it manually.
    pub fn new(price: f64, qty: f64) -> Bid {
        Bid { price, qty }
    }
}

impl Ask {
    /// Constructs a new Ask with specified price and quantity.
    ///
    /// Useful for testing or simulating order book data. Bots typically receive this from the API rather than constructing it manually.
    pub fn new(price: f64, qty: f64) -> Ask {
        Ask { price, qty }
    }
}

/// Response structure for ticker data requests.
///
/// Returned by the `/v5/market/tickers` endpoint, this struct provides real-time market data for a trading pair, such as current price, volume, and funding rates. For perpetual futures, this is critical for monitoring market conditions and funding costs.
#[derive(Serialize, Deserialize, Clone, Debug)]
#[serde(rename_all = "camelCase")]
pub struct TickerResponse {
    /// The return code indicating the success or failure of the request.
    ///
    /// A `0` indicates success. Non-zero codes require error handling. Bots should retry or adjust parameters for errors.
    pub ret_code: i32,

    /// A human-readable message describing the result or error.
    ///
    /// Provides context for the `ret_code`. Bots should log this for debugging.
    pub ret_msg: String,

    /// The ticker information.
    ///
    /// Contains the actual market data for the trading pair(s). Bots use this for real-time price monitoring and strategy execution in perpetual futures.
    pub result: TickersInfo,

    /// Additional information, typically an empty object.
    ///
    /// Usually an `Empty` struct and can be ignored.
    pub ret_ext_info: Empty,

    /// The timestamp of the response in milliseconds.
    ///
    /// Indicates response generation time. Bots should use this to ensure data freshness for real-time trading.
    pub time: u64,
}

/// Summarizes ticker information for a category.
///
/// Part of the `TickerResponse`, this struct organizes ticker data by category and a list of ticker records. Bots use this to monitor multiple trading pairs.
#[derive(Serialize, Deserialize, Clone, Debug)]
#[serde(rename_all = "camelCase")]
pub struct TickersInfo {
    /// The product category (e.g., "linear", "spot").
    ///
    /// Indicates the instrument type. For perpetual futures, this is `linear` or `inverse`. Bots should verify this matches their strategy.
    pub category: String,

    /// A list of ticker data records.
    ///
    /// Contains the actual market data for each trading pair. Bots iterate over this list to extract prices, volumes, and funding rates for perpetual futures.
    pub list: Vec<TickerData>,
}

/// Enum representing ticker data for different instrument types.
///
/// This untagged enum allows the API to return ticker data for either spot or futures (including perpetuals). For perpetual futures, the `Futures` variant is most relevant, containing funding rate and open interest data.
#[derive(Serialize, Deserialize, Clone, Debug)]
#[serde(untagged)]
pub enum TickerData {
    /// Ticker data for spot markets.
    ///
    /// Contains market data for spot trading pairs. Not relevant for perpetual futures.
    Spot(SpotTicker),

    /// Ticker data for futures (including perpetuals).
    ///
    /// Contains market data for perpetual futures, including funding rates and open interest. Critical for bots monitoring market conditions and funding costs.
    Futures(FuturesTicker),
}

/// Represents ticker data for a futures contract (including perpetuals).
///
/// Contains real-time market data for a perpetual futures contract, such as prices, volumes, open interest, and funding rates. Bots use this for price monitoring, liquidity analysis, and funding cost estimation.
#[derive(Serialize, Deserialize, Clone, Debug)]
#[serde(rename_all = "camelCase")]
pub struct FuturesTicker {
    /// The trading pair symbol (e.g., "BTCUSDT").
    ///
    /// Identifies the perpetual futures contract. Bots should verify this matches their target pair.
    pub symbol: String,

    /// The last traded price.
    ///
    /// The most recent price at which the contract was traded. Bots use this for real-time price tracking and as a reference for order placement.
    #[serde(with = "string_to_float")]
    pub last_price: f64,

    /// The index price.
    ///
    /// The spot market price of the underlying asset, aggregated from multiple exchanges. In perpetual futures, this anchors the mark price to prevent manipulation. Bots use this to predict mark price movements and funding rates.
    #[serde(with = "string_to_float")]
    pub index_price: f64,

    /// The mark price.
    ///
    /// A smoothed price used for funding rate calculations and liquidation triggers in perpetual futures. Bots must monitor this to avoid liquidations, as positions are closed if the mark price hits the liquidation price.
    #[serde(with = "string_to_float")]
    pub mark_price: f64,

    /// The price 24 hours ago.
    ///
    /// The price of the contract 24 hours prior. Bots use this to calculate daily price changes and assess market trends.
    #[serde(with = "string_to_float")]
    pub prev_price_24h: f64,

    /// The percentage price change over the last 24 hours.
    ///
    /// Calculated as `(last_price - prev_price_24h) / prev_price_24h`. Bots use this to identify trends and volatility in perpetual futures.
    #[serde(rename = "price24hPcnt", with = "string_to_float")]
    pub daily_change_percentage: f64,

    /// The highest price in the last 24 hours.
    ///
    /// Indicates the peak price. Bots use this to assess resistance levels and volatility.
    #[serde(rename = "highPrice24h", with = "string_to_float")]
    pub high_24h: f64,

    /// The lowest price in the last 24 hours.
    ///
    /// Indicates the trough price. Bots use this to assess support levels and volatility.
    #[serde(rename = "lowPrice24h", with = "string_to_float")]
    pub low_24h: f64,

    /// The price 1 hour ago.
    ///
    /// The price of the contract 1 hour prior. Bots use this for short-term trend analysis.
    #[serde(with = "string_to_float")]
    pub prev_price_1h: f64,

    /// The total open interest.
    ///
    /// The total number of open contracts (in base asset units, e.g., BTC). High open interest indicates strong market participation, which can affect liquidity and volatility in perpetual futures. Bots use this to gauge market sentiment.
    #[serde(with = "string_to_float")]
    pub open_interest: f64,

    /// The value of open interest in the quote asset.
    ///
    /// The total value of open contracts in the quote asset (e.g., USDT). Bots use this to assess the financial scale of market participation.
    #[serde(with = "string_to_float")]
    pub open_interest_value: f64,

    /// The trading turnover in the last 24 hours (in quote asset).
    ///
    /// The total value traded in the quote asset (e.g., USDT). Bots use this to assess market activity and liquidity.
    #[serde(with = "string_to_float")]
    pub turnover_24h: f64,

    /// The trading volume in the last 24 hours (in base asset).
    ///
    /// The total quantity traded in the base asset (e.g., BTC). Bots use this to confirm trade signals, as high volume often indicates strong trends.
    #[serde(with = "string_to_float")]
    pub volume_24h: f64,

    /// The current funding rate.
    ///
    /// The rate paid between long and short position holders every funding interval (typically 8 hours). Positive rates mean longs pay shorts; negative rates mean shorts pay longs. Bots must monitor this to estimate funding costs, which can significantly impact profitability for long-term positions in perpetual futures.
    pub funding_rate: String,

    /// The timestamp of the next funding settlement (Unix timestamp in milliseconds).
    ///
    /// Indicates when the next funding rate will be applied. Bots should use this to time position adjustments to minimize funding costs.
    #[serde(with = "string_to_u64")]
    pub next_funding_time: u64,

    /// The predicted delivery price (empty for perpetuals).
    ///
    /// For perpetual futures, this is typically empty since there’s no delivery. Bots can ignore this.
    #[serde(skip_serializing_if = "String::is_empty")]
    pub predicted_delivery_price: String,

    /// The basis rate (empty for perpetuals).
    ///
    /// For perpetual futures, this is typically empty. Bots can ignore this.
    #[serde(skip_serializing_if = "String::is_empty")]
    pub basis_rate: String,

    /// The delivery fee rate (empty for perpetuals).
    ///
    /// For perpetual futures, this is typically empty. Bots can ignore this.
    pub delivery_fee_rate: String,

    /// The delivery time (empty for perpetuals).
    ///
    /// For perpetual futures, this is typically empty. Bots can ignore this.
    #[serde(with = "string_to_u64")]
    pub delivery_time: u64,

    /// The size of the best ask order.
    ///
    /// The quantity available at the best ask price. Bots use this to assess immediate selling liquidity.
    #[serde(rename = "ask1Size", with = "string_to_float")]
    pub ask_size: f64,

    /// The best bid price.
    ///
    /// The highest price buyers are willing to pay. Bots use this to determine the current market bid price for sell orders.
    #[serde(rename = "bid1Price", with = "string_to_float")]
    pub bid_price: f64,

    /// The best ask price.
    ///
    /// The lowest price sellers are willing to accept. Bots use this to determine the current market ask price for buy orders.
    #[serde(rename = "ask1Price", with = "string_to_float")]
    pub ask_price: f64,

    /// The size of the best bid order.
    ///
    /// The quantity available at the best bid price. Bots use this to assess immediate buying liquidity.
    #[serde(rename = "bid1Size", with = "string_to_float")]
    pub bid_size: f64,

    /// The basis (empty for perpetuals).
    ///
    /// For perpetual futures, this is typically empty. Bots can ignore this.
    #[serde(skip_serializing_if = "String::is_empty")]
    pub basis: String,
}

/// Represents ticker data for a spot trading pair.
///
/// Contains market data for spot markets. Not relevant for perpetual futures but included for completeness.
#[derive(Serialize, Deserialize, Clone, Debug)]
#[serde(rename_all = "camelCase")]
pub struct SpotTicker {
    /// The trading pair symbol (e.g., "BTCUSDT").
    ///
    /// Identifies the spot trading pair. Not relevant for perpetuals.
    pub symbol: String,

    /// The best bid price.
    ///
    /// The highest price buyers are willing to pay in the spot market. Not relevant for perpetuals.
    #[serde(rename = "bid1Price", with = "string_to_float")]
    pub bid_price: f64,

    /// The size of the best bid order.
    ///
    /// The quantity at the best bid price. Not relevant for perpetuals.
    #[serde(rename = "bid1Size", with = "string_to_float")]
    pub bid_size: f64,

    /// The best ask price.
    ///
    /// The lowest price sellers are willing to accept in the spot market. Not relevant for perpetuals.
    #[serde(rename = "ask1Price", with = "string_to_float")]
    pub ask_price: f64,

    /// The size of the best ask order.
    ///
    /// The quantity at the best ask price. Not relevant for perpetuals.
    #[serde(rename = "ask1Size", with = "string_to_float")]
    pub ask_size: f64,

    /// The last traded price.
    ///
    /// The most recent price in the spot market. Not relevant for perpetuals.
    #[serde(with = "string_to_float")]
    pub last_price: f64,

    /// The price 24 hours ago.
    ///
    /// The price in the spot market 24 hours prior. Not relevant for perpetuals.
    #[serde(rename = "prevPrice24h", with = "string_to_float")]
    pub prev_price_24h: f64,

    /// The percentage price change over the last 24 hours.
    ///
    /// Calculated for the spot market. Not relevant for perpetuals.
    #[serde(rename = "price24hPcnt", with = "string_to_float")]
    pub daily_change_percentage: f64,

    /// The highest price in the last 24 hours.
    ///
    /// The peak price in the spot market. Not relevant for perpetuals.
    #[serde(rename = "highPrice24h", with = "string_to_float")]
    pub high_24h: f64,

    /// The lowest price in the last 24 hours.
    ///
    /// The trough price in the spot market. Not relevant for perpetuals.
    #[serde(rename = "lowPrice24h", with = "string_to_float")]
    pub low_24h: f64,

    /// The trading turnover in the last 24 hours (in quote asset).
    ///
    /// The total value traded in the spot market. Not relevant for perpetuals.
    #[serde(with = "string_to_float")]
    pub turnover_24h: f64,

    /// The trading volume in the last 24 hours (in base asset).
    ///
    /// The total quantity traded in the spot market. Not relevant for perpetuals.
    #[serde(with = "string_to_float")]
    pub volume_24h: f64,

    /// The USD index price.
    ///
    /// The spot price of the asset in USD. Not relevant for perpetuals.
    #[serde(with = "string_to_float")]
    pub usd_index_price: f64,
}

/// Parameters for requesting funding rate history.
///
/// This struct defines the parameters for querying funding rate history via the `/v5/market/funding/history` endpoint. Funding rates are critical in perpetual futures as they balance long and short positions and affect position holding costs.
#[derive(Clone, Default)]
pub struct FundingHistoryRequest<'a> {
    /// The product category (e.g., Linear, Inverse).
    ///
    /// Specifies the instrument type. For perpetual futures, use `Linear` or `Inverse`. Bots must set this correctly.
    pub category: Category,

    /// The trading pair symbol (e.g., "BTCUSDT").
    ///
    /// Identifies the perpetual futures contract. Bots must specify a valid symbol.
    pub symbol: Cow<'a, str>,

    /// The start time for the funding history (Unix timestamp in milliseconds).
    ///
    /// Defines the beginning of the time range. Bots should set this for historical analysis of funding costs.
    pub start_time: Option<u64>,

    /// The end time for the funding history (Unix timestamp in milliseconds).
    ///
    /// Defines the end of the time range. Bots should set this to limit data to a specific period.
    pub end_time: Option<u64>,

    /// The maximum number of records to return (1-200, default: 200).
    ///
    /// Controls the response size. Bots should set a reasonable limit to balance data completeness and performance.
    pub limit: Option<u64>,
}

impl<'a> FundingHistoryRequest<'a> {
    /// Creates a default FundingHistory request.
    ///
    /// Returns a request with `category` set to `Linear` and `symbol` set to `"BTCUSDT"`. Suitable for testing but should be customized for production.
    pub fn default() -> FundingHistoryRequest<'a> {
        FundingHistoryRequest::new(Category::Linear, "BTCUSDT", None, None, None)
    }

    /// Constructs a new FundingHistory request with specified parameters.
    ///
    /// Allows customization. Bots should use this to specify the exact symbol and time range for funding rate analysis.
    pub fn new(
        category: Category,
        symbol: &'a str,
        start_time: Option<u64>,
        end_time: Option<u64>,
        limit: Option<u64>,
    ) -> FundingHistoryRequest<'a> {
        FundingHistoryRequest {
            category,
            symbol: Cow::Borrowed(symbol),
            start_time,
            end_time,
            limit,
        }
    }
}

/// Response structure for funding rate history requests.
///
/// Returned by the `/v5/market/funding/history` endpoint, this struct provides historical funding rate data for a perpetual futures contract. Bots use this to analyze funding costs and optimize position timing.
#[derive(Serialize, Deserialize, Clone, Debug)]
#[serde(rename_all = "camelCase")]
pub struct FundingRateResponse {
    /// The return code indicating the success or failure of the request.
    ///
    /// A `0` indicates success. Non-zero codes require error handling. Bots should retry or adjust parameters.
    pub ret_code: i32,

    /// A human-readable message describing the result or error.
    ///
    /// Provides context for the `ret_code`. Bots should log this for debugging.
    pub ret_msg: String,

    /// The funding rate history summary.
    ///
    /// Contains the funding rate data for the specified contract. Bots use this to estimate historical funding costs.
    pub result: FundingRateSummary,

    /// Additional information, typically an empty object.
    ///
    /// Usually an `Empty` struct and can be ignored.
    pub ret_ext_info: Empty,

    /// The timestamp of the response in milliseconds.
    ///
    /// Indicates response generation time. Bots can use this for data freshness checks.
    pub time: u64,
}

/// Summarizes funding rate history for a trading pair.
///
/// Part of the `FundingRateResponse`, this struct organizes funding rate data by category and a list of funding rate records. Bots use this to analyze funding cost trends.
#[derive(Serialize, Deserialize, Clone, Debug)]
#[serde(rename_all = "camelCase")]
pub struct FundingRateSummary {
    /// The product category (e.g., "linear").
    ///
    /// Indicates the instrument type. Bots should verify this matches their strategy.
    pub category: String,

    /// A list of funding rate records.
    ///
    /// Contains the actual funding rate data. Bots iterate over this list to analyze historical funding costs.
    pub list: Vec<FundingRate>,
}

/// Represents a single funding rate record.
///
/// Each record provides the funding rate and timestamp for a specific funding interval in a perpetual futures contract. Funding rates balance long and short positions by charging a fee, paid every funding interval (typically 8 hours). Bots use this data to analyze historical funding costs, optimize position timing, and estimate profitability, as positive rates mean longs pay shorts, while negative rates mean shorts pay longs.
#[derive(Serialize, Deserialize, Clone, Debug)]
#[serde(rename_all = "camelCase")]
pub struct FundingRate {
    /// The trading pair symbol (e.g., "BTCUSDT").
    ///
    /// Identifies the perpetual futures contract for this funding rate record. Bots should verify this matches the requested symbol to ensure data integrity.
    pub symbol: String,

    /// The funding rate for the interval.
    ///
    /// The rate applied during the funding interval, expressed as a decimal (e.g., `0.0001` for 0.01%). Positive rates indicate longs pay shorts; negative rates indicate shorts pay longs. Bots must parse this to `f64` for calculations and use it to estimate funding costs, which can significantly impact long-term position profitability in perpetual futures.
    #[serde(with = "string_to_float")]
    pub funding_rate: f64,

    /// The timestamp of the funding rate application (Unix timestamp in milliseconds).
    ///
    /// Indicates when the funding rate was applied. Bots use this to align funding rate data with other time-series data (e.g., price or position data) and to reconstruct the funding cost history for backtesting or strategy optimization.
    #[serde(with = "string_to_u64")]
    pub funding_rate_timestamp: u64,
}

/// Parameters for requesting recent trading records.
///
/// This struct defines the parameters for querying recent trades via the `/v5/market/recent-trade` endpoint. Recent trade data provides executed trade details, which are critical for analyzing market activity, liquidity, and short-term price movements in perpetual futures.
#[derive(Clone, Default)]
pub struct RecentTradesRequest<'a> {
    /// The product category (e.g., Linear, Inverse).
    ///
    /// Specifies the instrument type. For perpetual futures, use `Linear` (USDT-margined) or `Inverse` (coin-margined). Bots must set this correctly to fetch trades for the intended contract type.
    pub category: Category,

    /// The trading pair symbol (e.g., "BTCUSDT").
    ///
    /// Identifies the perpetual futures contract. Bots must specify a valid symbol to retrieve trade data for the correct market.
    pub symbol: Option<Cow<'a, str>>,

    /// The base coin of the instrument (e.g., "BTC").
    ///
    /// Optionally filters trades by the base asset (e.g., all BTC-based perpetuals like `BTCUSDT` or `BTCUSD`). Useful for bots analyzing trades across multiple pairs of the same asset. If unset, trades are filtered only by `symbol`.
    pub base_coin: Option<Cow<'a, str>>,

    /// The maximum number of trade records to return (1-1000, default: 500).
    ///
    /// Controls the number of trade records in the response. Bots should set a reasonable limit to balance data completeness with performance, as large datasets can increase latency and memory usage. For high-frequency trading, a smaller limit may suffice for real-time analysis.
    pub limit: Option<u64>,
}

impl<'a> RecentTradesRequest<'a> {
    /// Creates a default RecentTrades request.
    ///
    /// Returns a request with `category` set to `Linear` and `symbol` set to `"BTCUSDT"`. Suitable for quick testing or prototyping but should be customized for production to match the specific perpetual futures contract and analysis needs.
    pub fn default() -> RecentTradesRequest<'a> {
        RecentTradesRequest::new(Category::Linear, Some("BTCUSDT"), None, None)
    }

    /// Constructs a new RecentTrades request with specified parameters.
    ///
    /// Allows full customization of the trade request. Bots should use this to specify the exact symbol, category, and other parameters to align with their trading strategy for perpetual futures.
    pub fn new(
        category: Category,
        symbol: Option<&'a str>,
        base_coin: Option<&'a str>,
        limit: Option<u64>,
    ) -> RecentTradesRequest<'a> {
        RecentTradesRequest {
            category,
            symbol: symbol.map(Cow::Borrowed),
            base_coin: base_coin.map(Cow::Borrowed),
            limit,
        }
    }
}

/// Response structure for recent trading records requests.
///
/// Returned by the `/v5/market/recent-trade` endpoint, this struct provides a list of recently executed trades for a specified trading pair. Bots use this data to analyze trade volume, price trends, and market sentiment in perpetual futures, which can inform short-term trading decisions.
#[derive(Serialize, Deserialize, Clone, Debug)]
#[serde(rename_all = "camelCase")]
pub struct RecentTradesResponse {
    /// The return code indicating the success or failure of the request.
    ///
    /// A value of `0` indicates success, while non-zero values correspond to errors (e.g., `10001` for invalid parameters). Bots should check this field and implement error handling, such as retrying requests or logging issues for debugging.
    pub ret_code: i32,

    /// A human-readable message describing the result or error.
    ///
    /// For successful requests, this is typically `"OK"`. For errors, it provides details (e.g., `"invalid symbol"`). Bots should log this field for debugging and user feedback, especially when `ret_code` is non-zero.
    pub ret_msg: String,

    /// The recent trades data summary.
    ///
    /// Contains the actual trade records, including price, quantity, and execution details. Bots use this for real-time market analysis and to confirm trade signals in perpetual futures.
    pub result: RecentTrades,

    /// Additional information, typically an empty object.
    ///
    /// Usually an `Empty` struct (`{}`) and can be ignored unless verifying response structure integrity for error handling or validation.
    pub ret_ext_info: Empty,

    /// The timestamp of the response in milliseconds.
    ///
    /// Indicates when the response was generated by Bybit’s server. Bots can use this to measure latency or ensure data freshness, as stale trade data can lead to inaccurate trading decisions in fast-moving markets.
    pub time: u64,
}

/// Summarizes recent trading records for a trading pair.
///
/// Part of the `RecentTradesResponse`, this struct organizes recent trade data by category and a list of trade records. It’s the primary container for trade data used by bots to analyze market activity in perpetual futures.
#[derive(Serialize, Deserialize, Clone, Debug)]
#[serde(rename_all = "camelCase")]
pub struct RecentTrades {
    /// The product category (e.g., "linear").
    ///
    /// Indicates the instrument type (e.g., `linear` for USDT-margined perpetuals). Bots should verify this matches the requested `category` to ensure data relevance.
    pub category: String,

    /// A list of recent trade records.
    ///
    /// Contains the executed trade details, such as price, quantity, and side (buy/sell). Bots use this to analyze trade volume, price momentum, and market liquidity for perpetual futures.
    pub list: Vec<RecentTrade>,
}

/// Represents a single trade record.
///
/// Each trade record details an executed trade, including price, quantity, side, and timestamp. For perpetual futures, this data is critical for understanding short-term market dynamics and confirming trading signals.
#[derive(Serialize, Deserialize, Clone, Debug)]
#[serde(rename_all = "camelCase")]
pub struct RecentTrade {
    /// The timestamp of the trade execution (Unix timestamp in milliseconds).
    ///
    /// Indicates when the trade occurred. Bots use this to align trade data with other time-series data (e.g., Klines) and to assess the recency of market activity for real-time strategies.
    #[serde(with = "string_to_u64")]
    pub exec_time: u64,

    /// The trading pair symbol (e.g., "BTCUSDT").
    ///
    /// Identifies the perpetual futures contract for the trade. Bots should verify this matches the requested symbol to ensure data accuracy.
    pub symbol: String,

    /// The trade execution price.
    ///
    /// The price at which the trade was executed. Bots use this to track price movements and calculate metrics like average trade price or slippage in perpetual futures. Stored as a string to preserve precision, so bots must parse it to `f64` for calculations.
    pub price: String,

    /// The trade quantity (in base asset).
    ///
    /// The amount of the base asset traded (e.g., BTC in `BTCUSDT`). Bots use this to assess trade size and market liquidity, as large trades may indicate institutional activity or strong market sentiment.
    #[serde(with = "string_to_float")]
    pub size: f64,

    /// The side of the trade ("Buy" or "Sell").
    ///
    /// Indicates whether the trade was a buy (taker buying from maker) or sell (taker selling to maker). Bots use this to analyze buying vs. selling pressure, which can inform momentum-based strategies in perpetual futures.
    pub side: String,

    /// The unique trade ID.
    ///
    /// A unique identifier for the trade on Bybit’s exchange. Bots can use this to track specific trades, avoid duplicates in data processing, or correlate trades with other exchange data.
    pub trade_id: String,

    /// Indicates if the trade is a block trade.
    ///
    /// A boolean (`true` or `false`) indicating whether the trade was a large block trade, typically executed off the public order book. Bots can use this to identify significant market moves driven by institutional or large traders in perpetual futures.
    pub is_block_trade: bool,
}

/// Parameters for requesting open interest data.
///
/// This struct defines the parameters for querying open interest via the `/v5/market/open-interest` endpoint. Open interest represents the total number of outstanding contracts, a key metric for assessing market participation and sentiment in perpetual futures.
#[derive(Clone, Default)]
pub struct OpenInterestRequest<'a> {
    /// The product category (e.g., Linear, Inverse).
    ///
    /// Specifies the instrument type. For perpetual futures, use `Linear` or `Inverse`. Bots must set this to fetch open interest for the correct contract type.
    pub category: Category,

    /// The trading pair symbol (e.g., "BTCUSDT").
    ///
    /// Identifies the perpetual futures contract. Bots must specify a valid symbol to retrieve open interest data.
    pub symbol: Cow<'a, str>,

    /// The time interval for open interest data (e.g., "5min", "1h", "1d").
    ///
    /// Specifies the granularity of the open interest data, such as `5min` (5 minutes), `1h` (1 hour), or `1d` (1 day). Bots should choose an interval that aligns with their analysis timeframe—shorter intervals for intraday strategies, longer for trend analysis.
    pub interval: Cow<'a, str>,

    /// The start time for the open interest data (Unix timestamp in milliseconds).
    ///
    /// Defines the beginning of the time range. Bots should set this for historical open interest analysis, such as studying market participation trends in perpetual futures.
    pub start_time: Option<u64>,

    /// The end time for the open interest data (Unix timestamp in milliseconds).
    ///
    /// Defines the end of the time range. Bots should set this to limit data to a specific period, optimizing performance when processing large datasets.
    pub end_time: Option<u64>,

    /// The maximum number of records to return (1-200, default: 200).
    ///
    /// Controls the number of open interest records returned. Bots should set a reasonable limit to balance data completeness with performance, especially for high-frequency strategies requiring real-time data.
    pub limit: Option<u64>,
}

impl<'a> OpenInterestRequest<'a> {
    /// Creates a default OpenInterest request.
    ///
    /// Returns a request with `category` set to `Linear`, `symbol` set to `"BTCUSDT"`, and `interval` set to `"1h"`. Suitable for testing but should be customized for production to match specific trading needs and analysis timeframes.
    pub fn default() -> OpenInterestRequest<'a> {
        OpenInterestRequest::new(Category::Linear, "BTCUSDT", "1h", None, None, None)
    }

    /// Constructs a new OpenInterest request with specified parameters.
    ///
    /// Allows full customization. Bots should use this to specify the exact symbol, interval, and time range to align with their strategy for analyzing open interest in perpetual futures.
    pub fn new(
        category: Category,
        symbol: &'a str,
        interval: &'a str,
        start_time: Option<u64>,
        end_time: Option<u64>,
        limit: Option<u64>,
    ) -> OpenInterestRequest<'a> {
        OpenInterestRequest {
            category,
            symbol: Cow::Borrowed(symbol),
            interval: Cow::Borrowed(interval),
            start_time,
            end_time,
            limit,
        }
    }
}

/// Response structure for open interest data requests.
///
/// Returned by the `/v5/market/open-interest` endpoint, this struct provides historical or real-time open interest data for a perpetual futures contract. Bots use this to gauge market sentiment, as high open interest often indicates strong participation and potential for larger price moves.
#[derive(Serialize, Deserialize, Clone, Debug)]
#[serde(rename_all = "camelCase")]
pub struct OpenInterestResponse {
    /// The return code indicating the success or failure of the request.
    ///
    /// A `0` indicates success. Non-zero codes require error handling for issues like invalid symbols or intervals. Bots should implement retry logic or parameter adjustments for errors.
    pub ret_code: i32,

    /// A human-readable message describing the result or error.
    ///
    /// Provides context for the `ret_code`, such as `"OK"` for success or an error description (e.g., `"invalid interval"`). Bots should log this for debugging and user feedback.
    pub ret_msg: String,

    /// The open interest data summary.
    ///
    /// Contains the actual open interest data, including the symbol and a list of records. Bots use this to analyze market participation and liquidity in perpetual futures.
    pub result: OpenInterestSummary,

    /// The cursor for pagination.
    ///
    /// Indicates the next page of results for large datasets. Bots should use this for paginated requests to fetch additional open interest data when `limit` is reached.
    pub next_page_cursor: String,

    /// Additional information, typically an empty object.
    ///
    /// Usually an `Empty` struct and can be ignored unless verifying response structure.
    pub ret_ext_info: Empty,

    /// The timestamp of the response in milliseconds.
    ///
    /// Indicates when the response was generated. Bots can use this to ensure data freshness, especially for real-time strategies relying on current open interest trends.
    pub time: u64,
}

/// Summarizes open interest data for a trading pair.
///
/// Part of the `OpenInterestResponse`, this struct organizes open interest data by symbol and a list of records. It’s the primary container for open interest data used by bots to assess market dynamics in perpetual futures.
#[derive(Serialize, Deserialize, Clone, Debug)]
#[serde(rename_all = "camelCase")]
pub struct OpenInterestSummary {
    /// The trading pair symbol (e.g., "BTCUSDT").
    ///
    /// Confirms the perpetual futures contract for the open interest data. Bots should verify this matches the requested symbol.
    pub symbol: String,

    /// A list of open interest records.
    ///
    /// Contains the open interest data for each time interval, including quantity and timestamp. Bots use this to analyze trends in market participation and predict potential price volatility.
    pub list: Vec<OpenInterest>,
}

/// Represents a single open interest record.
///
/// Each record provides the open interest (total outstanding contracts) for a specific time interval in a perpetual futures contract. Bots use this to assess market sentiment, as rising open interest may indicate new positions and potential price momentum, while declining open interest may signal position unwinding.
#[derive(Serialize, Deserialize, Clone, Debug)]
#[serde(rename_all = "camelCase")]
pub struct OpenInterest {
    /// The open interest quantity (in base asset).
    ///
    /// The total number of outstanding contracts in the base asset (e.g., BTC in `BTCUSDT`). Bots use this to gauge market participation, as high open interest suggests strong liquidity and potential for larger price moves in perpetual futures. Parse to `f64` for calculations.
    #[serde(with = "string_to_float")]
    pub open_interest: f64,

    /// The timestamp of the open interest record (Unix timestamp in milliseconds).
    ///
    /// Indicates when the open interest was recorded. Bots use this to align open interest data with price or trade data for time-series analysis and to track changes over time.
    #[serde(with = "string_to_u64")]
    pub timestamp: u64,
}

/// Represents a request to fetch historical volatility data for a specific cryptocurrency on Bybit.
/// Historical volatility measures the price fluctuation of an asset over a period, crucial for
/// assessing risk in perpetual futures trading. In perpetual futures, which are contracts without
/// an expiration date, volatility data helps traders predict price movements and adjust leverage.
/// Trading bots use this to optimize entry/exit points or hedge positions.
#[derive(Clone, Default)]
pub struct HistoricalVolatilityRequest<'a> {
    /// The base cryptocurrency (e.g., "BTC" for Bitcoin).
    /// On Bybit, this specifies the asset for which volatility is calculated. For perpetual futures,

    /// the base coin determines the trading pair (e.g., BTCUSD). Bots must validate this field to
    /// ensure the pair is supported, as an invalid coin will result in an API error.
    pub base_coin: Option<Cow<'a, str>>,

    /// The time period for volatility calculation (e.g., "7" for 7 days).
    /// This defines the lookback period for the volatility metric, typically in days. In perpetual
    /// futures, shorter periods (e.g., 7 days) are used for short-term trading strategies, while
    /// longer periods (e.g., 30 days) suit risk management. Bots should handle this flexibly to
    /// adapt to different trading horizons.
    pub period: Option<Cow<'a, str>>,

    /// The start time for the data range (e.g., "2023-01-01T00:00:00Z").
    /// Specifies the beginning of the historical data window. In perpetual futures, accurate
    /// time ranges are critical for backtesting strategies. Bots must ensure the format complies
    /// with Bybit’s API (ISO 8601) to avoid errors.
    pub start: Option<Cow<'a, str>>,

    /// The end time for the data range (e.g., "2023-12-31T23:59:59Z").
    /// Marks the end of the historical data window. This is essential for defining precise data
    /// sets in trading algorithms. Bots should validate that `end` is later than `start` to prevent
    /// invalid requests.
    pub end: Option<Cow<'a, str>>,
}

impl<'a> HistoricalVolatilityRequest<'a> {
    /// Creates a default request with BTC as the base coin.
    /// Useful for quick initialization in trading bots, but developers should override fields as
    /// needed for specific strategies.
    pub fn default() -> HistoricalVolatilityRequest<'a> {
        HistoricalVolatilityRequest::new(Some("BTC"), None, None, None)
    }
    /// Constructs a new request with specified parameters.
    /// Allows fine-grained control over the volatility query, enabling bots to target specific
    /// coins and timeframes.
    pub fn new(
        base_coin: Option<&'a str>,
        period: Option<&'a str>,
        start: Option<&'a str>,
        end: Option<&'a str>,
    ) -> HistoricalVolatilityRequest<'a> {
        HistoricalVolatilityRequest {
            base_coin: base_coin.map(Cow::Borrowed),
            period: period.map(Cow::Borrowed),
            start: start.map(Cow::Borrowed),
            end: end.map(Cow::Borrowed),
        }
    }
}

/// Represents the response from Bybit’s historical volatility API endpoint.
/// Contains metadata and a list of volatility data points for the requested cryptocurrency.
/// This is critical for bots analyzing price stability in perpetual futures markets.
#[derive(Serialize, Deserialize, Clone, Debug)]
#[serde(rename_all = "camelCase")]
pub struct HistoricalVolatilityResponse {
    /// Return code indicating the success or failure of the API request (e.g., 0 for success).
    /// Bots must check this to handle errors, such as invalid parameters or rate limits, which
    /// are common in high-frequency trading environments.
    pub ret_code: i32,

    /// Message describing the result or error (e.g., "OK" or "Invalid base coin").
    /// Provides human-readable context for debugging. Bots should log this for error handling
    /// and user notifications.
    pub ret_msg: String,

    /// The trading category (e.g., "linear" for USDT-margined perpetuals).
    /// In Bybit, "linear" refers to perpetual futures settled in USDT, while "inverse" uses the
    /// base coin (e.g., BTC). Bots need to match this with the trading pair to ensure compatibility.
    pub category: String,

    /// List of historical volatility data points.
    /// Each entry provides volatility metrics for a specific time period, used by bots to assess
    /// risk or inform trading decisions in perpetual futures markets.
    pub result: Vec<HistoricalVolatility>,
}

/// Represents a single historical volatility data point.
/// Provides volatility metrics for a specific time and period, used to gauge price fluctuation
/// risks in perpetual futures trading.
#[derive(Serialize, Deserialize, Clone, Debug)]
#[serde(rename_all = "camelCase")]
pub struct HistoricalVolatility {
    /// The time period for which volatility is calculated (e.g., 7 for 7 days).
    /// In perpetual futures, this indicates the lookback window for the volatility metric.
    /// Bots use this to align with trading strategy timeframes.
    pub period: u64,

    /// The calculated volatility value (e.g., 0.25 for 25% annualized volatility).
    /// Volatility is often expressed as a percentage, representing the standard deviation of
    /// returns. High volatility implies greater risk, impacting leverage decisions in bots.
    #[serde(with = "string_to_float")]
    pub value: f64,

    /// The timestamp of the volatility data point (Unix epoch in milliseconds).
    /// Marks when the volatility was recorded. Bots use this to sequence data and align with
    /// market events or other time-series data.
    #[serde(rename = "time", with = "string_to_u64")]
    pub timestamp: u64,
}

/// Represents the response from Bybit’s insurance fund API endpoint.
/// The insurance fund covers losses from bankrupt positions in perpetual futures, ensuring
/// market stability. Bots use this to assess exchange risk and counterparty exposure.
#[derive(Serialize, Deserialize, Clone, Debug)]
#[serde(rename_all = "camelCase")]
pub struct InsuranceResponse {
    /// Return code indicating the success or failure of the API request (e.g., 0 for success).
    /// Bots must validate this to handle API errors, such as rate limits or server issues.
    pub ret_code: i32,

    /// Message describing the result or error (e.g., "OK" or "Server error").
    /// Used for logging and debugging in trading bots to trace issues.
    pub ret_msg: String,

    /// Summary of the insurance fund data.
    /// Contains details about the fund’s balance and updates, critical for assessing Bybit’s
    /// financial health in perpetual futures markets.
    pub result: InsuranceSummary,

    /// Additional metadata (typically empty).
    /// Reserved for future use by Bybit. Bots should ignore this unless specified in the API docs.
    pub ret_ext_info: Empty,

    /// Timestamp of the response (Unix epoch in milliseconds).
    /// Indicates when the data was retrieved. Bots use this to ensure data freshness.
    pub time: u64,
}

/// Summarizes the insurance fund data for Bybit’s perpetual futures.
/// The insurance fund absorbs losses when a trader’s position is liquidated below the bankruptcy
/// price (bust price), preventing auto-deleveraging of other traders.
#[derive(Serialize, Deserialize, Clone, Debug)]
#[serde(rename_all = "camelCase")]
pub struct InsuranceSummary {
    /// Timestamp of the last update to the insurance fund (Unix epoch in milliseconds).
    /// Bots use this to verify the recency of the data, as outdated fund balances could signal risk.
    #[serde(with = "string_to_u64")]
    pub updated_time: u64,

    /// List of insurance fund entries for different coins.
    /// Each entry details the fund’s balance for a specific cryptocurrency, used to assess
    /// Bybit’s capacity to cover losses in perpetual futures.
    pub list: Vec<Insurance>,
}

/// Represents an insurance fund entry for a specific cryptocurrency.
/// Details the fund’s balance and value, which backstops losses in perpetual futures trading.
#[derive(Serialize, Deserialize, Clone, Debug)]
#[serde(rename_all = "camelCase")]
pub struct Insurance {
    /// The cryptocurrency of the insurance fund (e.g., "BTC").
    /// Specifies which asset’s fund is being described. Bots must match this with trading pairs.
    pub coin: String,

    /// The balance of the insurance fund in the specified coin (e.g., 0.5 for 0.5 BTC).
    /// A larger balance indicates a stronger buffer against liquidations. Bots monitor this to
    /// gauge exchange stability, as a depleted fund increases counterparty risk.
    #[serde(with = "string_to_float")]
    pub balance: f64,

    /// The USD value of the fund balance (e.g., "10000").
    /// Provides a standardized valuation, useful for comparing fund sizes across coins. Bots use
    /// this to assess the fund’s adequacy relative to market volatility.
    pub value: String,
}

/// Represents a request to fetch risk limit data for a trading category on Bybit.
/// Risk limits define the maximum position size and leverage for a trader, critical for
/// managing exposure in perpetual futures.
#[derive(Clone, Default)]
pub struct RiskLimitRequest<'a> {
    /// The trading category (e.g., Linear for USDT-margined perpetuals).
    /// Determines the type of futures contract. Bots must ensure this matches the trading pair.
    pub category: Category,

    /// The trading symbol (e.g., "BTCUSDT").
    /// Specifies the market for which risk limits are queried. Optional, as some endpoints allow
    /// category-wide queries. Bots should validate symbols to avoid API errors.
    pub symbol: Option<Cow<'a, str>>,
}

impl<'a> RiskLimitRequest<'a> {
    /// Creates a default request for the Linear category.
    /// Simplifies initialization for bots targeting USDT-margined perpetuals.
    pub fn default() -> RiskLimitRequest<'a> {
        RiskLimitRequest::new(Category::Linear, None)
    }
    /// Constructs a new request with specified category and symbol.
    /// Enables precise queries for risk limits, critical for bots managing leverage and position
    /// sizes in perpetual futures.
    pub fn new(category: Category, symbol: Option<&'a str>) -> RiskLimitRequest<'a> {
        RiskLimitRequest {
            category,
            symbol: symbol.map(Cow::Borrowed),
        }
    }
}

/// Represents the response from Bybit’s risk limit API endpoint.
/// Provides details on position size and leverage constraints for perpetual futures trading.
#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct RiskLimitResponse {
    /// Return code indicating the success or failure of the API request (e.g., 0 for success).
    /// Bots must check this to handle errors, such as invalid symbols or categories.
    pub ret_code: i32,

    /// Message describing the result or error (e.g., "OK" or "Invalid category").
    /// Used for logging and error handling in trading bots.
    pub ret_msg: String,

    /// Summary of risk limit data.
    /// Contains the category and a list of risk limit configurations, used by bots to adjust
    /// position sizes and leverage dynamically.
    pub result: RiskLimitSummary,

    /// Additional metadata (typically empty).
    /// Reserved for future use. Bots should ignore this unless specified in the API docs.
    pub ret_ext_info: Empty,

    /// Timestamp of the response (Unix epoch in milliseconds).
    /// Ensures data freshness, critical for real-time trading bots.
    pub time: u64,
}

/// Summarizes risk limit data for a trading category.
/// Defines constraints on position size and leverage in perpetual futures trading.
#[derive(Serialize, Deserialize, Clone, Debug)]
#[serde(rename_all = "camelCase")]
pub struct RiskLimitSummary {
    /// The trading category (e.g., "linear" for USDT-margined perpetuals).
    /// Matches the request category, ensuring data relevance. Bots use this to filter results.
    pub category: String,

    /// List of risk limit configurations.
    /// Each entry specifies leverage and margin requirements for a symbol, used by bots to
    /// manage trading constraints.
    pub list: Vec<RiskLimit>,
}

/// Represents a risk limit configuration for a trading symbol.
/// Defines leverage, margin, and position size limits for perpetual futures.
#[derive(Serialize, Deserialize, Clone, Debug)]
#[serde(rename_all = "camelCase")]
pub struct RiskLimit {
    /// Unique identifier for the risk limit tier.
    /// Used by Bybit to distinguish different risk levels. Bots can use this to track specific
    /// configurations.
    pub id: u64,

    /// The trading symbol (e.g., "BTCUSDT").
    /// Specifies the market to which the risk limit applies. Bots must match this with their
    /// trading pairs.
    pub symbol: String,

    /// The maximum position size allowed (in base currency or USD).
    /// In perpetual futures, this limits exposure to prevent excessive risk. Bots use this to
    /// cap order sizes and avoid rejections.
    #[serde(with = "string_to_float")]
    pub risk_limit_value: f64,

    /// The maintenance margin rate (e.g., 0.005 for 0.5%).
    /// The minimum margin required to keep a position open. If the margin falls below this,

    /// liquidation occurs at the bust price (bankruptcy price). Bots monitor this to manage
    /// liquidation risks.
    #[serde(with = "string_to_float")]
    pub maintenance_margin: f64,

    /// The initial margin rate (e.g., 0.01 for 1%).
    /// The margin required to open a position. Lower rates allow higher leverage, but increase
    /// liquidation risk. Bots use this to calculate capital requirements.
    #[serde(with = "string_to_float")]
    pub initial_margin: f64,

    /// Indicates if this is the lowest risk tier (1 for true, 0 for false).
    /// Lower risk tiers have stricter limits but safer margin requirements. Bots may prefer these
    /// for conservative strategies.
    pub is_lowest_risk: u8,

    /// The maximum leverage allowed (e.g., "100" for 100x).
    /// Leverage amplifies gains and losses in perpetual futures. Bots must ensure orders comply
    /// with this limit to avoid rejections.
    pub max_leverage: String,
}

/// Represents the response from Bybit’s delivery price API endpoint.
/// Delivery prices apply to futures with settlement dates, but for perpetual futures, this may
/// be used for reference or historical analysis by bots.
#[derive(Serialize, Deserialize, Clone, Debug)]
#[serde(rename_all = "camelCase")]
pub struct DeliveryPriceResponse {
    /// Return code indicating the success or failure of the API request (e.g., 0 for success).
    /// Bots must validate this to handle API errors.
    pub ret_code: i32,

    /// Message describing the result or error (e.g., "OK" or "Server error").
    /// Used for logging and debugging in trading bots.
    pub ret_msg: String,

    /// Summary of delivery price data.
    /// Contains prices and times for settled futures contracts, useful for historical analysis.
    pub result: DeliveryPriceSummary,

    /// Additional metadata (typically empty).
    /// Reserved for future use. Bots should ignore this unless specified.
    pub ret_ext_info: Empty,

    /// Timestamp of the response (Unix epoch in milliseconds).
    /// Ensures data freshness for bots analyzing historical settlement data.
    pub time: u64,
}

/// Summarizes delivery price data for futures contracts.
/// Includes pagination details and a list of delivery prices.
#[derive(Serialize, Deserialize, Clone, Debug)]
#[serde(rename_all = "camelCase")]
pub struct DeliveryPriceSummary {
    /// The trading category (e.g., "linear" for USDT-margined contracts).
    /// Specifies the contract type. Bots use this to filter relevant data.
    pub category: String,

    /// Cursor for fetching the next page of results (if any).
    /// Used for pagination in large datasets. Bots must handle this to retrieve complete data.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_page_cursor: Option<String>,

    /// List of delivery price records.
    /// Each entry provides settlement details for a futures contract, useful for historical
    /// analysis in trading bots.
    pub list: Vec<DeliveryPrice>,
}

/// Represents a delivery price record for a futures contract.
/// Details the settlement price and time, primarily for non-perpetual futures.
#[derive(Serialize, Deserialize, Clone, Debug)]
#[serde(rename_all = "camelCase")]
pub struct DeliveryPrice {
    /// The trading symbol (e.g., "BTCUSDT").
    /// Specifies the market for the delivery price. Bots use this to align with trading pairs.
    pub symbol: String,

    /// The settlement price at delivery (e.g., "50000").
    /// The price at which the contract settles. For perpetual futures, this is less relevant
    /// but may be used for benchmarking or strategy backtesting.
    pub delivery_price: String,

    /// Timestamp of the delivery (Unix epoch in milliseconds).
    /// Marks when the contract was settled. Bots use this for time-series analysis.
    #[serde(with = "string_to_u64")]
    pub delivery_time: u64,
}

/// Represents the response from Bybit’s long/short ratio API endpoint.
/// The long/short ratio shows the balance of bullish vs. bearish positions in the market,
/// critical for sentiment analysis in perpetual futures trading.
#[derive(Serialize, Deserialize, Clone, Debug)]
#[serde(rename_all = "camelCase")]
pub struct LongShortRatioResponse {
    /// Return code indicating the success or failure of the API request (e.g., 0 for success).
    /// Bots must check this to handle API errors.
    pub ret_code: i32,

    /// Message describing the result or error (e.g., "OK" or "Invalid symbol").
    /// Used for logging and error handling in trading bots.
    pub ret_msg: String,

    /// Summary of long/short ratio data.
    /// Contains a list of ratio records, used by bots to gauge market sentiment.
    pub result: LongShortRatioSummary,

    /// Additional metadata (typically empty).
    /// Reserved for future use. Bots should ignore this unless specified.
    pub ret_ext_info: Empty,

    /// Timestamp of the response (Unix epoch in milliseconds).
    /// Ensures data freshness, critical for real-time sentiment analysis.
    pub time: u64,
}

/// Summarizes long/short ratio data for a market.
/// Provides insights into trader positioning in perpetual futures.
#[derive(Serialize, Deserialize, Clone, Debug)]
#[serde(rename_all = "camelCase")]
pub struct LongShortRatioSummary {
    /// List of long/short ratio records.
    /// Each entry details the balance of long vs. short positions, used by bots for
    /// contrarian or momentum strategies.
    pub list: Vec<LongShortRatio>,
}

/// Represents a long/short ratio record for a trading symbol.
/// Shows the proportion of long vs. short positions, indicating market sentiment.
#[derive(Serialize, Deserialize, Clone, Debug)]
#[serde(rename_all = "camelCase")]
pub struct LongShortRatio {
    /// The trading symbol (e.g., "BTCUSDT").
    /// Specifies the market for the ratio. Bots use this to align with trading pairs.
    pub symbol: String,

    /// The ratio of long positions (e.g., 0.6 for 60%).
    /// A higher ratio indicates bullish sentiment. Bots use this for sentiment-based strategies,

    /// such as fading extreme ratios.
    #[serde(with = "string_to_float")]
    pub buy_ratio: f64,

    /// The ratio of short positions (e.g., 0.4 for 40%).
    /// A higher ratio indicates bearish sentiment. Bots combine this with `buy_ratio` to assess
    /// market bias and potential reversals.
    #[serde(with = "string_to_float")]
    pub sell_ratio: f64,

    /// Timestamp of the ratio data (Unix epoch in milliseconds).
    /// Marks when the ratio was recorded. Bots use this to align with market events.
    #[serde(with = "string_to_u64")]
    pub timestamp: u64,
}

/// Represents the product category for Bybit instruments.
///
/// This enum defines the possible categories of trading instruments on Bybit, used in various API requests (e.g., Kline, Orderbook, OpenInterest). For perpetual futures, `Linear` (USDT-margined) and `Inverse` (coin-margined) are the most relevant categories.
#[derive(Clone, Copy, Debug, Serialize, Deserialize, PartialEq, Default)]
pub enum Category {
    /// Spot trading pairs (e.g., BTC/USDT spot market).
    ///
    /// Represents spot markets, where assets are traded for immediate delivery. Not relevant for perpetual futures but included for completeness. Bots trading perpetuals should avoid this category.
    #[serde(rename = "spot")]
    Spot,

    /// Linear perpetual futures (USDT-margined, e.g., BTCUSDT).
    ///
    /// Represents USDT-margined perpetual futures contracts, which use USDT as the margin and settlement currency. These are popular for their simplicity and stable margin value. Bots trading perpetuals typically use this category for pairs like `BTCUSDT`.
    #[serde(rename = "linear")]
    #[default]
    Linear,

    /// Inverse perpetual futures (coin-margined, e.g., BTCUSD).
    ///
    /// Represents coin-margined perpetual futures contracts, where the base asset (e.g., BTC) is used for margin and settlement. These are more complex due to the inverse relationship between contract value and price. Bots trading inverse perpetuals (e.g., `BTCUSD`) should use this category.
    #[serde(rename = "inverse")]
    Inverse,

    /// Options contracts.
    ///
    /// Represents options markets, which involve contracts giving the right to buy or sell an asset at a specific price. Not relevant for perpetual futures but included for completeness. Bots should avoid this category for perpetuals trading.
    #[serde(rename = "option")]
    Option,
}

impl Category {
    pub fn as_str(&self) -> &str {
        match self {
            Category::Spot => "spot",
            Category::Linear => "linear",
            Category::Inverse => "inverse",
            Category::Option => "option",
        }
    }
}

/// Represents the side of an order in trading, either buying or selling.
///
/// In financial markets, the "side" of an order indicates whether the trader is
/// purchasing (Buy) or selling (Sell) an asset. For perpetual futures on Bybit,
/// this determines whether the trader is opening a long position (Buy) or a short
/// position (Sell). When writing trading bots, the side is critical for position
/// management, as it affects margin requirements and exposure to price movements.
/// For example, a Buy order in a rising market aims to profit from price increases,
/// while a Sell order in a falling market aims to profit from price declines.
/// Incorrectly setting the side can lead to unintended positions, so bots must
/// validate this field against their strategy.
#[derive(Serialize, Deserialize, Clone, Debug, Default)]
pub enum Side {
    /// Represents a buy order, initiating a long position or closing a short position.
    #[default]
    Buy,
    /// Represents a sell order, initiating a short position or closing a long position.
    Sell,
}

impl Side {
    /// Converts the `Side` enum to its string representation.
    ///
    /// This method is used to serialize the `Side` enum into a string format
    /// compatible with Bybit's API, which expects "Buy" or "Sell". Bots should use
    /// this method when constructing API requests to ensure correct formatting.
    pub fn as_str(&self) -> &str {
        match self {
            Side::Buy => "Buy",
            Side::Sell => "Sell",
        }
    }
}

/// Defines the type of order, either limit or market.
///
/// Order types determine how an order is executed in the market. A **Limit** order
/// is placed at a specific price and only executes at that price or better, offering
/// control but risking non-execution if the market moves away. A **Market** order
/// executes immediately at the best available price, ensuring execution but with
/// potential slippage (difference between expected and actual price). In perpetual
/// futures, where price volatility can be high, choosing the right order type is
/// crucial for bots. Market orders are faster but may incur higher fees (taker fees),
/// while limit orders may qualify for lower fees (maker fees) if they add liquidity.
#[derive(Serialize, Deserialize, Clone, Debug, Default)]
pub enum OrderType {
    /// A limit order, executed at a specified price or better.
    Limit,
    /// A market order, executed immediately at the best available price.
    #[default]
    Market,
}

impl OrderType {
    /// Converts the `OrderType` enum to its string representation.
    ///
    /// This method ensures the order type is formatted as "Limit" or "Market" for
    /// Bybit API requests. Bots must use this to comply with API expectations.
    pub fn as_str(&self) -> &str {
        match self {
            OrderType::Limit => "Limit",
            OrderType::Market => "Market",
        }
    }
}

/// Specifies the time-in-force policy for an order, controlling how long it remains active.
///
/// Time-in-force (TIF) dictates the duration an order stays open before it is executed
/// or canceled. In perpetual futures trading, TIF is critical for managing order
/// execution in volatile markets. For example:
/// - **GTC (Good Till Canceled)**: Remains active until filled or manually canceled, suitable for patient strategies.
/// - **IOC (Immediate or Cancel)**: Executes immediately, with any unfilled portion canceled, ideal for high-frequency trading.
/// - **FOK (Fill or Kill)**: Must be fully filled immediately or canceled, used for large orders needing guaranteed execution.
/// - **PostOnly**: Ensures the order adds liquidity (maker order) and cancels if it would take liquidity, useful for fee optimization.
///
/// Bots must carefully select TIF based on strategy. For instance, a PostOnly order
/// can reduce fees but may fail in fast-moving markets, impacting profitability.
#[derive(Serialize, Deserialize, Clone, Debug, Default)]
pub enum TimeInForce {
    /// Good Till Canceled: Order remains active until filled or canceled.
    #[default]
    GTC,
    /// Immediate or Cancel: Executes immediately, with unfilled portion canceled.
    IOC,
    /// Fill or Kill: Must be fully filled immediately or canceled.
    FOK,
    /// Post Only: Ensures the order is a maker order, cancels if it would be a taker.
    PostOnly,
}

impl TimeInForce {
    /// Converts the `TimeInForce` enum to its string representation.
    ///
    /// Returns the string format expected by Bybit's API, such as "GTC" or "PostOnly".
    /// Bots should use this method to ensure API compatibility when setting TIF.
    pub fn as_str(&self) -> &str {
        match self {
            TimeInForce::GTC => "GTC",
            TimeInForce::IOC => "IOC",
            TimeInForce::FOK => "FOK",
            TimeInForce::PostOnly => "PostOnly",
        }
    }
}

/// Represents a request to place an order on Bybit's trading platform.
///
/// The `OrderRequest` struct encapsulates all parameters needed to create an order,
/// supporting both spot and perpetual futures trading. Perpetual futures on Bybit
/// allow leveraged trading without expiration, with funding rates balancing long and
/// short positions. Bots using this struct must handle fields carefully to align with
/// trading strategies, manage risk (e.g., take-profit/stop-loss), and comply with
/// Bybit's API constraints (e.g., valid symbol, quantity precision). Incorrect
/// configurations can lead to order rebing, insufficient margin, or unintended
/// liquidations.
#[derive(Clone, Default, Serialize)]
pub struct OrderRequest<'a> {
    /// The category of the trading product (e.g., Spot, Linear for perpetual futures).
    ///
    /// Bybit organizes trading into categories like Spot (cash trading) and Linear
    /// (USDT-margined perpetual futures). For perpetual futures, `Linear` is commonly
    /// used, supporting symbols like BTCUSDT. Bots must set this correctly to target
    /// the intended market. Misconfiguring the category can result in API errors or
    /// orders placed in the wrong market, disrupting strategy execution.
    pub category: Category,

    /// The trading pair symbol, e.g., "BTCUSDT".
    ///
    /// The symbol identifies the asset pair being traded, such as BTCUSDT for Bitcoin
    /// against USDT. In perpetual futures, symbols are typically USDT-margined (Linear).
    /// Bots must ensure the symbol is valid and supported by Bybit, as invalid symbols
    /// lead to order rejection. Additionally, each symbol has specific contract details
    /// (e.g., tick size, quantity precision), which bots should validate to avoid errors.
    pub symbol: Cow<'a, str>,

    /// Indicates if the order uses leverage (true for margin trading, false otherwise).
    ///
    /// Leverage allows traders to amplify positions with borrowed funds, common in
    /// perpetual futures. For example, 10x leverage means a $1,000 position controls
    /// $10,000 of assets. Bots must set this field based on the account's margin mode
    /// (isolated or cross) and risk tolerance. High leverage increases potential returns
    /// but also liquidation risk if prices move adversely. Bots should monitor margin
    /// levels to avoid forced liquidations.
    pub is_leverage: Option<bool>,

    /// The side of the order (Buy or Sell).
    ///
    /// Specifies whether the order is to buy (long) or sell (short). In perpetual
    /// futures, Buy orders open long positions or close short ones, while Sell orders
    /// open short positions or close long ones. Bots must align the side with their
    /// market outlook and position management strategy. Incorrect sides can lead to
    /// unintended exposure, so bots should include validation logic.
    pub side: Side,

    /// The type of order (Limit or Market).
    ///
    /// Determines how the order is executed. Limit orders specify a price, while Market
    /// orders execute at the best available price. In volatile perpetual futures markets,
    /// Market orders risk slippage, while Limit orders may not execute if the price moves
    /// away. Bots should choose based on strategy goals (e.g., speed vs. price control)
    /// and account for Bybit's fee structure (maker vs. taker fees).
    pub order_type: OrderType,

    /// The quantity of the asset to trade.
    ///
    /// Represents the size of the order, typically in the base asset (e.g., BTC for
    /// BTCUSDT). In perpetual futures, quantity must adhere to Bybit's minimum and
    /// maximum limits, which vary by symbol. Bots must validate quantity against account
    /// balance, margin requirements, and symbol constraints to avoid rejections. Overly
    /// large quantities can trigger liquidations if the market moves against the position.
    pub qty: f64,

    /// The unit for market orders (optional, used in specific cases).
    ///
    /// Some Bybit markets allow specifying quantities in alternative units (e.g., USDT
    /// for Linear contracts). This field is typically used for market orders in specific
    /// trading modes. Bots should consult Bybit's API documentation for symbol-specific
    /// requirements, as incorrect units can cause order failures. Most strategies leave
    /// this as `None` unless explicitly required.
    pub market_unit: Option<f64>,

    /// The price at which to place a limit order (optional for market orders).
    ///
    /// For Limit orders, this specifies the target price. For Market orders, it’s
    /// typically `None`. In perpetual futures, price must align with the symbol’s tick
    /// size (e.g., $0.5 for BTCUSDT). Bots should validate prices against current market
    /// conditions to ensure orders are realistic. Setting prices too far from the market
    /// can prevent execution, while tight prices risk being filled at suboptimal levels.
    pub price: Option<f64>,

    /// The direction of the trigger price (true for rising, false for falling).
    ///
    /// Used for conditional orders (e.g., stop or take-profit orders), indicating whether
    /// the trigger activates when the price rises or falls. For example, a stop-loss
    /// might trigger when the price falls below a threshold. Bots must set this correctly
    /// to align with the intended risk management strategy. Incorrect directions can lead
    /// to premature or missed triggers, impacting profitability.
    pub trigger_direction: Option<bool>,

    /// A filter to specify the order type (e.g., "tpslOrder" for take-profit/stop-loss).
    ///
    /// Bybit uses order filters to categorize special order types, such as take-profit/
    /// stop-loss (TPSL) orders. For example, setting `order_filter` to "tpslOrder"
    /// indicates the order is part of a TPSL strategy. Bots must use valid filter values
    /// as per Bybit’s API to avoid rejections. This field is crucial for automated risk
    /// management in perpetual futures, where volatility necessitates robust controls.
    pub order_filter: Option<Cow<'a, str>>,

    /// The price at which a conditional order is triggered.
    ///
    /// Specifies the price level that activates a conditional order (e.g., stop-loss or
    /// take-profit). In perpetual futures, trigger prices are critical for risk management,
    /// as they define exit points for profitable or losing positions. Bots should set
    /// trigger prices based on technical analysis or risk thresholds, ensuring they align
    /// with market volatility and symbol tick sizes to avoid invalid orders.
    pub trigger_price: Option<f64>,

    /// The price type for triggering the order (e.g., "LastPrice", "IndexPrice").
    ///
    /// Defines which price metric (e.g., last traded price, index price, or mark price)
    /// triggers a conditional order. In perpetual futures, Bybit uses different price
    /// types to account for market manipulation or volatility. For example, "MarkPrice"
    /// is less susceptible to spoofing than "LastPrice". Bots must choose the appropriate
    /// trigger type to ensure reliable execution, especially in high-frequency trading.
    pub trigger_by: Option<Cow<'a, str>>,

    /// The implied volatility for options orders (optional, not used in perpetual futures).
    ///
    /// While not typically used in perpetual futures, this field applies to options
    /// trading on Bybit, representing the expected volatility of the underlying asset.
    /// Bots trading perpetual futures can ignore this field, but those expanding to
    /// options must calculate or source accurate volatility data to set this correctly.
    pub order_iv: Option<f64>,

    /// The time-in-force policy for the order.
    ///
    /// Specifies how long the order remains active (e.g., GTC, IOC). In perpetual
    /// futures, TIF affects execution strategy and fees. For example, PostOnly orders
    /// optimize for maker fees but may not execute in fast markets. Bots should select
    /// TIF based on market conditions and strategy goals, ensuring compatibility with
    /// Bybit’s API requirements.
    pub time_in_force: Option<Cow<'a, str>>,

    /// The position index for futures (0 for one-way, 1 or 2 for hedge mode).
    ///
    /// In Bybit’s perpetual futures, position index distinguishes between one-way mode
    /// (0) and hedge mode (1 for long, 2 for short). Hedge mode allows simultaneous long
    /// and short positions on the same symbol. Bots must set this correctly based on the
    /// account’s position mode to avoid order rejections. Mismanaging position index can
    /// lead to unintended position netting or increased margin requirements.
    pub position_idx: Option<u8>,

    /// A user-defined identifier for the order.
    ///
    /// Allows bots to tag orders with a custom ID for tracking and management. In
    /// perpetual futures, where multiple orders may be active, `order_link_id` helps
    /// bots correlate API responses with specific strategies. Bots should use unique,
    /// descriptive IDs to avoid confusion and ensure robust order tracking.
    pub order_link_id: Option<Cow<'a, str>>,

    /// The take-profit price for the order.
    ///
    /// Sets the price at which a position is automatically closed to lock in profits.
    /// In perpetual futures, take-profit (TP) is essential for risk management, allowing
    /// bots to exit positions at predefined profit levels. Bots should calculate TP based
    /// on market analysis and risk-reward ratios, ensuring the price is realistic given
    /// volatility and tick size constraints.
    pub take_profit: Option<f64>,

    /// The stop-loss price for the order.
    ///
    /// Sets the price at which a position is closed to limit losses. In perpetual futures,
    /// stop-loss (SL) is critical to prevent significant drawdowns, especially with
    /// leverage. Bots should set SL based on risk tolerance and market volatility, ensuring
    /// it’s not too tight (risking premature exit) or too loose (risking large losses).
    pub stop_loss: Option<f64>,

    /// The price type for triggering take-profit (e.g., "LastPrice", "MarkPrice").
    ///
    /// Specifies which price metric triggers the take-profit order. Choosing the right
    /// trigger type is crucial in perpetual futures to avoid manipulation-driven triggers.
    /// Bots should prefer stable metrics like "MarkPrice" for reliability, especially in
    /// volatile markets.
    pub tp_trigger_by: Option<Cow<'a, str>>,

    /// The price type for triggering stop-loss (e.g., "LastPrice", "MarkPrice").
    ///
    /// Specifies which price metric triggers the stop-loss order. Similar to `tp_trigger_by`,
    /// bots should select a reliable trigger type to ensure stop-loss activates as intended,
    /// protecting against adverse price movements in perpetual futures.
    pub sl_trigger_by: Option<Cow<'a, str>>,

    /// Indicates if the order reduces an existing position (true) or opens a new one (false).
    ///
    /// In perpetual futures, `reduce_only` ensures an order only closes an existing
    /// position, preventing unintended increases in exposure. Bots must set this correctly
    /// when closing positions to avoid accidentally opening opposing positions, which could
    /// increase margin requirements or trigger liquidations.
    pub reduce_only: Option<bool>,

    /// Indicates if the order closes the position when triggered (used for stop orders).
    ///
    /// When `true`, the order closes the position upon triggering, typically used for
    /// stop-loss or take-profit orders. In perpetual futures, this helps bots manage risk
    /// by ensuring automatic position closure at predefined levels. Bots should enable
    /// this for risk-limiting orders to prevent unintended position retention.
    pub close_on_trigger: Option<bool>,

    /// The type of self-match prevention (optional, for institutional traders).
    ///
    /// Self-match prevention (SMP) prevents a trader’s own orders from matching against
    /// each other, which could manipulate market perception. In perpetual futures, this
    /// is relevant for large or institutional bots to comply with exchange rules. Most
    /// retail bots can leave this as `None` unless operating at scale.
    pub smp_type: Option<Cow<'a, str>>,

    /// Indicates if the order uses market maker protection (optional).
    ///
    /// Market maker protection (MMP) prevents rapid liquidations for market makers by
    /// adjusting order execution. In perpetual futures, this is typically used by advanced
    /// bots providing liquidity. Retail bots can usually ignore this field unless
    /// participating in Bybit’s market maker program.
    pub mmp: Option<bool>,

    /// The take-profit/stop-loss mode (e.g., "Full", "Partial").
    ///
    /// Specifies whether TP/SL applies to the entire position ("Full") or a portion
    /// ("Partial"). In perpetual futures, "Full" ensures complete position closure at
    /// TP/SL levels, while "Partial" allows scaling out. Bots should choose based on
    /// strategy; "Full" is simpler for risk management, while "Partial" suits complex
    /// exit strategies.
    pub tpsl_mode: Option<Cow<'a, str>>,

    /// The limit price for take-profit orders (for limit TP orders).
    ///
    /// Specifies the exact price for a limit-based take-profit order. In perpetual futures,
    /// this allows precise profit-taking but risks non-execution if the market doesn’t
    /// reach the price. Bots should set this based on market depth and volatility to
    /// balance execution likelihood and profitability.
    pub tp_limit_price: Option<f64>,

    /// The limit price for stop-loss orders (for limit SL orders).
    ///
    /// Specifies the exact price for a limit-based stop-loss order. Similar to
    /// `tp_limit_price`, bots must balance precision with execution risk, ensuring the
    /// price is achievable in volatile perpetual futures markets to protect against losses.
    pub sl_limit_price: Option<f64>,

    /// The order type for take-profit (e.g., "Market", "Limit").
    ///
    /// Defines whether the take-profit order executes as a Market or Limit order. Market
    /// TP ensures execution but risks slippage, while Limit TP offers price control but
    /// may not fill. Bots should choose based on market conditions and strategy priorities
    /// in perpetual futures trading.
    pub tp_order_type: Option<Cow<'a, str>>,

    /// The order type for stop-loss (e.g., "Market", "Limit").
    ///
    /// Defines whether the stop-loss order executes as a Market or Limit order. Similar
    /// to `tp_order_type`, bots must weigh execution speed against price control, as
    /// Market SL orders ensure loss limitation but may incur slippage in volatile markets.
    pub sl_order_type: Option<Cow<'a, str>>,
}

impl<'a> OrderRequest<'a> {
    /// Creates a default `OrderRequest` with predefined values.
    ///
    /// Initializes an order request with common defaults (e.g., Linear category,
    /// BTCUSDT symbol, Market order). Bots can use this as a starting point and modify
    /// fields as needed. Ensure all required fields are set before submitting to Bybit’s API.
    pub fn default() -> Self {
        Self {
            category: Category::Linear,
            symbol: Cow::Borrowed("BTCUSDT"),
            is_leverage: None,
            side: Side::default(),
            order_type: OrderType::Market,
            qty: 0.00,
            market_unit: None,
            price: None,
            trigger_direction: None,
            order_filter: None,
            trigger_price: None,
            trigger_by: None,
            order_iv: None,
            time_in_force: None,
            position_idx: None,
            order_link_id: None,
            take_profit: None,
            stop_loss: None,
            tp_trigger_by: None,
            sl_trigger_by: None,
            reduce_only: None,
            close_on_trigger: None,
            smp_type: None,
            mmp: None,
            tpsl_mode: None,
            tp_limit_price: None,
            sl_limit_price: None,
            tp_order_type: None,
            sl_order_type: None,
        }
    }

    /// Creates a custom `OrderRequest` with specified parameters.
    ///
    /// Allows bots to construct an order request with full control over all fields.
    /// Ensure all parameters comply with Bybit’s API constraints (e.g., valid symbol,
    /// quantity precision) to avoid rejections. This method is ideal for tailored
    /// strategies in perpetual futures trading.
    pub fn custom(
        category: Category,
        symbol: &'a str,
        leverage: Option<bool>,
        side: Side,
        order_type: OrderType,
        qty: f64,
        market_unit: Option<f64>,
        price: Option<f64>,
        trigger_direction: Option<bool>,
        order_filter: Option<&'a str>,
        trigger_price: Option<f64>,
        trigger_by: Option<&'a str>,
        order_iv: Option<f64>,
        time_in_force: Option<&'a str>,
        position_idx: Option<u8>,
        order_link_id: Option<&'a str>,
        take_profit: Option<f64>,
        stop_loss: Option<f64>,
        tp_trigger_by: Option<&'a str>,
        sl_trigger_by: Option<&'a str>,
        reduce_only: Option<bool>,
        close_on_trigger: Option<bool>,
        smp_type: Option<&'a str>,
        mmp: Option<bool>,
        tpsl_mode: Option<&'a str>,
        tp_limit_price: Option<f64>,
        sl_limit_price: Option<f64>,
        tp_order_type: Option<&'a str>,
        sl_order_type: Option<&'a str>,
    ) -> Self {
        Self {
            category,
            symbol: Cow::Borrowed(symbol),
            is_leverage: leverage,
            side,
            order_type,
            qty,
            market_unit,
            price,
            trigger_direction,
            order_filter: order_filter.map(Cow::Borrowed),
            trigger_price,
            trigger_by: trigger_by.map(Cow::Borrowed),
            order_iv,
            time_in_force: time_in_force.map(Cow::Borrowed),
            position_idx,
            order_link_id: order_link_id.map(Cow::Borrowed),
            take_profit,
            stop_loss,
            tp_trigger_by: tp_trigger_by.map(Cow::Borrowed),
            sl_trigger_by: sl_trigger_by.map(Cow::Borrowed),
            reduce_only,
            close_on_trigger,
            smp_type: smp_type.map(Cow::Borrowed),
            mmp,
            tpsl_mode: tpsl_mode.map(Cow::Borrowed),
            tp_limit_price,
            sl_limit_price,
            tp_order_type: tp_order_type.map(Cow::Borrowed),
            sl_order_type: sl_order_type.map(Cow::Borrowed),
        }
    }

    /// Creates a spot limit order with market-based take-profit and stop-loss.
    ///
    /// Constructs a spot limit order with predefined TP/SL executed as market orders.
    /// Suitable for spot trading strategies aiming for precise entry prices with
    /// automated exits. Bots should ensure TP/SL prices are set appropriately to balance
    /// risk and reward.
    pub fn spot_limit_with_market_tpsl(
        symbol: &'a str,
        side: Side,
        qty: f64,
        price: f64,
        tp: f64,
        sl: f64,
    ) -> Self {
        Self {
            category: Category::Spot,
            symbol: Cow::Borrowed(symbol),
            side,
            order_type: OrderType::Limit,
            qty,
            price: Some(price),
            time_in_force: Some(Cow::Borrowed(TimeInForce::PostOnly.as_str())),
            take_profit: Some(tp),
            stop_loss: Some(sl),
            tp_order_type: Some(Cow::Borrowed("Market")),
            sl_order_type: Some(Cow::Borrowed("Market")),
            ..Self::default()
        }
    }

    /// Creates a spot limit order with limit-based take-profit and stop-loss.
    ///
    /// Constructs a spot limit order with TP/SL executed as limit orders for precise
    /// exit prices. Ideal for strategies prioritizing price control over execution
    /// certainty. Bots must ensure TP/SL prices are achievable given market conditions.
    pub fn spot_limit_with_limit_tpsl(
        symbol: &'a str,
        side: Side,
        qty: f64,
        price: f64,
        tp: f64,
        sl: f64,
    ) -> Self {
        Self {
            category: Category::Spot,
            symbol: Cow::Borrowed(symbol),
            side,
            order_type: OrderType::Limit,
            qty,
            price: Some(price),
            time_in_force: Some(Cow::Borrowed(TimeInForce::PostOnly.as_str())),
            take_profit: Some(tp),
            stop_loss: Some(sl),
            tp_limit_price: Some(tp),
            sl_limit_price: Some(sl),
            tp_order_type: Some(Cow::Borrowed("Limit")),
            sl_order_type: Some(Cow::Borrowed("Limit")),
            ..Self::default()
        }
    }

    /// Creates a spot post-only limit order.
    ///
    /// Constructs a spot limit order that only adds liquidity (maker order). Useful for
    /// minimizing fees but risks non-execution if the market moves away. Bots should
    /// monitor order book depth to ensure the price is competitive.
    pub fn spot_postonly(symbol: &'a str, side: Side, qty: f64, price: f64) -> Self {
        Self {
            category: Category::Spot,
            symbol: Cow::Borrowed(symbol),
            side,
            order_type: OrderType::Limit,
            qty,
            price: Some(price),
            time_in_force: Some(Cow::Borrowed(TimeInForce::PostOnly.as_str())),
            ..Self::default()
        }
    }

    /// Creates a spot take-profit/stop-loss order.
    ///
    /// Constructs a spot order specifically for TP/SL, often used to manage existing
    /// positions. The `order_filter` is set to "tpslOrder" to indicate this purpose.
    /// Bots should use this for automated risk management, ensuring the `order_link_id`
    /// is unique for tracking.
    pub fn spot_tpsl(
        symbol: &'a str,
        side: Side,
        price: f64,
        qty: f64,
        order_link_id: Option<&'a str>,
    ) -> Self {
        Self {
            category: Category::Spot,
            symbol: Cow::Borrowed(symbol),
            side,
            order_type: OrderType::Limit,
            qty,
            price: Some(price),
            time_in_force: Some(Cow::Borrowed(TimeInForce::GTC.as_str())),
            order_link_id: order_link_id.map(Cow::Borrowed),
            order_filter: Some(Cow::Borrowed("tpslOrder")),
            ..Self::default()
        }
    }

    /// Creates a spot margin order with leverage.
    ///
    /// Constructs a spot order using margin (borrowed funds). Leverage increases
    /// potential returns but also liquidation risk. Bots must monitor margin levels
    /// and ensure sufficient collateral to avoid forced liquidations.
    pub fn spot_margin(symbol: &'a str, side: Side, qty: f64, price: f64) -> Self {
        Self {
            category: Category::Spot,
            symbol: Cow::Borrowed(symbol),
            side,
            order_type: OrderType::Market,
            qty,
            price: Some(price),
            time_in_force: Some(Cow::Borrowed(TimeInForce::PostOnly.as_str())),
            is_leverage: Some(true),
            ..Self::default()
        }
    }

    /// Creates a spot market order.
    ///
    /// Constructs a spot market order for immediate execution. Ideal for strategies
    /// prioritizing speed over price control. Bots should account for slippage and
    /// taker fees, which can impact profitability in volatile markets.
    pub fn spot_market(symbol: &'a str, side: Side, qty: f64) -> Self {
        Self {
            category: Category::Spot,
            symbol: Cow::Borrowed(symbol),
            side,
            order_type: OrderType::Market,
            qty,
            time_in_force: Some(Cow::Borrowed(TimeInForce::IOC.as_str())),
            ..Self::default()
        }
    }

    /// Creates a futures limit order with market-based take-profit and stop-loss.
    ///
    /// Constructs a perpetual futures limit order with TP/SL executed as market orders.
    /// Suitable for strategies balancing precise entry with automated exits. Bots should
    /// ensure TP/SL levels align with risk management goals and market volatility.
    pub fn futures_limit_with_market_tpsl(
        symbol: &'a str,
        side: Side,
        qty: f64,
        price: f64,
        tp: f64,
        sl: f64,
    ) -> Self {
        Self {
            category: Category::Linear,
            symbol: Cow::Borrowed(symbol),
            side,
            order_type: OrderType::Limit,
            qty,
            price: Some(price),
            time_in_force: Some(Cow::Borrowed(TimeInForce::PostOnly.as_str())),
            reduce_only: Some(false),
            take_profit: Some(tp),
            stop_loss: Some(sl),
            tpsl_mode: Some(Cow::Borrowed("Full")),
            tp_order_type: Some(Cow::Borrowed("Market")),
            sl_order_type: Some(Cow::Borrowed("Market")),
            ..Self::default()
        }
    }

    /// Creates a futures limit order with limit-based take-profit and stop-loss.
    ///
    /// Constructs a perpetual futures limit order with TP/SL executed as limit orders.
    /// Ideal for precise exit price control, though execution is not guaranteed. Bots
    /// must set TP/SL prices realistically to ensure they are filled in volatile markets.
    pub fn futures_limit_with_limit_tpsl(
        symbol: &'a str,
        side: Side,
        qty: f64,
        price: f64,
        tp: f64,
        sl: f64,
    ) -> Self {
        Self {
            category: Category::Linear,
            symbol: Cow::Borrowed(symbol),
            side,
            order_type: OrderType::Limit,
            qty,
            price: Some(price),
            time_in_force: Some(Cow::Borrowed(TimeInForce::PostOnly.as_str())),
            reduce_only: Some(false),
            take_profit: Some(tp),
            stop_loss: Some(sl),
            tpsl_mode: Some(Cow::Borrowed("Partial")),
            tp_order_type: Some(Cow::Borrowed("Limit")),
            sl_order_type: Some(Cow::Borrowed("Limit")),
            tp_limit_price: Some(tp),
            sl_limit_price: Some(sl),
            ..Self::default()
        }
    }

    /// Creates a futures market order.
    ///
    /// Constructs a perpetual futures market order for immediate execution. Suitable
    /// for strategies needing fast entry or exit. Bots should account for slippage and
    /// taker fees, which can be significant in perpetual futures due to leverage and
    /// volatility.
    pub fn futures_market(symbol: &'a str, side: Side, qty: f64) -> Self {
        Self {
            category: Category::Linear,
            symbol: Cow::Borrowed(symbol),
            side,
            order_type: OrderType::Market,
            qty,
            time_in_force: Some(Cow::Borrowed(TimeInForce::IOC.as_str())),
            reduce_only: Some(false),
            ..Self::default()
        }
    }

    /// Creates a futures limit order to close a position.
    ///
    /// Constructs a perpetual futures limit order to close an existing position, with
    /// `reduce_only` set to `true`. Bots should use this to exit positions at specific
    /// prices, ensuring the `order_link_id` is unique for tracking. Validate quantity
    /// against the open position to avoid over-closing.
    pub fn futures_close_limit(
        symbol: &'a str,
        side: Side,
        qty: f64,
        price: f64,
        order_link_id: &'a str,
    ) -> Self {
        Self {
            category: Category::Linear,
            symbol: Cow::Borrowed(symbol),
            side,
            order_type: OrderType::Limit,
            qty,
            price: Some(price),
            time_in_force: Some(Cow::Borrowed(TimeInForce::GTC.as_str())),
            order_link_id: Some(Cow::Borrowed(order_link_id)),
            reduce_only: Some(true),
            ..Self::default()
        }
    }

    /// Creates a futures market order to close a position.
    ///
    /// Constructs a perpetual futures market order to immediately close an existing
    /// position. Ideal for rapid exits in volatile markets. Bots should ensure the
    /// quantity matches the open position and account for slippage and fees.
    pub fn futures_market_close(symbol: &'a str, side: Side, qty: f64) -> Self {
        Self {
            category: Category::Linear,
            symbol: Cow::Borrowed(symbol),
            side,
            order_type: OrderType::Market,
            qty,
            time_in_force: Some(Cow::Borrowed(TimeInForce::IOC.as_str())),
            reduce_only: Some(true),
            ..Self::default()
        }
    }
}

/// Represents the response from Bybit when amending an order.
///
/// This struct captures the result of an order amendment request, including success
/// status and updated order details. In perpetual futures, amending orders (e.g.,
/// changing price, quantity, or TP/SL) is common to adapt to market conditions. Bots
/// should check `ret_code` and `ret_msg` to confirm success and handle errors (e.g.,
/// invalid price, insufficient margin). The `result` field provides the updated order
/// status, which bots can use to track changes.
#[derive(Serialize, Deserialize, Clone, Debug)]
#[serde(rename_all = "camelCase")]
pub struct AmendOrderResponse {
    /// The return code indicating the success or failure of the amendment.
    ///
    /// A `ret_code` of 0 indicates success, while non-zero values indicate errors
    /// (e.g., 10001 for invalid parameters). Bots must check this field to handle
    /// failures, such as rejections due to market constraints or account issues. In
    /// perpetual futures, frequent amendments may trigger rate limits, so bots should
    /// implement retry logic with backoff.
    pub ret_code: i32,

    /// A message describing the result or error.
    ///
    /// Provides human-readable details about the amendment outcome (e.g., "OK" for
    /// success or an error description). Bots should log this for debugging and user
    /// feedback, especially when handling complex perpetual futures strategies involving
    /// multiple amendments.
    pub ret_msg: String,

    /// The updated status of the amended order.
    ///
    /// Contains the `order_id` and `order_link_id` of the amended order. Bots should
    /// use this to confirm the amendment and update internal state, ensuring consistency
    /// in tracking open positions in perpetual futures.
    pub result: OrderStatus,

    /// Additional information (typically empty).
    ///
    /// Reserved for future use by Bybit. Bots can safely ignore this field unless
    /// Bybit’s API documentation specifies new usage. In perpetual futures, this ensures
    /// forward compatibility with API updates.
    pub ret_ext_info: Empty,

    /// The timestamp of the response (in milliseconds).
    ///
    /// Indicates when the amendment was processed. Bots should use this to track latency
    /// and ensure timely updates to order state. In high-frequency perpetual futures
    /// trading, precise timing is critical for strategy execution.
    pub time: u64,
}

/// Represents a request to amend an existing order on Bybit.
///
/// This struct defines parameters for modifying an order’s attributes, such as price,
/// quantity, or TP/SL. In perpetual futures, amending orders is essential for adapting
/// to market movements (e.g., tightening stop-losses). Bots must ensure the `order_id`
/// or `order_link_id` is valid and that changes comply with Bybit’s constraints (e.g.,
/// minimum quantity, price tick size) to avoid rejections.
#[derive(Clone, Default, Serialize)]
pub struct AmendOrderRequest<'a> {
    /// The category of the trading product (e.g., Spot, Linear).
    ///
    /// Specifies the market for the order being amended. Bots must match this to the
    /// original order’s category to avoid errors. In perpetual futures, `Linear` is
    /// typical for USDT-margined contracts.
    pub category: Category,

    /// The trading pair symbol, e.g., "BTCUSDT".
    ///
    /// Identifies the asset pair of the order. Must match the original order’s symbol.
    /// Bots should validate symbol consistency to prevent API errors in perpetual futures
    /// trading.
    pub symbol: Cow<'a, str>,

    /// The unique identifier of the order to amend.
    ///
    /// Provided by Bybit when the order was created. Bots must include either `order_id`
    /// or `order_link_id` to identify the order. In perpetual futures, accurate order
    /// identification is critical for amending the correct position.
    pub order_id: Option<Cow<'a, str>>,

    /// The user-defined identifier of the order to amend.
    ///
    /// Allows bots to reference orders using their custom ID. Useful for tracking
    /// multiple orders in perpetual futures strategies. Either `order_id` or
    /// `order_link_id` must be provided.
    pub order_link_id: Option<Cow<'a, str>>,

    /// The implied volatility for options orders (optional).
    ///
    /// Used for options trading, not perpetual futures. Bots can ignore this unless
    /// amending options orders, where accurate volatility is needed for pricing.
    pub order_iv: Option<f64>,

    /// The new trigger price for conditional orders.
    ///
    /// Updates the price at which a conditional order (e.g., stop-loss) activates.
    /// In perpetual futures, bots use this to adjust risk management dynamically based
    /// on market conditions. Ensure the price aligns with symbol constraints.
    pub trigger_price: Option<f64>,

    /// The new quantity of the order.
    ///
    /// Updates the order size. In perpetual futures, bots must ensure the new quantity
    /// is valid (e.g., within position limits, sufficient margin) to avoid rejections.
    /// Over-sizing can increase liquidation risk.
    pub qty: f64,

    /// The new price for limit orders.
    ///
    /// Updates the target price for a limit order. Bots should validate the price against
    /// the symbol’s tick size and market conditions to ensure execution feasibility in
    /// volatile perpetual futures markets.
    pub price: Option<f64>,

    /// The new take-profit/stop-loss mode (e.g., "Full", "Partial").
    ///
    /// Updates whether TP/SL applies to the entire position or a portion. Bots should
    /// adjust this based on exit strategy; "Full" simplifies risk management, while
    /// "Partial" suits scaling out in perpetual futures.
    pub tpsl_mode: Option<Cow<'a, str>>,

    /// The new take-profit price.
    ///
    /// Updates the price to lock in profits. Bots should set this based on updated market
    /// analysis, ensuring it’s realistic given volatility in perpetual futures.
    pub take_profit: Option<f64>,

    /// The new stop-loss price.
    ///
    /// Updates the price to limit losses. Critical for risk management in perpetual
    /// futures, bots should adjust SL dynamically to protect against adverse price
    /// movements while avoiding premature exits.
    pub stop_loss: Option<f64>,

    /// The new trigger price type for take-profit.
    ///
    /// Updates the price metric (e.g., "MarkPrice") for TP triggering. Bots should choose
    /// a reliable metric to ensure consistent execution in perpetual futures markets.
    pub tp_trigger_by: Option<Cow<'a, str>>,

    /// The new trigger price type for stop-loss.
    ///
    /// Updates the price metric for SL triggering. Similar to `tp_trigger_by`, bots
    /// should select a stable trigger type to protect against manipulation in perpetual
    /// futures.
    pub sl_trigger_by: Option<Cow<'a, str>>,

    /// The new trigger price type for conditional orders.
    ///
    /// Updates the price metric for triggering conditional orders. Bots should ensure
    /// consistency with the order’s strategy and market conditions in perpetual futures.
    pub trigger_by: Option<Cow<'a, str>>,

    /// The new limit price for take-profit orders.
    ///
    /// Updates the exact price for limit-based TP orders. Bots must balance precision
    /// with execution likelihood in volatile perpetual futures markets.
    pub tp_limit_price: Option<f64>,

    /// The new limit price for stop-loss orders.
    ///
    /// Updates the exact price for limit-based SL orders. Bots should ensure the price
    /// is achievable to effectively limit losses in perpetual futures.
    pub sl_limit_price: Option<f64>,
}

impl<'a> AmendOrderRequest<'a> {
    /// Creates a default `AmendOrderRequest` with predefined values.
    ///
    /// Initializes an amendment request with common defaults. Bots should modify
    /// necessary fields before submission to align with the target order’s attributes.
    pub fn default() -> Self {
        Self {
            category: Category::Linear,
            symbol: Cow::Borrowed("BTCUSDT"),
            order_id: None,
            order_link_id: None,
            order_iv: None,
            trigger_price: None,
            qty: 0.00,
            price: None,
            tpsl_mode: None,
            take_profit: None,
            stop_loss: None,
            tp_trigger_by: None,
            sl_trigger_by: None,
            trigger_by: None,
            tp_limit_price: None,
            sl_limit_price: None,
        }
    }

    /// Creates a custom `AmendOrderRequest` with specified parameters.
    ///
    /// Allows bots to tailor an amendment request fully. Ensure all parameters are valid
    /// and consistent with the original order to avoid API errors in perpetual futures
    /// trading.
    pub fn custom(
        category: Category,
        symbol: &'a str,
        order_id: Option<&'a str>,
        order_link_id: Option<&'a str>,
        order_iv: Option<f64>,
        trigger_price: Option<f64>,
        qty: f64,
        price: Option<f64>,
        tpsl_mode: Option<&'a str>,
        take_profit: Option<f64>,
        stop_loss: Option<f64>,
        tp_trigger_by: Option<&'a str>,
        sl_trigger_by: Option<&'a str>,
        trigger_by: Option<&'a str>,
        tp_limit_price: Option<f64>,
        sl_limit_price: Option<f64>,
    ) -> Self {
        Self {
            category,
            symbol: Cow::Borrowed(symbol),
            order_id: order_id.map(Cow::Borrowed),
            order_link_id: order_link_id.map(Cow::Borrowed),
            order_iv,
            trigger_price,
            qty,
            price,
            tpsl_mode: tpsl_mode.map(Cow::Borrowed),
            take_profit,
            stop_loss,
            tp_trigger_by: tp_trigger_by.map(Cow::Borrowed),
            sl_trigger_by: sl_trigger_by.map(Cow::Borrowed),
            trigger_by: trigger_by.map(Cow::Borrowed),
            tp_limit_price,
            sl_limit_price,
        }
    }
}

/// Represents a request to cancel an order on Bybit.
///
/// This struct defines parameters to cancel an existing order, identified by `order_id`
/// or `order_link_id`. In perpetual futures, canceling orders is common to adjust
/// strategies or avoid unwanted executions. Bots must ensure accurate identification
/// and handle API responses to confirm cancellation, as untracked orders can lead to
/// unintended positions.
#[derive(Clone, Serialize)]
pub struct CancelOrderRequest<'a> {
    /// The category of the trading product (e.g., Spot, Linear).
    ///
    /// Specifies the market of the order to cancel. Must match the original order’s
    /// category to avoid errors. In perpetual futures, `Linear` is typical.
    pub category: Category,

    /// The trading pair symbol, e.g., "BTCUSDT".
    ///
    /// Identifies the asset pair of the order. Must match the original order’s symbol.
    /// Bots should validate symbol consistency to ensure correct cancellation.
    pub symbol: Cow<'a, str>,

    /// The unique identifier of the order to cancel.
    ///
    /// Provided by Bybit when the order was created. Either `order_id` or
    /// `order_link_id` must be provided to identify the order for cancellation.
    pub order_id: Option<Cow<'a, str>>,

    /// The user-defined identifier of the order to cancel.
    ///
    /// Allows bots to reference orders using their custom ID. Useful for tracking
    /// cancellations in complex perpetual futures strategies.
    pub order_link_id: Option<Cow<'a, str>>,

    /// A filter to specify the order type (e.g., "tpslOrder").
    ///
    /// Used to target specific order types for cancellation, such as TP/SL orders.
    /// Bots should set this correctly to cancel the intended orders in perpetual futures.
    pub order_filter: Option<Cow<'a, str>>,
}

/// Represents the response from Bybit when canceling an order.
///
/// This struct captures the result of an order cancellation request. Bots should check
/// `ret_code` and `ret_msg` to confirm success and handle errors (e.g., order already
/// filled). The `result` field provides the canceled order’s status, aiding in state
/// management for perpetual futures trading.
#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct CancelOrderResponse {
    /// The return code indicating the success or failure of the cancellation.
    ///
    /// A `ret_code` of 0 indicates success, while non-zero values indicate errors.
    /// Bots must handle errors, such as attempting to cancel a filled order, and
    /// implement retry logic if needed in perpetual futures trading.
    pub ret_code: i32,

    /// A message describing the result or error.
    ///
    /// Provides details about the cancellation outcome. Bots should log this for
    /// debugging and to inform users of issues in perpetual futures strategies.
    pub ret_msg: String,

    /// The status of the canceled order.
    ///
    /// Contains the `order_id` and `order_link_id` of the canceled order. Bots should
    /// use this to update internal state and confirm cancellation in perpetual futures.
    pub result: OrderStatus,

    /// Additional information (typically empty).
    ///
    /// Reserved for future use. Bots can ignore this unless Bybit specifies new usage.
    pub ret_ext_info: Empty,

    /// The timestamp of the response (in milliseconds).
    ///
    /// Indicates when the cancellation was processed. Bots should use this to track
    /// latency and ensure timely state updates in high-frequency perpetual futures
    /// trading.
    pub time: u64,
}

/// Represents a request to retrieve open orders on Bybit.
///
/// This struct defines parameters to query active orders, filtered by symbol, category,
/// or other criteria. In perpetual futures, monitoring open orders is critical for
/// position management and strategy adjustments. Bots should use this to track pending
/// orders and avoid over-leveraging or unintended executions.
#[derive(Clone, Default)]
pub struct OpenOrdersRequest<'a> {
    /// The category of the trading product (e.g., Spot, Linear).
    ///
    /// Specifies the market to query. Bots must set this to match the target market,
    /// typically `Linear` for perpetual futures.
    pub category: Category,

    /// The trading pair symbol, e.g., "BTCUSDT".
    ///
    /// Filters orders by symbol. Bots can set this to focus on specific assets or leave
    /// it broad to retrieve all orders in the category.
    pub symbol: Cow<'a, str>,

    /// The base coin of the trading pair (e.g., "BTC").
    ///
    /// Filters orders by the base asset. Useful for bots managing multiple pairs in
    /// perpetual futures, allowing targeted queries.
    pub base_coin: Option<Cow<'a, str>>,

    /// The settlement coin (e.g., "USDT").
    ///
    /// Filters orders by the quote asset. Bots can use this to narrow down queries in
    /// USDT-margined perpetual futures markets.
    pub settle_coin: Option<Cow<'a, str>>,

    /// The unique identifier of a specific order.
    ///
    /// Allows querying a single order by its Bybit-provided ID. Bots should use this
    /// for precise order tracking in perpetual futures.
    pub order_id: Option<Cow<'a, str>>,

    /// The user-defined identifier of a specific order.
    ///
    /// Allows querying a single order by its custom ID. Useful for bots tracking orders
    /// across multiple strategies in perpetual futures.
    pub order_link_id: Option<Cow<'a, str>>,

    /// Filters orders by open status (0, 1, or 2).
    ///
    /// Specifies whether to retrieve all orders (0), open orders (1), or partially
    /// filled orders (2). Bots should set this based on monitoring needs in perpetual
    /// futures trading.
    pub open_only: Option<usize>,

    /// A filter to specify the order type (e.g., "tpslOrder").
    ///
    /// Targets specific order types, such as TP/SL orders. Bots should use this to
    /// focus on relevant orders in perpetual futures risk management.
    pub order_filter: Option<Cow<'a, str>>,

    /// The maximum number of orders to return.
    ///
    /// Limits the response size, typically up to 50. Bots should set this to manage
    /// API response sizes and avoid rate limits in perpetual futures trading.
    pub limit: Option<usize>,
}

impl<'a> OpenOrdersRequest<'a> {
    /// Creates a default `OpenOrdersRequest` with predefined values.
    ///
    /// Initializes a query with common defaults. Bots should modify fields as needed
    /// to target specific orders in perpetual futures.
    pub fn default() -> Self {
        Self {
            category: Category::Linear,
            symbol: Cow::Borrowed("BTCUSDT"),
            base_coin: None,
            settle_coin: None,
            order_id: None,
            order_link_id: None,
            open_only: None,
            order_filter: None,
            limit: None,
        }
    }

    /// Creates a custom `OpenOrdersRequest` with specified parameters.
    ///
    /// Allows bots to tailor the query fully. Ensure parameters are valid to avoid
    /// API errors, and set `open_only` within the allowed range (0–2) for perpetual
    /// futures trading.
    pub fn custom(
        category: Category,
        symbol: &'a str,
        base_coin: Option<&'a str>,
        settle_coin: Option<&'a str>,
        order_id: Option<&'a str>,
        order_link_id: Option<&'a str>,
        open_only: usize,
        order_filter: Option<&'a str>,
        limit: Option<usize>,
    ) -> Self {
        Self {
            category,
            symbol: Cow::Borrowed(symbol),
            base_coin: base_coin.map(Cow::Borrowed),
            settle_coin: settle_coin.map(Cow::Borrowed),
            order_id: order_id.map(Cow::Borrowed),
            order_link_id: order_link_id.map(Cow::Borrowed),
            open_only: match open_only {
                0..=2 => Some(open_only),
                _ => None,
            },
            order_filter: order_filter.map(Cow::Borrowed),
            limit,
        }
    }
}

/// Represents the response from Bybit when querying open orders.
///
/// This struct captures the list of open orders and metadata. Bots should parse the
/// `result` field to track active orders and use `next_page_cursor` for pagination
/// in perpetual futures trading. Check `ret_code` and `ret_msg` to handle errors.
#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct OpenOrdersResponse {
    /// The return code indicating the success or failure of the query.
    ///
    /// A `ret_code` of 0 indicates success. Non-zero values indicate errors, which
    /// bots must handle to ensure robust querying in perpetual futures trading.
    pub ret_code: i32,

    /// A message describing the result or error.
    ///
    /// Provides details about the query outcome. Bots should log this for debugging
    /// and user feedback in perpetual futures strategies.
    pub ret_msg: String,

    /// The list of open orders and pagination details.
    ///
    /// Contains the orders matching the query criteria. Bots should process this to
    /// update internal state and manage positions in perpetual futures.
    pub result: OrderHistory,

    /// Additional information (typically empty).
    ///
    /// Reserved for future use. Bots can ignore this unless specified by Bybit.
    pub ret_ext_info: Empty,

    /// The timestamp of the response (in milliseconds).
    ///
    /// Indicates when the query was processed. Bots should use this for latency
    /// tracking in high-frequency perpetual futures trading.
    pub time: u64,
}

/// Represents the status of an order, including its identifiers.
///
/// This struct provides the `order_id` and `order_link_id` for an order, used in
/// responses for order placement, amendment, or cancellation. In perpetual futures,
/// bots use this to track orders and correlate API responses with internal state.
#[derive(Serialize, Deserialize, Clone, Debug)]
#[serde(rename_all = "camelCase")]
pub struct OrderStatus {
    /// The unique identifier of the order provided by Bybit.
    ///
    /// Used to reference the order in API requests and responses. Bots must store
    /// this to manage orders effectively in perpetual futures trading.
    pub order_id: String,

    /// The user-defined identifier of the order.
    ///
    /// Allows bots to track orders using custom IDs. Essential for complex strategies
    /// in perpetual futures where multiple orders are active.
    pub order_link_id: String,
}

/// Represents the response from Bybit when placing an order.
///
/// This struct captures the result of an order placement request. Bots should check
/// `ret_code` and `ret_msg` to confirm success and handle errors (e.g., insufficient
/// margin). The `result` field provides the new order’s status for tracking in
/// perpetual futures trading.
#[derive(Serialize, Deserialize, Clone, Debug)]
#[serde(rename_all = "camelCase")]
pub struct OrderResponse {
    /// The return code indicating the success or failure of the order placement.
    ///
    /// A `ret_code` of 0 indicates success. Non-zero values indicate errors, which
    /// bots must handle to ensure reliable order placement in perpetual futures.
    pub ret_code: i32,

    /// A message describing the result or error.
    ///
    /// Provides details about the order placement outcome. Bots should log this for
    /// debugging and user feedback in perpetual futures strategies.
    pub ret_msg: String,

    /// The status of the newly placed order.
    ///
    /// Contains the `order_id` and `order_link_id`. Bots should use this to track
    /// the order and update internal state in perpetual futures trading.
    pub result: OrderStatus,

    /// Additional information (typically empty).
    ///
    /// Reserved for future use. Bots can ignore this unless specified by Bybit.
    pub ret_ext_info: Empty,

    /// The timestamp of the response (in milliseconds).
    ///
    /// Indicates when the order was processed. Bots should use this for latency
    /// tracking in high-frequency perpetual futures trading.
    pub time: u64,
}

/// Represents a request to retrieve order history on Bybit.
///
/// This struct defines parameters to query past orders, filtered by time, symbol,
/// or status. In perpetual futures, order history is crucial for auditing performance
/// and refining strategies. Bots should use this to analyze executed orders and
/// adjust trading logic accordingly.
#[derive(Clone, Default)]
pub struct OrderHistoryRequest<'a> {
    /// The category of the trading product (e.g., Spot, Linear).
    ///
    /// Specifies the market to query. Bots must set this to match the target market,
    /// typically `Linear` for perpetual futures.
    pub category: Category,

    /// The trading pair symbol, e.g., "BTCUSDT".
    ///
    /// Filters orders by symbol. Bots can set this to focus on specific assets or
    /// leave it as `None` for all orders in the category.
    pub symbol: Option<Cow<'a, str>>,

    /// The base coin of the trading pair (e.g., "BTC").
    ///
    /// Filters orders by the base asset. Useful for analyzing specific assets in
    /// perpetual futures trading.
    pub base_coin: Option<Cow<'a, str>>,

    /// The settlement coin (e.g., "USDT").
    ///
    /// Filters orders by the quote asset. Useful for USDT-margined perpetual futures
    /// markets.
    pub settle_coin: Option<Cow<'a, str>>,

    /// The unique identifier of a specific order.
    ///
    /// Allows querying a single order by its Bybit-provided ID. Bots should use this
    /// for precise historical analysis.
    pub order_id: Option<Cow<'a, str>>,

    /// The user-defined identifier of a specific order.
    ///
    /// Allows querying a single order by its custom ID. Useful for tracking specific
    /// orders in perpetual futures strategies.
    pub order_link_id: Option<Cow<'a, str>>,

    /// A filter to specify the order type (e.g., "tpslOrder").
    ///
    /// Targets specific order types, such as TP/SL orders. Bots should use this to
    /// analyze relevant orders in perpetual futures.
    pub order_filter: Option<Cow<'a, str>>,

    /// The status of the orders to query (e.g., "Filled", "Cancelled").
    ///
    /// Filters orders by their execution status. Bots can use this to focus on
    /// completed or canceled orders for performance analysis in perpetual futures.
    pub order_status: Option<Cow<'a, str>>,

    /// The start time for the query (in milliseconds).
    ///
    /// Filters orders created after this timestamp. Bots should use this to narrow
    /// down historical data for specific periods in perpetual futures trading.
    pub start_time: Option<u64>,

    /// The end time for the query (in milliseconds).
    ///
    /// Filters orders created before this timestamp. Bots should pair this with
    /// `start_time` for precise time-based queries.
    pub end_time: Option<u64>,

    /// The maximum number of orders to return.
    ///
    /// Limits the response size, typically up to 50. Bots should set this to manage
    /// API response sizes and avoid rate limits in perpetual futures trading.
    pub limit: Option<u64>,
}

impl<'a> OrderHistoryRequest<'a> {
    /// Creates a default `OrderHistoryRequest` with predefined values.
    ///
    /// Initializes a query with common defaults. Bots should modify fields to target
    /// specific historical orders in perpetual futures.
    pub fn default() -> Self {
        Self {
            category: Category::Linear,
            symbol: None,
            base_coin: None,
            settle_coin: None,
            order_id: None,
            order_link_id: None,
            order_filter: None,
            order_status: None,
            start_time: None,
            end_time: None,
            limit: None,
        }
    }

    /// Creates a custom `OrderHistoryRequest` with specified parameters.
    ///
    /// Allows bots to tailor the query fully. Ensure parameters are valid to avoid
    /// API errors in perpetual futures trading.
    pub fn new(
        category: Category,
        symbol: Option<&'a str>,
        base_coin: Option<&'a str>,
        settle_coin: Option<&'a str>,
        order_id: Option<&'a str>,
        order_link_id: Option<&'a str>,
        order_filter: Option<&'a str>,
        order_status: Option<&'a str>,
        start_time: Option<u64>,
        end_time: Option<u64>,
        limit: Option<u64>,
    ) -> Self {
        Self {
            category,
            symbol: symbol.map(Cow::Borrowed),
            base_coin: base_coin.map(Cow::Borrowed),
            settle_coin: settle_coin.map(Cow::Borrowed),
            order_id: order_id.map(Cow::Borrowed),
            order_link_id: order_link_id.map(Cow::Borrowed),
            order_filter: order_filter.map(Cow::Borrowed),
            order_status: order_status.map(Cow::Borrowed),
            start_time,
            end_time,
            limit,
        }
    }
}

/// Represents the response from Bybit when querying order history.
///
/// This struct captures the list of past orders and metadata. Bots should parse the
/// `result` field to analyze executed orders and use `next_page_cursor` for pagination
/// in perpetual futures trading. Check `ret_code` and `ret_msg` to handle errors.
#[derive(Serialize, Deserialize, Clone, Debug)]
#[serde(rename_all = "camelCase")]
pub struct OrderHistoryResponse {
    /// The return code indicating the success or failure of the query.
    ///
    /// A `ret_code` of 0 indicates success. Non-zero values indicate errors, which
    /// bots must handle to ensure robust querying in perpetual futures trading.
    pub ret_code: i32,

    /// A message describing the result or error.
    ///
    /// Provides details about the query outcome. Bots should log this for debugging
    /// and user feedback in perpetual futures strategies.
    pub ret_msg: String,

    /// The list of historical orders and pagination details.
    ///
    /// Contains the orders matching the query criteria. Bots should process this to
    /// analyze performance and refine strategies in perpetual futures.
    pub result: OrderHistory,

    /// Additional information (typically empty).
    ///
    /// Reserved for future use. Bots can ignore this unless specified by Bybit.
    #[serde(rename = "retExtInfo")]
    pub ret_ext_info: Empty,

    /// The timestamp of the response (in milliseconds).
    ///
    /// Indicates when the query was processed. Bots should use this for latency
    /// tracking in high-frequency perpetual futures trading.
    pub time: u64,
}

/// Represents a collection of historical orders with pagination information.
///
/// This struct contains the list of orders and a cursor for fetching additional pages.
/// In perpetual futures, bots use this to analyze trading history, calculate performance
/// metrics, and adjust strategies based on past executions.
#[derive(Serialize, Deserialize, Clone, Debug)]
#[serde(rename_all = "camelCase")]
pub struct OrderHistory {
    /// The category of the orders (e.g., "spot", "linear").
    ///
    /// Indicates the market of the orders (e.g., Spot or Linear for perpetual futures).
    /// Bots should verify this matches the query to ensure correct data processing.
    pub category: String,

    /// The list of historical orders.
    ///
    /// Contains detailed information about each order. Bots should iterate over this
    /// to extract metrics like execution price, fees, and status for perpetual futures
    /// analysis.
    pub list: Vec<Order>,

    /// The cursor for fetching the next page of results.
    ///
    /// Used for pagination when the query returns more orders than the `limit`. Bots
    /// should include this in subsequent requests to retrieve additional orders in
    /// perpetual futures trading.
    #[serde(skip_serializing_if = "String::is_empty")]
    pub next_page_cursor: String,
}

/// Represents a single order with detailed attributes.
///
/// This struct provides comprehensive details about an order, including its execution
/// status, prices, quantities, and fees. In perpetual futures trading on Bybit, this
/// struct is used to track the lifecycle of an order, from placement to execution or
/// cancellation. Perpetual futures are financial derivatives that allow leveraged
/// trading without an expiration date, balanced by funding rates. Bots use this struct
/// to monitor order progress, calculate profitability, manage positions, and handle
/// risk. Fields like `avg_price`, `cum_exec_fee`, and `take_profit` are critical for
/// performance analysis and risk management in volatile markets.
#[derive(Serialize, Deserialize, Clone, Debug)]
#[serde(rename_all = "camelCase")]
pub struct Order {
    /// The unique identifier of the order provided by Bybit.
    ///
    /// This is a system-generated ID assigned when the order is created. In perpetual
    /// futures, `order_id` is essential for tracking orders across API requests (e.g.,
    /// amending, canceling, or querying status). Bots must store and reference this ID
    /// to manage orders accurately, especially in high-frequency trading where multiple
    /// orders are active. Losing track of `order_id` can lead to orphaned orders or
    /// mismanaged positions, impacting strategy execution.
    pub order_id: String,

    /// The user-defined identifier of the order.
    ///
    /// A custom ID set by the trader to track the order. In perpetual futures, where
    /// bots may manage numerous orders, `order_link_id` provides a way to correlate
    /// orders with specific strategies or logic. Bots should use unique, descriptive
    /// IDs to avoid confusion and ensure robust order tracking. If not set, it’s an
    /// empty string, but bots should always assign a value for traceability.
    pub order_link_id: String,

    /// The identifier for block trades (optional).
    ///
    /// Represents the ID of a block trade, which is a large order executed off the
    /// public order book, typically for institutional traders. In perpetual futures,
    /// this field is usually `None` for retail bots, as block trades are less common.
    /// For bots handling large orders, this field helps track such trades, ensuring
    /// compliance with Bybit’s reporting requirements. Bots should log this for
    /// auditing if applicable.
    #[serde(
        deserialize_with = "empty_string_as_none",
        skip_serializing_if = "is_empty_or_none"
    )]
    pub block_trade_id: Option<String>,

    /// The trading pair symbol, e.g., "BTCUSDT".
    ///
    /// Identifies the asset pair of the order (e.g., BTCUSDT for Bitcoin against USDT).
    /// In perpetual futures, symbols are typically USDT-margined (Linear category).
    /// Bots must validate that the symbol is supported by Bybit and align order
    /// parameters (e.g., price, quantity) with the symbol’s contract specifications
    /// (e.g., tick size, minimum quantity). This field is critical for correlating
    /// orders with market data and ensuring strategy consistency.
    pub symbol: String,

    /// The price of the order.
    ///
    /// For limit orders, this is the specified price at which the order is placed; for
    /// market orders, it’s the executed price. In perpetual futures, price must adhere
    /// to the symbol’s tick size (e.g., $0.5 for BTCUSDT). Bots should use this field
    /// to verify execution against market conditions and calculate profitability. For
    /// limit orders, setting prices too far from the market may prevent execution,
    /// while market orders risk slippage in volatile markets.
    #[serde(with = "string_to_float")]
    pub price: f64,

    /// The quantity of the order.
    ///
    /// Represents the size of the order in the base asset (e.g., BTC for BTCUSDT).
    /// In perpetual futures, quantity must comply with Bybit’s minimum and maximum
    /// limits, which vary by symbol. Bots should validate this against account balance,
    /// margin requirements, and symbol constraints to avoid rejections. Over-sizing
    /// quantities can increase liquidation risk, especially with leverage, so bots
    /// must carefully manage this field.
    #[serde(with = "string_to_float")]
    pub qty: f64,

    /// The side of the order (Buy or Sell).
    ///
    /// Indicates whether the order is to buy (long) or sell (short). In perpetual
    /// futures, Buy orders open long positions or close short ones, while Sell orders
    /// open short positions or close long ones. Bots must align this with their market
    /// outlook and position management strategy. Incorrect sides can lead to unintended
    /// exposure, so bots should include validation logic to prevent errors.
    pub side: Side,

    /// Indicates if leverage was used (empty string for false).
    ///
    /// A non-empty string (e.g., "1") indicates the order used leverage, common in
    /// perpetual futures to amplify position sizes. Leverage increases potential
    /// returns but also liquidation risk if prices move adversely. Bots should check
    /// this field to confirm margin usage and monitor account health, ensuring
    /// sufficient collateral to avoid forced liquidations. For non-leveraged orders,
    /// this is an empty string.
    #[serde(skip_serializing_if = "String::is_empty")]
    pub is_leverage: String,

    /// The position index (0 for one-way, 1 or 2 for hedge mode).
    ///
    /// Specifies the position mode: 0 for one-way mode (single position per symbol),
    /// 1 for long, or 2 for short in hedge mode (allowing simultaneous long and short
    /// positions). In perpetual futures, bots must ensure this matches the account’s
    /// position mode to avoid order rejections. Mismanaging `position_idx` can lead to
    /// unintended position netting or increased margin requirements, disrupting
    /// strategy execution.
    pub position_idx: i32,

    /// The current status of the order (e.g., "New", "Filled", "Cancelled").
    ///
    /// Indicates the order’s lifecycle stage, such as "New" (pending), "PartiallyFilled",
    /// "Filled", or "Cancelled". In perpetual futures, bots should monitor this to track
    /// execution progress and handle edge cases (e.g., partial fills or cancellations).
    /// For example, a "PartiallyFilled" status requires bots to adjust position sizes
    /// and risk calculations. This field is critical for state management and strategy
    /// adaptation.
    pub order_status: String,

    /// The reason for cancellation (if applicable).
    ///
    /// Specifies why an order was canceled, such as "CancelByUser" or "Timeout". In
    /// perpetual futures, understanding cancellation reasons helps bots diagnose issues
    /// (e.g., market conditions preventing execution) and refine strategies. Bots
    /// should log this field for auditing and use it to trigger fallback logic, such
    /// as resubmitting orders with adjusted parameters.
    pub cancel_type: String,

    /// The reason for order rejection (if applicable).
    ///
    /// Explains why an order was rejected by Bybit, such as "InsufficientBalance" or
    /// "InvalidPrice". In perpetual futures, rejections can occur due to margin
    /// constraints, invalid parameters, or market limits. Bots must handle this field
    /// to diagnose and resolve issues, implementing error-handling logic to adjust
    /// order parameters (e.g., reducing quantity) or retrying after funding the account.
    pub reject_reason: String,

    /// The average execution price (optional).
    ///
    /// The weighted average price of executed portions for partially or fully filled
    /// orders. In perpetual futures, bots use this to calculate realized profitability
    /// and compare against market prices. For example, a lower `avg_price` than
    /// expected for a Buy order indicates slippage. If `None`, the order has not been
    /// filled. Bots should monitor this to assess execution quality and optimize order
    /// types (e.g., preferring limit orders to reduce slippage).
    #[serde(with = "string_to_float_optional")]
    pub avg_price: Option<f64>,

    /// The remaining quantity to be executed.
    ///
    /// Indicates the unfilled portion of the order’s quantity. In perpetual futures,
    /// bots should monitor this to determine if an order is partially filled and adjust
    /// position sizing or risk calculations. A non-zero `leaves_qty` for a limit order
    /// may indicate the price is too far from the market, prompting bots to amend the
    /// order or cancel and resubmit at a better price.
    #[serde(with = "string_to_float")]
    pub leaves_qty: f64,

    /// The remaining value to be executed.
    ///
    /// The monetary value of the unfilled portion (typically `leaves_qty` multiplied
    /// by the order price). In perpetual futures, bots can use this to assess exposure
    /// and margin requirements for pending orders. This field helps quantify the
    /// potential impact of unfilled orders on account health, especially in leveraged
    /// trading scenarios.
    #[serde(with = "string_to_float")]
    pub leaves_value: f64,

    /// The cumulative executed quantity.
    ///
    /// The total quantity filled so far. In perpetual futures, bots should use this
    /// to track order progress and update position sizes. For example, if
    /// `cum_exec_qty` is less than `qty`, the order is partially filled, requiring
    /// bots to manage the open position and any remaining risk. This field is critical
    /// for accurate position tracking and strategy execution.
    #[serde(with = "string_to_float")]
    pub cum_exec_qty: f64,

    /// The cumulative executed value.
    ///
    /// The total monetary value of filled portions (typically `cum_exec_qty` multiplied
    /// by the execution prices). In perpetual futures, bots use this to calculate the
    /// cost basis of a position and assess profitability. This field helps bots
    /// determine the financial impact of executed trades, especially for leveraged
    /// positions where margin requirements are dynamic.
    #[serde(with = "string_to_float")]
    pub cum_exec_value: f64,

    /// The cumulative execution fees.
    ///
    /// The total fees incurred for executed portions of the order. In perpetual
    /// futures, fees vary based on order type: maker orders (e.g., PostOnly limit
    /// orders) typically have lower or negative fees, while taker orders (e.g., market
    /// orders) have higher fees. Bots should monitor this closely, as fees impact
    /// profitability, especially in high-frequency trading. Optimizing for maker orders
    /// can reduce costs, and bots should log this field for performance analysis.
    #[serde(with = "string_to_float")]
    pub cum_exec_fee: f64,

    /// The time-in-force policy of the order.
    ///
    /// Specifies how long the order was active, such as "GTC" (Good Till Canceled),
    /// "IOC" (Immediate or Cancel), "FOK" (Fill or Kill), or "PostOnly". In perpetual
    /// futures, TIF affects execution strategy and fees. For example, PostOnly orders
    /// optimize for maker fees but may not execute in fast markets. Bots should verify
    /// this field to ensure the order’s behavior aligns with the strategy and adjust
    /// TIF for future orders if needed.
    pub time_in_force: String,

    /// The type of order (Limit or Market).
    ///
    /// Indicates whether the order was a limit order (executed at a specified price)
    /// or a market order (executed at the best available price). In perpetual futures,
    /// limit orders offer price control but risk non-execution, while market orders
    /// ensure execution but may incur slippage and higher fees. Bots should use this
    /// field to confirm order type and assess execution performance, optimizing for
    /// cost or speed based on strategy goals.
    pub order_type: OrderType,

    /// The type of stop order (optional, e.g., "StopLoss").
    ///
    /// Specifies if the order was a conditional stop order, such as "StopLoss" or
    /// "TakeProfit". In perpetual futures, stop orders are critical for risk
    /// management, automatically closing positions at predefined levels. If `None`,
    /// the order is not a stop order. Bots should use this field to identify risk
    /// management orders and ensure they align with the strategy’s exit conditions.
    #[serde(
        deserialize_with = "empty_string_as_none",
        skip_serializing_if = "is_empty_or_none"
    )]
    pub stop_order_type: Option<String>,

    /// The implied volatility for options orders (optional).
    ///
    /// Represents the expected volatility for options orders, not applicable to
    /// perpetual futures. In Bybit’s API, this field is relevant only for options
    /// trading, where volatility affects pricing. Bots trading perpetual futures can
    /// ignore this field, but those expanding to options must source accurate
    /// volatility data to interpret this correctly.
    #[serde(
        deserialize_with = "empty_string_as_none",
        skip_serializing_if = "is_empty_or_none"
    )]
    pub order_iv: Option<String>,

    /// The trigger price for conditional orders (optional).
    ///
    /// The price at which a conditional order (e.g., stop-loss or take-profit)
    /// activates. In perpetual futures, trigger prices are essential for risk
    /// management, defining exit points for profitable or losing positions. If `None`,
    /// the order is not conditional. Bots should verify this field to ensure risk
    /// management settings are correct and adjust trigger prices based on market
    /// volatility and strategy goals.
    #[serde(with = "string_to_float_optional")]
    pub trigger_price: Option<f64>,

    /// The take-profit price (optional).
    ///
    /// The price at which the position is closed to lock in profits. In perpetual
    /// futures, take-profit (TP) is critical for securing gains in volatile markets.
    /// If `None`, no TP is set. Bots should use this field to confirm TP settings and
    /// calculate realized profits, ensuring the price is realistic given market
    /// conditions and symbol tick size constraints.
    #[serde(with = "string_to_float_optional")]
    pub take_profit: Option<f64>,

    /// The stop-loss price (optional).
    ///
    /// The price at which the position is closed to limit losses. In perpetual
    /// futures, stop-loss (SL) is essential to prevent significant drawdowns,
    /// especially with leverage. If `None`, no SL is set. Bots should use this field
    /// to confirm SL settings and manage risk, setting SL prices based on risk
    /// tolerance and volatility to avoid premature exits or excessive losses.
    #[serde(with = "string_to_float_optional")]
    pub stop_loss: Option<f64>,

    /// The price type for triggering take-profit.
    ///
    /// Specifies the price metric used for TP triggering, such as "LastPrice",
    /// "IndexPrice", or "MarkPrice". In perpetual futures, choosing a reliable metric
    /// like "MarkPrice" (less susceptible to manipulation) ensures consistent
    /// execution. Bots should verify this field to ensure TP triggers as intended,
    /// especially in volatile markets where price discrepancies can occur.
    pub tp_trigger_by: String,

    /// The price type for triggering stop-loss.
    ///
    /// Specifies the price metric used for SL triggering, similar to `tp_trigger_by`.
    /// Bots should select a stable metric (e.g., "MarkPrice") to protect against
    /// manipulation-driven triggers in perpetual futures. This field ensures SL
    /// activates reliably, safeguarding positions from adverse price movements.
    pub sl_trigger_by: String,

    /// The direction of the trigger price (0, 1, or 2).
    ///
    /// Indicates whether the trigger activates when the price rises (1) or falls (2);
    /// 0 indicates no direction (non-conditional orders). In perpetual futures, this
    /// field is critical for conditional orders like stop-loss or take-profit. For
    /// example, a stop-loss for a long position typically has `trigger_direction` set
    /// to 2 (falling price). Bots must validate this to ensure risk management logic
    /// aligns with market expectations.
    pub trigger_direction: i32,

    /// The price type for triggering conditional orders (optional).
    ///
    /// Specifies the price metric for triggering conditional orders (e.g.,
    /// "LastPrice", "MarkPrice"). If `None`, the order is not conditional. In
    /// perpetual futures, bots should choose a reliable metric to ensure consistent
    /// execution, especially for high-frequency strategies where timing is critical.
    #[serde(
        deserialize_with = "empty_string_as_none",
        skip_serializing_if = "is_empty_or_none"
    )]
    pub trigger_by: Option<String>,

    /// The market price when the order was created (optional).
    ///
    /// The reference market price at the time of order placement, typically the last
    /// traded price. In perpetual futures, bots can use this to compare against
    /// execution prices (`avg_price`) and assess slippage or market movement since
    /// order creation. If `None`, no reference price was recorded. This field helps
    /// bots evaluate order timing and market conditions.
    #[serde(with = "string_to_float_optional")]
    pub last_price_on_created: Option<f64>,

    /// Indicates if the order reduces an existing position.
    ///
    /// When `true`, the order only closes an existing position, preventing unintended
    /// increases in exposure. In perpetual futures, `reduce_only` is critical for
    /// position management, ensuring bots exit positions without opening opposing
    /// ones. Bots should set and verify this field when closing positions to avoid
    /// margin issues or unexpected leverage.
    pub reduce_only: bool,

    /// Indicates if the order closes the position when triggered.
    ///
    /// When `true`, the order closes the position upon triggering, typically used for
    /// stop-loss or take-profit orders. In perpetual futures, this ensures automatic
    /// position closure at predefined levels, aiding risk management. Bots should
    /// verify this field for risk-limiting orders to prevent unintended position
    /// retention.
    pub close_on_trigger: bool,

    /// The type of self-match prevention.
    ///
    /// Specifies the self-match prevention (SMP) mechanism to prevent a trader’s own
    /// orders from matching against each other, which could manipulate market
    /// perception. In perpetual futures, this is relevant for large or institutional
    /// bots to comply with exchange rules. Retail bots typically see an empty string
    /// unless SMP is configured. Bots should log this for compliance auditing.
    pub smp_type: String,

    /// The self-match prevention group identifier.
    ///
    /// Groups orders for SMP purposes, assigning them to a specific SMP group. In
    /// perpetual futures, this is relevant for advanced bots managing large order
    /// books. Retail bots can usually ignore this unless participating in SMP
    /// mechanisms. Bots should use this to ensure compliance with Bybit’s trading
    /// rules.
    pub smp_group: i32,

    /// The identifier of the matched SMP order (optional).
    ///
    /// Indicates if an order was affected by SMP, identifying the matched order. In
    /// perpetual futures, this is typically `None` for retail bots but relevant for
    /// institutional traders. Bots should log this for auditing and compliance,
    /// ensuring SMP rules are followed to avoid penalties.
    #[serde(
        deserialize_with = "empty_string_as_none",
        skip_serializing_if = "is_empty_or_none"
    )]
    pub smp_order_id: Option<String>,

    /// The take-profit/stop-loss mode (e.g., "Full", "Partial").
    ///
    /// Specifies whether TP/SL applies to the entire position ("Full") or a portion
    /// ("Partial"). In perpetual futures, "Full" ensures complete position closure at
    /// TP/SL levels, simplifying risk management, while "Partial" suits complex exit
    /// strategies like scaling out. Bots should verify this field to confirm exit
    /// strategy alignment and adjust TP/SL settings accordingly.
    #[serde(skip_serializing_if = "String::is_empty")]
    pub tpsl_mode: String,

    /// The limit price for take-profit orders (optional).
    ///
    /// The exact price for a limit-based take-profit order. In perpetual futures,
    /// this allows precise profit-taking but risks non-execution if the market doesn’t
    /// reach the price. If `None`, the TP is not limit-based. Bots should set this
    /// based on market depth and volatility to balance execution likelihood and
    /// profitability, ensuring compliance with tick size constraints.
    #[serde(with = "string_to_float_optional")]
    pub tp_limit_price: Option<f64>,

    /// The limit price for stop-loss orders (optional).
    ///
    /// The exact price for a limit-based stop-loss order. Similar to `tp_limit_price`,
    /// bots must balance precision with execution risk, ensuring the price is
    /// achievable in volatile perpetual futures markets to protect against losses. If
    /// `None`, the SL is not limit-based. Bots should validate this against market
    /// conditions to ensure effective risk management.
    #[serde(with = "string_to_float_optional")]
    pub sl_limit_price: Option<f64>,

    /// The placement type of the order (optional).
    ///
    /// Indicates how the order was placed, such as via API, web, or mobile app. In
    /// perpetual futures, this is typically `None` for API-based orders but may be
    /// used for auditing or tracking order sources. Bots should log this for
    /// traceability, especially in multi-platform trading environments.
    #[serde(
        deserialize_with = "empty_string_as_none",
        skip_serializing_if = "is_empty_or_none"
    )]
    pub place_type: Option<String>,

    /// The timestamp when the order was created (in milliseconds).
    ///
    /// The time the order was placed, in Unix epoch milliseconds. In perpetual
    /// futures, bots use this to track order age and correlate with market events.
    /// For example, comparing `created_time` with `updated_time` helps assess order
    /// execution latency. Bots should log this for auditing and performance analysis.
    #[serde(with = "string_to_u64")]
    pub created_time: u64,

    /// The timestamp when the order was last updated (in milliseconds).
    ///
    /// The time of the most recent update to the order (e.g., partial fill,
    /// cancellation), in Unix epoch milliseconds. In perpetual futures, bots use this
    /// to monitor order progress and detect changes in status or execution. Comparing
    /// `updated_time` with `created_time` helps evaluate market responsiveness and
    /// strategy timing. Bots should use this for real-time state management.
    #[serde(with = "string_to_u64")]
    pub updated_time: u64,
}

/// Custom deserialization functions and utilities.

/// Deserializes a string to a u64, handling empty strings and invalid formats.
///
/// Used for fields like timestamps (`time_second`, `start_time`) that are returned as strings by the Bybit API but need to be converted to `u64` for Rust. Bots should rely on this to handle edge cases, such as empty strings, which are treated as `0`.
pub mod string_to_u64 {
    use std::default;

    use serde::{self, Deserialize, Deserializer, Serializer};

    // Serialize a u64 as a string.
    pub fn serialize<S>(value: &u64, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let s = value.to_string();
        serializer.serialize_str(&s)
    }

    // Deserialize a string to a u64.
    pub fn deserialize<'de, D>(deserializer: D) -> Result<u64, D::Error>
    where
        D: Deserializer<'de>,
    {
        let s = String::deserialize(deserializer)?;
        s.parse::<u64>().map_err(serde::de::Error::custom)
    }
}

/// Deserializes a string to an f64, handling empty strings and invalid formats.
///
/// Used for fields like prices (`last_price`, `open_price`) and quantities (`size`, `open_interest`) that are returned as strings to preserve precision but need to be converted to `f64` for calculations. Bots should use this to ensure accurate numerical processing and handle edge cases like empty strings.
pub mod string_to_float {
    use serde::{self, Deserialize, Deserializer, Serializer};

    // Serialize a u64 as a string.
    pub fn serialize<S>(value: &f64, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let s = value.to_string();
        serializer.serialize_str(&s)
    }

    // Deserialize a string as an f64.
    pub fn deserialize<'de, D>(deserializer: D) -> Result<f64, D::Error>
    where
        D: Deserializer<'de>,
    {
        let s = String::deserialize(deserializer)?;
        s.parse::<f64>().map_err(serde::de::Error::custom)
    }
}

/// Checks if an optional string is empty or None.
///
/// Used in serialization to skip fields like `min_price` or `max_order_qty` when they are empty or `None`, ensuring cleaner JSON output that complies with Bybit’s API expectations.
pub fn is_empty_or_none(s: &Option<String>) -> bool {
    s.as_ref().map_or(true, |s| s.is_empty())
}

/// Custom deserialization function to treat empty strings as `None`.
///
/// Used for fields that may receive empty strings from the Bybit API but should be treated as absent values in Rust. This ensures proper handling of optional fields like `block_trade_id` or `order_iv` in order responses, preventing empty strings from being misinterpreted as valid data. Bots should use this to maintain data integrity when processing API responses.
fn empty_string_as_none<'de, D, T>(deserializer: D) -> Result<Option<T>, D::Error>
where
    D: Deserializer<'de>,
    T: Deserialize<'de>,
{
    let s: Option<String> = Option::deserialize(deserializer)?;
    match s {
        Some(ref s) if s.trim().is_empty() => Ok(None),
        Some(s) => {
            let kind = T::deserialize(serde_json::Value::String(s))
                .map(Some)
                .map_err(serde::de::Error::custom)?;
            Ok(kind)
        }
        None => Ok(None),
    }
}

/// Test module for deserialization functionality.
#[cfg(test)]
mod tests {
    use super::*;

    /// Tests deserialization of an order response from JSON.
    ///
    /// Ensures that the `Order` struct correctly parses a sample JSON response from the Bybit API, verifying key fields like `order_id`. This is critical for bots to confirm that order data is accurately processed for trade execution and monitoring.
    #[test]
    fn test_deserialize_orders() {
        let json = r#"
        {
                "orderId": "fd4300ae-7847-404e-b947-b46980a4d140",
                "orderLinkId": "test-000005",
                "blockTradeId": "",
                "symbol": "ETHUSDT",
                "price": "1600.00",
                "qty": "0.10",
                "side": "Buy",
                "isLeverage": "",
                "positionIdx": 1,
                "orderStatus": "New",
                "cancelType": "UNKNOWN",
                "rejectReason": "EC_NoError",
                "avgPrice": "0",
                "leavesQty": "0.10",
                "leavesValue": "160",
                "cumExecQty": "0.00",
                "cumExecValue": "0",
                "cumExecFee": "0",
                "timeInForce": "GTC",
                "orderType": "Limit",
                "stopOrderType": "UNKNOWN",
                "orderIv": "",
                "triggerPrice": "0.00",
                "takeProfit": "2500.00",
                "stopLoss": "1500.00",
                "tpTriggerBy": "LastPrice",
                "slTriggerBy": "LastPrice",
                "triggerDirection": 0,
                "triggerBy": "UNKNOWN",
                "lastPriceOnCreated": "",
                "reduceOnly": false,
                "closeOnTrigger": false,
                "smpType": "None",
                "smpGroup": 0,
                "smpOrderId": "",
                "tpslMode": "Full",
                "tpLimitPrice": "",
                "slLimitPrice": "",
                "placeType": "",
                "createdTime": "1684738540559",
                "updatedTime": "1684738540561"
            }
        "#;
        let order: Order = serde_json::from_str(json).unwrap();
        assert_eq!(order.order_id, "fd4300ae-7847-404e-b947-b46980a4d140");
    }
}

/// Parameters for canceling all open orders.
///
/// Used to construct a request to the `/v5/order/cancel-all` endpoint to cancel all open orders for a specific trading pair or category. This is useful for bots implementing risk management strategies, such as closing all positions during high volatility or system errors in perpetual futures trading.
#[derive(Clone, Default)]
pub struct CancelallRequest<'a> {
    /// The product category (e.g., Linear, Inverse).
    ///
    /// Specifies the instrument type, such as `Linear` for USDT-margined perpetual futures. Bots must set this correctly to target the desired contract type.
    pub category: Category,

    /// The trading pair symbol (e.g., "BTCUSDT").
    ///
    /// Identifies the specific perpetual futures contract. If specified, only orders for this symbol are canceled. Bots can leave this empty to cancel orders across all symbols in the category.
    pub symbol: &'a str,

    /// The base coin of the instrument (e.g., "BTC").
    ///
    /// Optionally filters orders by the base asset (e.g., all BTC-based perpetuals). Useful for bots managing multiple pairs of the same asset.
    pub base_coin: Option<&'a str>,

    /// The settlement coin (e.g., "USDT").
    ///
    /// Optionally filters orders by the settlement currency. For `Linear` perpetuals, this is typically "USDT". Bots can use this to narrow down cancellations to specific margin types.
    pub settle_coin: Option<&'a str>,

    /// The order filter (e.g., "Order", "StopOrder").
    ///
    /// Specifies the type of orders to cancel, such as regular orders or stop orders. Bots can use this to selectively cancel specific order types, preserving others like take-profit/stop-loss orders.
    pub order_filter: Option<&'a str>,

    /// The stop order type (e.g., "StopLoss", "TakeProfit").
    ///
    /// Optionally filters by specific stop order types. Useful for bots managing complex strategies with multiple conditional orders in perpetual futures.
    pub stop_order_type: Option<&'a str>,
}

impl<'a> CancelallRequest<'a> {
    /// Creates a default Cancelall request.
    ///
    /// Returns a request with `category` set to `Linear` and `symbol` set to `"BTCUSDT"`. Suitable for testing or quick cancellations but should be customized for production to match specific trading needs.
    pub fn default() -> Self {
        Self {
            category: Category::Linear,
            symbol: "BTCUSDT",
            base_coin: None,
            settle_coin: None,
            order_filter: None,
            stop_order_type: None,
        }
    }

    /// Constructs a new Cancelall request with specified parameters.
    ///
    /// Allows full customization of the cancellation request. Bots should use this to specify the exact symbol, category, and filters to align with their risk management or trading strategy.
    pub fn new(
        category: Category,
        symbol: &'a str,
        base_coin: Option<&'a str>,
        settle_coin: Option<&'a str>,
        order_filter: Option<&'a str>,
        stop_order_type: Option<&'a str>,
    ) -> Self {
        Self {
            category,
            symbol,
            base_coin,
            settle_coin,
            order_filter,
            stop_order_type,
        }
    }
}

/// Response structure for the cancel-all orders request.
///
/// Returned by the `/v5/order/cancel-all` endpoint, this struct provides the result of canceling all open orders. Bots use this to confirm successful cancellations and handle errors, ensuring proper risk management in perpetual futures trading.
#[derive(Serialize, Deserialize, Clone, Debug)]
#[serde(rename_all = "camelCase")]
pub struct CancelallResponse {
    /// The return code indicating the success or failure of the request.
    ///
    /// A value of `0` indicates success, while non-zero values indicate errors (e.g., `10001` for invalid parameters). Bots should check this field and implement error handling, such as retrying or logging issues.
    pub ret_code: i32,

    /// A human-readable message describing the result or error.
    ///
    /// Typically `"OK"` for success or an error description (e.g., `"invalid symbol"`). Bots should log this for debugging and user feedback, especially when `ret_code` is non-zero.
    pub ret_msg: String,

    /// The list of canceled orders.
    ///
    /// Contains the status of each canceled order, including order IDs and symbols. Bots use this to verify which orders were canceled and update their internal state accordingly.
    pub result: CancelledList,

    /// Additional information, typically an empty object.
    ///
    /// Usually an `Empty` struct (`{}`) and can be ignored unless verifying response structure for error handling.
    pub ret_ext_info: Empty,

    /// The timestamp of the response in milliseconds.
    ///
    /// Indicates when the response was generated by Bybit’s server. Bots can use this to ensure data freshness and measure latency, critical for high-frequency trading strategies.
    pub time: u64,
}

/// Summarizes the list of canceled orders.
///
/// Part of the `CancelallResponse`, this struct contains the details of all orders canceled in the request. Bots use this to confirm cancellation success and update their order tracking systems.
#[derive(Serialize, Deserialize, Clone, Debug)]
#[serde(rename_all = "camelCase")]
pub struct CancelledList {
    /// A list of canceled order statuses.
    ///
    /// Contains details like order IDs and symbols for each canceled order. Bots should iterate through this to update their internal order book and ensure no orphaned orders remain.
    pub list: Vec<OrderStatus>,
}

/// Response structure for trade history requests.
///
/// Returned by the `/v5/execution/list` endpoint, this struct provides historical trade execution data for a trading pair. Bots use this to analyze past trades, calculate realized P&L, and refine trading strategies for perpetual futures.
#[derive(Serialize, Deserialize, Clone, Debug)]
#[serde(rename_all = "camelCase")]
pub struct TradeHistoryResponse {
    /// The return code indicating the success or failure of the request.
    ///
    /// A `0` indicates success. Non-zero codes require error handling for issues like invalid symbols. Bots should implement retry logic or parameter adjustments for errors.
    pub ret_code: i32,

    /// A human-readable message describing the result or error.
    ///
    /// Provides context for the `ret_code`, such as `"OK"` or an error description. Bots should log this for debugging and user feedback.
    pub ret_msg: String,

    /// The trade history data summary.
    ///
    /// Contains the actual trade execution records, including price, quantity, and fees. Bots use this for performance analysis and strategy optimization.
    pub result: TradeHistorySummary,

    /// Additional information, typically an empty object.
    ///
    /// Usually an `Empty` struct and can be ignored unless verifying response structure.
    pub ret_ext_info: Empty,

    /// The timestamp of the response in milliseconds.
    ///
    /// Indicates when the response was generated. Bots can use this to ensure data freshness, especially for strategies relying on recent trade data.
    pub time: u64,
}

/// Summarizes trade history data for a trading pair.
///
/// Part of the `TradeHistoryResponse`, this struct organizes trade history by category, pagination cursor, and a list of trade records. Bots use this to process executed trades and calculate metrics like average execution price or total fees.
#[derive(Serialize, Deserialize, Clone, Debug)]
#[serde(rename_all = "camelCase")]
pub struct TradeHistorySummary {
    /// The cursor for pagination.
    ///
    /// Indicates the next page of results for large datasets. Bots should use this for paginated requests to fetch additional trade history when `limit` is reached.
    #[serde(skip_serializing_if = "String::is_empty")]
    pub next_page_cursor: String,

    /// The product category (e.g., "linear").
    ///
    /// Indicates the instrument type (e.g., `linear` for USDT-margined perpetuals). Bots should verify this matches the requested `category` to ensure data relevance.
    pub category: String,

    /// A list of trade history records.
    ///
    /// Contains detailed execution data for each trade, such as price, quantity, and fees. Bots use this to analyze trade performance and refine strategies.
    pub list: Vec<TradeHistory>,
}

/// Represents a single trade history record.
///
/// Each record details an executed trade, including execution price, quantity, fees, and timestamps. Bots use this to track trade outcomes, calculate realized profits, and assess strategy effectiveness in perpetual futures.
#[derive(Serialize, Deserialize, Clone, Debug)]
#[serde(rename_all = "camelCase")]
pub struct TradeHistory {
    /// The trading pair symbol (e.g., "BTCUSDT").
    ///
    /// Identifies the perpetual futures contract for the trade. Bots should verify this matches the requested symbol to ensure data accuracy.
    pub symbol: String,

    /// The order type (e.g., "Limit", "Market").
    ///
    /// Indicates whether the trade was executed via a limit or market order. Bots use this to analyze execution strategy effectiveness.
    pub order_type: String,

    /// The underlying price (optional).
    ///
    /// For derivatives, this may represent the price of the underlying asset. Often empty for perpetual futures. Bots can ignore this unless analyzing specific derivative products.
    #[serde(default, skip_serializing_if = "String::is_empty")]
    pub underlying_price: String,

    /// The user-defined order link ID (optional).
    ///
    /// A custom identifier for the order. Bots can use this to correlate trades with specific strategies or client orders.
    #[serde(default, skip_serializing_if = "String::is_empty")]
    pub order_link_id: String,

    /// The trade side ("Buy" or "Sell").
    ///
    /// Indicates whether the trade was a buy or sell. Bots use this to track position direction and calculate net exposure.
    pub side: String,

    /// The index price at execution (optional).
    ///
    /// The index price of the asset at the time of execution, used for mark-to-market calculations in perpetual futures. Often empty in some responses. Bots can use this for P&L calculations if available.
    #[serde(default, skip_serializing_if = "String::is_empty")]
    pub index_price: String,

    /// The unique order ID.
    ///
    /// Identifies the order associated with the trade. Bots use this to link trades to specific orders in their tracking systems.
    pub order_id: String,

    /// The stop order type (e.g., "StopLoss", "TakeProfit").
    ///
    /// Indicates if the trade was triggered by a stop order. Bots use this to analyze conditional order executions.
    pub stop_order_type: String,

    /// The remaining quantity after execution.
    ///
    /// The unfilled portion of the order after the trade. Bots use this to track partial fills and manage order status.
    pub leaves_qty: String,

    /// The timestamp of the trade execution.
    ///
    /// Indicates when the trade occurred. Bots use this to align trade data with other time-series data for analysis.
    pub exec_time: String,

    /// The currency of the fees (optional).
    ///
    /// Specifies the currency in which fees were charged (e.g., "USDT"). Bots use this to calculate net profitability.
    #[serde(default, skip_serializing_if = "String::is_empty")]
    pub fee_currency: String,

    /// Indicates if the trade was executed as a maker.
    ///
    /// `true` if the trade was a maker order (added liquidity), `false` if taker (removed liquidity). Bots use this to optimize fee structures, as maker fees are typically lower.
    pub is_maker: bool,

    /// The execution fee for the trade.
    ///
    /// The fee charged for the trade, in the settlement currency. Bots use this to calculate net P&L and assess trading costs in perpetual futures.
    #[serde(with = "string_to_float")]
    pub exec_fee: f64,

    /// The fee rate applied to the trade.
    ///
    /// The percentage fee rate (e.g., "0.00055" for 0.055%). Bots use this to verify fee calculations and optimize for lower-cost execution strategies.
    pub fee_rate: String,

    /// The unique execution ID.
    ///
    /// A unique identifier for the trade execution on Bybit’s exchange. Bots use this to track specific trades and avoid duplicates.
    pub exec_id: String,

    /// The implied volatility for the trade (optional).
    ///
    /// Relevant for options trading, typically empty for perpetual futures. Bots can ignore this unless trading options.
    #[serde(default, skip_serializing_if = "String::is_empty")]
    pub trade_iv: String,

    /// The block trade ID (optional).
    ///
    /// Identifies if the trade was a block trade, executed off the public order book. Bots can use this to detect large institutional trades.
    #[serde(default, skip_serializing_if = "String::is_empty")]
    pub block_trade_id: String,

    /// The mark price at execution.
    ///
    /// The mark price used for P&L calculations in perpetual futures. Bots use this to calculate unrealized P&L and assess position health.
    #[serde(with = "string_to_float")]
    pub mark_price: f64,

    /// The execution price of the trade.
    ///
    /// The price at which the trade was executed. Bots use this to calculate realized P&L and analyze execution quality.
    #[serde(with = "string_to_float")]
    pub exec_price: f64,

    /// The mark implied volatility (optional).
    ///
    /// Relevant for options, typically empty for perpetual futures. Bots can ignore this field.
    #[serde(default, skip_serializing_if = "String::is_empty")]
    pub mark_iv: String,

    /// The total order quantity.
    ///
    /// The total quantity of the order associated with the trade. Bots use this to track order size and fill progress.
    #[serde(with = "string_to_float")]
    pub order_qty: f64,

    /// The order price.
    ///
    /// The price specified in the order (for limit orders). Bots use this to compare with `exec_price` to assess slippage.
    #[serde(with = "string_to_float")]
    pub order_price: f64,

    /// The execution value of the trade.
    ///
    /// The monetary value of the trade (`exec_price` * `exec_qty`). Bots use this to calculate trade size in the settlement currency.
    #[serde(with = "string_to_float")]
    pub exec_value: f64,

    /// The execution type (e.g., "Trade", "Funding").
    ///
    /// Indicates the nature of the execution (e.g., regular trade or funding fee). Bots use this to filter trades for P&L calculations.
    pub exec_type: String,

    /// The executed quantity of the trade.
    ///
    /// The amount of the base asset traded. Bots use this to track fill amounts and update position sizes.
    #[serde(with = "string_to_float")]
    pub exec_qty: f64,

    /// The closed position size (optional).
    ///
    /// The portion of the position closed by this trade, if applicable. Bots use this to track position reductions.
    #[serde(
        rename = "closedSize",
        default,
        skip_serializing_if = "String::is_empty"
    )]
    pub closed_size: String,

    /// The sequence number of the trade.
    ///
    /// A unique sequence ID for ordering trades. Bots can use this to ensure proper chronological processing of trade data.
    pub seq: u64,
}

/// Parameters for requesting trade history data.
///
/// Used to construct a request to the `/v5/execution/list` endpoint to retrieve historical trade executions. Bots use this to analyze past trades, calculate performance metrics, and refine trading strategies for perpetual futures.
#[derive(Clone, Default)]
pub struct TradeHistoryRequest<'a> {
    /// The product category (e.g., Linear, Inverse).
    ///
    /// Specifies the instrument type. Bots must set this to fetch trade history for the correct contract type (e.g., `Linear` for USDT-margined perpetuals).
    pub category: Category,

    /// The trading pair symbol (e.g., "BTCUSDT").
    ///
    /// Optionally filters trades by symbol. If unset, trades for all symbols in the category are returned. Bots should specify this for targeted analysis.
    pub symbol: Option<Cow<'a, str>>,

    /// The order ID.
    ///
    /// Optionally filters trades by a specific order ID. Useful for bots tracking executions for a particular order.
    pub order_id: Option<Cow<'a, str>>,

    /// The user-defined order link ID.
    ///
    /// Optionally filters trades by a custom order identifier. Bots can use this to correlate trades with specific strategies.
    pub order_link_id: Option<Cow<'a, str>>,

    /// The base coin (e.g., "BTC").
    ///
    /// Optionally filters trades by the base asset. Useful for bots analyzing trades across multiple pairs of the same asset.
    pub base_coin: Option<Cow<'a, str>>,

    /// The start time for the trade history (Unix timestamp in milliseconds).
    ///
    /// Defines the beginning of the time range. Bots should set this for historical trade analysis, such as performance over a specific period.
    pub start_time: Option<u64>,

    /// The end time for the trade history (Unix timestamp in milliseconds).
    ///
    /// Defines the end of the time range. Bots should set this to limit data to a specific period, optimizing performance.
    pub end_time: Option<u64>,

    /// The execution type (e.g., "Trade", "Funding").
    ///
    /// Optionally filters trades by execution type. Bots can use this to focus on specific trade events, such as excluding funding fee executions.
    pub exec_type: Option<Cow<'a, str>>,

    /// The maximum number of records to return (1-50, default: 50).
    ///
    /// Controls the number of trade records returned. Bots should set a reasonable limit to balance data completeness with performance.
    pub limit: Option<u64>,
}

impl<'a> TradeHistoryRequest<'a> {
    /// Creates a default TradeHistory request.
    ///
    /// Returns a request with `category` set to `Linear` and all other fields unset. Suitable for broad queries but should be customized for specific analysis needs.
    pub fn default() -> TradeHistoryRequest<'a> {
        TradeHistoryRequest::new(
            Category::Linear,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
        )
    }

    /// Constructs a new TradeHistory request with specified parameters.
    ///
    /// Allows full customization. Bots should use this to specify the exact symbol, time range, and filters to align with their analysis requirements.
    pub fn new(
        category: Category,
        symbol: Option<&'a str>,
        order_id: Option<&'a str>,
        order_link_id: Option<&'a str>,
        base_coin: Option<&'a str>,
        start_time: Option<u64>,
        end_time: Option<u64>,
        exec_type: Option<&'a str>,
        limit: Option<u64>,
    ) -> TradeHistoryRequest<'a> {
        TradeHistoryRequest {
            category,
            symbol: symbol.map(Cow::Borrowed),
            order_id: order_id.map(Cow::Borrowed),
            order_link_id: order_link_id.map(Cow::Borrowed),
            base_coin: base_coin.map(Cow::Borrowed),
            start_time,
            end_time,
            exec_type: exec_type.map(Cow::Borrowed),
            limit,
        }
    }
}

/// Parameters for batch placing multiple orders.
///
/// Used to construct a request to the `/v5/order/create-batch` endpoint to place multiple orders simultaneously. This is useful for bots executing complex strategies, such as placing multiple limit orders at different price levels in perpetual futures.
#[derive(Clone, Default)]
pub struct BatchPlaceRequest<'a> {
    /// The product category (e.g., Linear, Inverse).
    ///
    /// Specifies the instrument type. Bots must set this to target the correct contract type for the batch orders.
    pub category: Category,

    /// A list of order requests to place.
    ///
    /// Contains the individual order details, such as symbol, price, and quantity. Bots should populate this with valid `OrderRequest` structs to execute multiple orders efficiently.
    pub requests: Vec<OrderRequest<'a>>,
}

impl<'a> BatchPlaceRequest<'a> {
    /// Constructs a new BatchPlace request with specified parameters.
    ///
    /// Allows customization of the batch order request. Bots should use this to define the category and list of orders to place.
    pub fn new(category: Category, requests: Vec<OrderRequest<'a>>) -> BatchPlaceRequest<'a> {
        BatchPlaceRequest { category, requests }
    }
}

/// Response structure for batch order placement.
///
/// Returned by the `/v5/order/create-batch` endpoint, this struct provides the result of placing multiple orders. Bots use this to confirm successful order placements and handle any errors for individual orders.
#[derive(Serialize, Deserialize, Clone, Debug)]
#[serde(rename_all = "camelCase")]
pub struct BatchPlaceResponse {
    /// The return code indicating the overall success or failure of the request.
    ///
    /// A `0` indicates success for the batch request, but individual orders may still have errors. Bots should check `ret_ext_info` for per-order results.
    pub ret_code: i32,

    /// A human-readable message describing the overall result or error.
    ///
    /// Typically `"OK"` for success or an error description. Bots should log this for debugging.
    pub ret_msg: String,

    /// The list of placed orders.
    ///
    /// Contains details of successfully placed orders, including order IDs and symbols. Bots use this to update their order tracking systems.
    pub result: BatchedOrderList,

    /// Additional information about individual order confirmations.
    ///
    /// Contains per-order success or failure details, including error codes and messages. Bots should inspect this to handle failed orders and retry or adjust as needed.
    pub ret_ext_info: OrderConfirmationList,

    /// The timestamp of the response in milliseconds.
    ///
    /// Indicates when the response was generated. Bots can use this to ensure data freshness and measure latency.
    pub time: u64,
}

/// Summarizes the list of batched orders.
///
/// Part of the `BatchPlaceResponse`, this struct contains the details of all orders placed in the batch request. Bots use this to confirm order creation and update their state.
#[derive(Serialize, Deserialize, Clone, Debug)]
#[serde(rename_all = "camelCase")]
pub struct BatchedOrderList {
    /// A list of placed orders.
    ///
    /// Contains details like order IDs and symbols for each successfully placed order. Bots should iterate through this to update their internal order book.
    pub list: Vec<BatchedOrder>,
}

/// Represents a single batched order result.
///
/// Details the outcome of an individual order in a batch placement request. Bots use this to track specific order creations and correlate with their trading strategy.
#[derive(Serialize, Deserialize, Clone, Debug)]
#[serde(rename_all = "camelCase")]
pub struct BatchedOrder {
    /// The product category (e.g., "linear").
    ///
    /// Indicates the instrument type of the order. Bots should verify this matches the requested category.
    pub category: String,

    /// The trading pair symbol (e.g., "BTCUSDT").
    ///
    /// Identifies the perpetual futures contract for the order. Bots should confirm this matches the requested symbol.
    pub symbol: String,

    /// The unique order ID.
    ///
    /// Identifies the placed order on Bybit’s exchange. Bots use this to track the order’s status and executions.
    pub order_id: String,

    /// The user-defined order link ID.
    ///
    /// A custom identifier for the order. Bots can use this to correlate the order with specific strategies or client requests.
    pub order_link_id: String,

    /// The timestamp of order creation.
    ///
    /// Indicates when the order was created. Bots use this to align order data with other time-series data.
    pub create_at: String,
}

/// Summarizes the confirmation status of batched orders.
///
/// Part of the `BatchPlaceResponse`, this struct contains confirmation details for each order in the batch, including success or failure statuses. Bots use this to handle errors for individual orders.
#[derive(Serialize, Deserialize, Clone, Debug)]
#[serde(rename_all = "camelCase")]
pub struct OrderConfirmationList {
    /// A list of order confirmations.
    ///
    /// Contains the status (success or failure) for each order in the batch. Bots should inspect this to identify and handle failed orders.
    pub list: Vec<OrderConfirmation>,
}

/// Represents the confirmation status of a single order in a batch.
///
/// Details the success or failure of an individual order in a batch request. Bots use this to diagnose issues with specific orders and implement retry logic if needed.
#[derive(Serialize, Deserialize, Clone, Debug)]
#[serde(rename_all = "camelCase")]
pub struct OrderConfirmation {
    /// The confirmation code for the order.
    ///
    /// A `0` indicates success, while non-zero values indicate errors (e.g., `10001` for invalid parameters). Bots should check this to identify failed orders.
    pub code: i16,

    /// A human-readable message describing the confirmation result.
    ///
    /// Provides details about the order’s status, such as `"OK"` or an error description. Bots should log this for debugging and error handling.
    pub msg: String,
}

/// Parameters for batch amending multiple orders.
///
/// Used to construct a request to the `/v5/order/amend-batch` endpoint to modify multiple existing orders simultaneously. This is useful for bots adjusting order parameters (e.g., price or quantity) in response to market conditions in perpetual futures.
#[derive(Clone, Default)]
pub struct BatchAmendRequest<'a> {
    /// The product category (e.g., Linear, Inverse).
    ///
    /// Specifies the instrument type. Bots must set this to target the correct contract type for the batch amendments.
    pub category: Category,

    /// A list of order amendment requests.
    ///
    /// Contains the individual amendment details, such as order ID, new price, or quantity. Bots should populate this with valid `AmendOrderRequest` structs to modify multiple orders efficiently.
    pub requests: Vec<AmendOrderRequest<'a>>,
}

impl<'a> BatchAmendRequest<'a> {
    /// Constructs a new BatchAmend request with specified parameters.
    ///
    /// Allows customization of the batch amendment request. Bots should use this to define the category and list of amendments to apply.
    pub fn new(category: Category, requests: Vec<AmendOrderRequest<'a>>) -> BatchAmendRequest<'a> {
        BatchAmendRequest { category, requests }
    }
}

/// Response structure for batch order amendment.
///
/// Returned by the `/v5/order/amend-batch` endpoint, this struct provides the result of amending multiple orders. Bots use this to confirm successful amendments and handle any errors for individual orders.
#[derive(Serialize, Deserialize, Clone, Debug)]
#[serde(rename_all = "camelCase")]
pub struct BatchAmendResponse {
    /// The return code indicating the overall success or failure of the request.
    ///
    /// A `0` indicates success for the batch request, but individual amendments may have errors. Bots should check `ret_ext_info` for per-order results.
    pub ret_code: i32,

    /// A human-readable message describing the overall result or error.
    ///
    /// Typically `"OK"` for success or an error description. Bots should log this for debugging.
    pub ret_msg: String,

    /// The list of amended orders.
    ///
    /// Contains details of successfully amended orders, including order IDs and symbols. Bots use this to update their order tracking systems.
    pub result: AmendedOrderList,

    /// Additional information about individual order confirmations.
    ///
    /// Contains per-order success or failure details, including error codes and messages. Bots should inspect this to handle failed amendments and retry or adjust as needed.
    pub ret_ext_info: OrderConfirmationList,

    /// The timestamp of the response in milliseconds.
    ///
    /// Indicates when the response was generated. Bots can use this to ensure data freshness and measure latency.
    pub time: u64,
}

/// Summarizes the list of amended orders.
///
/// Part of the `BatchAmendResponse`, this struct contains the details of all orders amended in the batch request. Bots use this to confirm amendment success and update their state.
#[derive(Serialize, Deserialize, Clone, Debug)]
#[serde(rename_all = "camelCase")]
pub struct AmendedOrderList {
    /// A list of amended orders.
    ///
    /// Contains details like order IDs and symbols for each successfully amended order. Bots should iterate through this to update their internal order book.
    pub list: Vec<AmendedOrder>,
}

/// Represents a single amended order result.
///
/// Details the outcome of an individual order amendment in a batch request. Bots use this to track specific order modifications and correlate with their trading strategy.
#[derive(Serialize, Deserialize, Clone, Debug)]
#[serde(rename_all = "camelCase")]
pub struct AmendedOrder {
    /// The product category (e.g., "linear").
    ///
    /// Indicates the instrument type of the order. Bots should verify this matches the requested category.
    pub category: String,

    /// The trading pair symbol (e.g., "BTCUSDT").
    ///
    /// Identifies the perpetual futures contract for the order. Bots should confirm this matches the requested symbol.
    pub symbol: String,

    /// The unique order ID.
    ///
    /// Identifies the amended order on Bybit’s exchange. Bots use this to track the order’s status and executions.
    pub order_id: String,

    /// The user-defined order link ID.
    ///
    /// A custom identifier for the order. Bots can use this to correlate the order with specific strategies or client requests.
    pub order_link_id: String,
}

/// Parameters for batch canceling multiple orders.
///
/// Used to construct a request to the `/v5/order/cancel-batch` endpoint to cancel multiple existing orders simultaneously. This is useful for bots implementing risk management or adjusting strategies in perpetual futures.
#[derive(Clone, Default)]
pub struct BatchCancelRequest<'a> {
    /// The product category (e.g., Linear, Inverse).
    ///
    /// Specifies the instrument type. Bots must set this to target the correct contract type for the batch cancellations.
    pub category: Category,

    /// A list of order cancellation requests.
    ///
    /// Contains the individual cancellation details, such as order ID or order link ID. Bots should populate this with valid `CancelOrderRequest` structs to cancel multiple orders efficiently.
    pub requests: Vec<CancelOrderRequest<'a>>,
}

impl<'a> BatchCancelRequest<'a> {
    /// Constructs a new BatchCancel request with specified parameters.
    ///
    /// Allows customization of the batch cancellation request. Bots should use this to define the category and list of cancellations to apply.
    pub fn new(
        category: Category,
        requests: Vec<CancelOrderRequest<'a>>,
    ) -> BatchCancelRequest<'a> {
        BatchCancelRequest { category, requests }
    }
}

/// Response structure for batch order cancellation.
///
/// Returned by the `/v5/order/cancel-batch` endpoint, this struct provides the result of canceling multiple orders. Bots use this to confirm successful cancellations and handle any errors for individual orders.
#[derive(Serialize, Deserialize, Clone, Debug)]
#[serde(rename_all = "camelCase")]
pub struct BatchCancelResponse {
    /// The return code indicating the overall success or failure of the request.
    ///
    /// A `0` indicates success for the batch request, but individual cancellations may have errors. Bots should check `ret_ext_info` for per-order results.
    pub ret_code: i32,

    /// A human-readable message describing the overall result or error.
    ///
    /// Typically `"OK"` for success or an error description. Bots should log this for debugging.
    pub ret_msg: String,

    /// The list of canceled orders.
    ///
    /// Contains details of successfully canceled orders, including order IDs and symbols. Bots use this to update their order tracking systems.
    pub result: CanceledOrderList,

    /// Additional information about individual order confirmations.
    ///
    /// Contains per-order success or failure details, including error codes and messages. Bots should inspect this to handle failed cancellations and retry or adjust as needed.
    pub ret_ext_info: OrderConfirmationList,

    /// The timestamp of the response in milliseconds.
    ///
    /// Indicates when the response was generated. Bots can use this to ensure data freshness and measure latency.
    pub time: u64,
}

/// Summarizes the list of canceled orders in a batch.
///
/// Part of the `BatchCancelResponse`, this struct contains the details of all orders canceled in the batch request. Bots use this to confirm cancellation success and update their state.
#[derive(Serialize, Deserialize, Clone, Debug)]
#[serde(rename_all = "camelCase")]
pub struct CanceledOrderList {
    /// A list of canceled orders.
    ///
    /// Contains details like order IDs and symbols for each successfully canceled order. Bots should iterate through this to update their internal order book.
    pub list: Vec<CanceledOrder>,
}

/// Represents a single canceled order result.
///
/// Details the outcome of an individual order cancellation in a batch request. Bots use this to track specific order cancellations and correlate with their trading strategy.
#[derive(Serialize, Deserialize, Clone, Debug)]
#[serde(rename_all = "camelCase")]
pub struct CanceledOrder {
    /// The product category (e.g., "linear").
    ///
    /// Indicates the instrument type of the order. Bots should verify this matches the requested category.
    pub category: String,

    /// The trading pair symbol (e.g., "BTCUSDT").
    ///
    /// Identifies the perpetual futures contract for the order. Bots should confirm this matches the requested symbol.
    pub symbol: String,

    /// The unique order ID.
    ///
    /// Identifies the canceled order on Bybit’s exchange. Bots use this to confirm the order is no longer active.
    pub order_id: String,

    /// The user-defined order link ID.
    ///
    /// A custom identifier for the order. Bots can use this to correlate the order with specific strategies or client requests.
    pub order_link_id: String,
}

/// Enum representing different types of batch order requests.
///
/// Allows bots to specify whether a batch request is for creating, amending, or canceling orders. This provides flexibility for handling multiple order operations in a unified way.
#[derive(Clone)]
pub enum RequestType<'a> {
    /// A batch order creation request.
    ///
    /// Used to place multiple new orders. Bots use this for strategies requiring simultaneous order placements, such as grid trading.
    Create(BatchPlaceRequest<'a>),

    /// A batch order amendment request.
    ///
    /// Used to modify multiple existing orders. Bots use this to adjust order parameters in response to market changes.
    Amend(BatchAmendRequest<'a>),

    /// A batch order cancellation request.
    ///
    /// Used to cancel multiple existing orders. Bots use this for risk management or strategy adjustments.
    Cancel(BatchCancelRequest<'a>),
}

// ----------------------------------------------------------
// POSITION STRUCTS SECTION
// ----------------------------------------------------------

/// Parameters for requesting position information.
///
/// Used to construct a request to the `/v5/position/list` endpoint to retrieve current position details. Bots use this to monitor open positions, calculate unrealized P&L, and manage risk in perpetual futures.
#[derive(Clone, Default)]
pub struct PositionRequest<'a> {
    /// The product category (e.g., Linear, Inverse).
    ///
    /// Specifies the instrument type. Bots must set this to fetch positions for the correct contract type.
    pub category: Category,

    /// The trading pair symbol (e.g., "BTCUSDT").
    ///
    /// Optionally filters positions by symbol. If unset, all positions in the category are returned. Bots should specify this for targeted position monitoring.
    pub symbol: Option<Cow<'a, str>>,

    /// The base coin (e.g., "BTC").
    ///
    /// Optionally filters positions by the base asset. Useful for bots managing multiple pairs of the same asset.
    pub base_coin: Option<Cow<'a, str>>,

    /// The settlement coin (e.g., "USDT").
    ///
    /// Optionally filters positions by the settlement currency. For `Linear` perpetuals, this is typically "USDT". Bots can use this to focus on specific margin types.
    pub settle_coin: Option<Cow<'a, str>>,

    /// The maximum number of position records to return.
    ///
    /// Controls the number of position records returned. Bots should set a reasonable limit to balance data completeness with performance.
    pub limit: Option<usize>,
}

impl<'a> PositionRequest<'a> {
    /// Creates a default Position request.
    ///
    /// Returns a request with `category` set to `Linear` and all other fields unset. Suitable for broad queries but should be customized for specific position monitoring needs.
    pub fn default() -> Self {
        Self::new(Category::Linear, None, None, None, None)
    }

    /// Constructs a new Position request with specified parameters.
    ///
    /// Allows full customization. Bots should use this to specify the exact symbol, category, and filters to align with their position management requirements.
    pub fn new(
        category: Category,
        symbol: Option<&'a str>,
        base_coin: Option<&'a str>,
        settle_coin: Option<&'a str>,
        limit: Option<usize>,
    ) -> Self {
        Self {
            category,
            symbol: symbol.map(Cow::Borrowed),
            base_coin: base_coin.map(Cow::Borrowed),
            settle_coin: settle_coin.map(Cow::Borrowed),
            limit,
        }
    }
}

/// Response structure for position information requests.
///
/// Returned by the `/v5/position/list` endpoint, this struct provides details of current open positions. Bots use this to monitor position size, unrealized P&L, and risk metrics in perpetual futures.
#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct InfoResponse {
    /// The return code indicating the success or failure of the request.
    ///
    /// A `0` indicates success. Non-zero codes require error handling for issues like invalid symbols. Bots should implement retry logic or parameter adjustments for errors.
    pub ret_code: i32,

    /// A human-readable message describing the result or error.
    ///
    /// Provides context for the `ret_code`, such as `"OK"` or an error description. Bots should log this for debugging and user feedback.
    pub ret_msg: String,

    /// The position data summary.
    ///
    /// Contains the actual position details, including size, entry price, and P&L. Bots use this for risk management and position monitoring.
    pub result: InfoResult,

    /// Additional information, typically an empty object.
    ///
    /// Usually an `Empty` struct and can be ignored unless verifying response structure.
    pub ret_ext_info: Empty,

    /// The timestamp of the response in milliseconds.
    ///
    /// Indicates when the response was generated. Bots can use this to ensure data freshness, critical for real-time position management.
    pub time: u64,
}

/// Summarizes position information data.
///
/// Part of the `InfoResponse`, this struct organizes position data by category, pagination cursor, and a list of position records. Bots use this to process and monitor open positions.
#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct InfoResult {
    /// A list of position records.
    ///
    /// Contains detailed position data, such as size, entry price, and P&L. Bots use this to calculate risk metrics and update position tracking systems.
    pub list: Vec<PositionInfo>,

    /// The cursor for pagination (optional).
    ///
    /// Indicates the next page of results for large datasets. Bots should use this for paginated requests to fetch additional position data when `limit` is reached.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_page_cursor: Option<String>,

    /// The product category (e.g., "linear").
    ///
    /// Indicates the instrument type. Bots should verify this matches the requested `category` to ensure data relevance.
    pub category: String,
}

/// Custom deserialization module for handling strings as optional `f64`.
///
/// Used for fields like `avg_price` or `leverage` that may be empty or absent in API responses. Empty strings are treated as `None`, ensuring proper handling of optional numerical fields.
mod string_to_float_optional {
    use serde::{Deserialize, Deserializer, Serializer};
    use std::str::FromStr;

    /// Serializes an `Option<f64>` as a string.
    ///
    /// Converts the `Option<f64>` to a string, using an empty string for `None`. This aligns with Bybit’s API expectations for optional fields.
    pub fn serialize<S>(value: &Option<f64>, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        match value {
            Some(v) => serializer.serialize_str(&v.to_string()),
            None => serializer.serialize_str(""),
        }
    }

    /// Deserializes a string to an `Option<f64>`, returning `None` for empty strings.
    ///
    /// Parses the string to an `Option<f64>`, treating empty strings as `None`. Bots use this to handle optional numerical fields robustly.
    pub fn deserialize<'de, D>(deserializer: D) -> Result<Option<f64>, D::Error>
    where
        D: Deserializer<'de>,
    {
        let s = String::deserialize(deserializer)?;
        if s.is_empty() {
            Ok(None)
        } else {
            f64::from_str(&s)
                .map(Some)
                .map_err(serde::de::Error::custom)
        }
    }
}

/// Represents detailed information about a single position.
///
/// Returned as part of the `InfoResponse`, this struct provides comprehensive position data, including size, entry price, leverage, and P&L. Bots use this to monitor and manage open positions in perpetual futures.
#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct PositionInfo {
    /// The position index (e.g., 0 for one-way mode, 1 or 2 for hedge mode).
    ///
    /// Indicates the position type in Bybit’s position management system. Bots use this to distinguish between long and short positions in hedge mode for perpetual futures.
    pub position_idx: i32,

    /// The risk ID associated with the position.
    ///
    /// Identifies the risk limit tier applied to the position. Bots use this to verify compliance with risk management settings.
    pub risk_id: i32,

    /// The risk limit value for the position.
    ///
    /// The maximum exposure allowed for the position, in the settlement currency. Bots use this to ensure positions stay within risk limits.
    #[serde(with = "string_to_float")]
    pub risk_limit_value: f64,

    /// The trading pair symbol (e.g., "BTCUSDT").
    ///
    /// Identifies the perpetual futures contract for the position. Bots should verify this matches the expected symbol.
    pub symbol: String,

    /// The position side (Buy, Sell, or None).
    ///
    /// Indicates whether the position is long (Buy), short (Sell), or closed (None). Bots use this to track position direction and calculate net exposure.
    #[serde(deserialize_with = "empty_string_as_none")]
    pub side: Option<Side>,

    /// The position size (in base asset).
    ///
    /// The quantity of the base asset held in the position (e.g., BTC in `BTCUSDT`). Bots use this to calculate position value and risk exposure.
    #[serde(with = "string_to_float")]
    pub size: f64,

    /// The average entry price of the position (optional).
    ///
    /// The average price at which the position was opened. Bots use this to calculate unrealized P&L and assess position profitability.
    #[serde(with = "string_to_float_optional")]
    pub avg_price: Option<f64>,

    /// The position value (optional).
    ///
    /// The monetary value of the position (`size` * `avg_price`). Bots use this to calculate margin requirements and exposure in the settlement currency.
    #[serde(with = "string_to_float_optional")]
    pub position_value: Option<f64>,

    /// The trade mode (0 for cross margin, 1 for isolated margin).
    ///
    /// Indicates whether the position uses cross margin (shared across positions) or isolated margin (specific to this position). Bots use this to manage margin allocation strategies.
    pub trade_mode: i32,

    /// The position status (e.g., "Normal", "Liq").
    ///
    /// Indicates the current state of the position, such as active or in liquidation. Bots use this to trigger risk management actions if the position is at risk.
    pub position_status: String,

    /// Auto-margin addition status (0 or 1).
    ///
    /// Indicates whether auto-margin addition is enabled (`1`) or disabled (`0`). Bots use this to monitor margin settings and prevent unexpected margin calls.
    pub auto_add_margin: i32,

    /// The Auto-Deleveraging (ADL) rank indicator.
    ///
    /// Indicates the position’s priority for auto-deleveraging in case of market stress. Higher ranks (e.g., 4) are deleveraged first. Bots use this to assess liquidation risk.
    pub adl_rank_indicator: i32,

    /// The leverage applied to the position (optional).
    ///
    /// The leverage multiplier (e.g., `10` for 10x). Bots use this to calculate margin requirements and assess risk exposure.
    #[serde(with = "string_to_float_optional")]
    pub leverage: Option<f64>,

    /// The position’s margin balance.
    ///
    /// The amount of margin allocated to the position. Bots use this to monitor margin health and prevent liquidation.
    #[serde(with = "string_to_float")]
    pub position_balance: f64,

    /// The mark price of the position.
    ///
    /// The current mark price used for P&L calculations in perpetual futures. Bots use this to calculate unrealized P&L and assess position health.
    #[serde(with = "string_to_float")]
    pub mark_price: f64,

    /// The liquidation price (optional).
    ///
    /// The price at which the position will be liquidated. Bots use this to set stop-loss orders or trigger risk management actions.
    #[serde(with = "string_to_float_optional")]
    pub liq_price: Option<f64>,

    /// The bankruptcy price (optional).
    ///
    /// The price at which the position would result in account bankruptcy. Bots use this as a critical risk threshold for position management.
    #[serde(with = "string_to_float_optional")]
    pub bust_price: Option<f64>,

    /// The maintenance margin for the position (optional).
    ///
    /// The minimum margin required to maintain the position. Bots use this to calculate margin ratios and avoid liquidation.
    #[serde(rename = "positionMM", with = "string_to_float_optional")]
    pub position_mm: Option<f64>,

    /// The initial margin for the position (optional).
    ///
    /// The initial margin required to open the position. Bots use this to calculate leverage and margin utilization.
    #[serde(rename = "positionIM", with = "string_to_float_optional")]
    pub position_im: Option<f64>,

    /// The take-profit/stop-loss mode (e.g., "Full", "Partial").
    ///
    /// Indicates whether take-profit and stop-loss orders are applied to the entire position (`Full`) or partially. Bots use this to manage exit strategies.
    pub tpsl_mode: String,

    /// The take-profit price (optional).
    ///
    /// The price at which the position will automatically close for a profit. Bots use this to implement automated exit strategies.
    #[serde(with = "string_to_float_optional")]
    pub take_profit: Option<f64>,

    /// The stop-loss price (optional).
    ///
    /// The price at which the position will automatically close to limit losses. Bots use this to manage downside risk.
    #[serde(with = "string_to_float_optional")]
    pub stop_loss: Option<f64>,

    /// The trailing stop value.
    ///
    /// The trailing stop offset, if enabled. Bots use this to implement dynamic stop-loss strategies that follow market movements.
    pub trailing_stop: String,

    /// The unrealized profit and loss (optional).
    ///
    /// The current unrealized P&L for the position, based on the mark price. Bots use this to monitor position profitability in real time.
    #[serde(with = "string_to_float_optional")]
    pub unrealised_pnl: Option<f64>,

    /// The cumulative realized profit and loss (optional).
    ///
    /// The total realized P&L for the position from all executions. Bots use this to track historical performance.
    #[serde(with = "string_to_float_optional")]
    pub cum_realised_pnl: Option<f64>,

    /// The sequence number of the position update.
    ///
    /// A unique sequence ID for ordering position updates. Bots use this to ensure proper chronological processing of position data.
    pub seq: u64,

    /// Indicates if the position is reduce-only.
    ///
    /// `true` if the position can only be reduced (e.g., closing trades only). Bots use this to enforce position management rules.
    pub is_reduce_only: bool,

    /// The timestamp of the last margin maintenance update (optional).
    ///
    /// Indicates when the margin maintenance requirements were last updated. Bots use this to monitor margin health over time.
    #[serde(with = "string_to_u64_optional")]
    pub mmr_sys_updated_time: Option<u64>,

    /// The timestamp of the last leverage update (optional).
    ///
    /// Indicates when the leverage settings were last updated. Bots use this to track changes in risk exposure.
    #[serde(with = "string_to_u64_optional")]
    pub leverage_sys_updated_time: Option<u64>,

    /// The timestamp when the position was created.
    ///
    /// Indicates when the position was opened. Bots use this to calculate position duration and align with other time-series data.
    #[serde(with = "string_to_u64")]
    pub created_time: u64,

    /// The timestamp of the last position update.
    ///
    /// Indicates when the position was last modified (e.g., size or margin changes). Bots use this to track position changes in real time.
    #[serde(with = "string_to_u64")]
    pub updated_time: u64,
}

/// Test module for deserializing position information.
#[cfg(test)]
mod test_decode_position_info {
    use super::*;

    /// Tests deserialization of a position info response from JSON.
    ///
    /// Ensures that the `PositionInfo` struct correctly parses a sample JSON response, verifying key fields like `cum_realised_pnl` and timestamps. This is critical for bots to confirm accurate position data processing.
    #[test]
    fn test_deserialize() {
        let json = r#"
             {
                "positionIdx": 0,
                "riskId": 1,
                "riskLimitValue": "150",
                "symbol": "BTCUSD",
                "side": "Sell",
                "size": "300",
                "avgPrice": "27464.50441675",
                "positionValue": "0.01092319",
                "tradeMode": 0,
                "positionStatus": "Normal",
                "autoAddMargin": 1,
                "adlRankIndicator": 2,
                "leverage": "10",
                "positionBalance": "0.00139186",
                "markPrice": "28224.50",
                "liqPrice": "",
                "bustPrice": "999999.00",
                "positionMM": "0.0000015",
                "positionIM": "0.00010923",
                "tpslMode": "Full",
                "takeProfit": "0.00",
                "stopLoss": "0.00",
                "trailingStop": "0.00",
                "unrealisedPnl": "-0.00029413",
                "curRealisedPnl": "0.00013123",
                "cumRealisedPnl": "-0.00096902",
                "seq": 5723621632,
                "isReduceOnly": false,
                "mmrSysUpdatedTime": "1676538056444",
                "leverageSysUpdatedTime": "1676538056333",
                "sessionAvgPrice": "",
                "createdTime": "1676538056258",
                "updatedTime": "1697673600012"
            }
        "#;
        let result = serde_json::from_str::<PositionInfo>(json);
        let result = result.unwrap();
        assert_eq!(result.cum_realised_pnl, Some(-0.00096902));
        assert_eq!(result.mmr_sys_updated_time, Some(1676538056444));
        assert_eq!(result.leverage_sys_updated_time, Some(1676538056333));
        assert_eq!(result.created_time, 1676538056258);
        assert_eq!(result.updated_time, 1697673600012);
    }
}

/// Parameters for setting leverage for a trading pair.
///
/// Used to construct a request to the `/v5/position/set-leverage` endpoint to adjust leverage for a specific symbol. Bots use this to manage risk exposure in perpetual futures, as higher leverage increases both potential returns and liquidation risk.
#[derive(Clone, Default)]
pub struct LeverageRequest<'a> {
    /// The product category (e.g., Linear, Inverse).
    ///
    /// Specifies the instrument type. Bots must set this to target the correct contract type.
    pub category: Category,

    /// The trading pair symbol (e.g., "BTCUSDT").
    ///
    /// Identifies the perpetual futures contract for which leverage is being set. Bots must specify a valid symbol.
    pub symbol: Cow<'a, str>,

    /// The leverage value (e.g., 10 for 10x).
    ///
    /// The desired leverage multiplier. Bots should ensure this complies with Bybit’s maximum leverage limits for the symbol to avoid request failures.
    pub leverage: i8,
}

impl<'a> LeverageRequest<'a> {
    /// Constructs a new Leverage request with specified parameters.
    ///
    /// Allows customization of the leverage request. Bots should use this to specify the exact symbol, category, and leverage value.
    pub fn new(category: Category, symbol: &'a str, leverage: i8) -> Self {
        Self {
            category,
            symbol: Cow::Borrowed(symbol),
            leverage,
        }
    }

    /// Creates a default Leverage request.
    ///
    /// Returns a request with `category` set to `Linear`, `symbol` set to `"BTCUSDT"`, and `leverage` set to `10`. Suitable for testing but should be customized for production.
    pub fn default() -> LeverageRequest<'a> {
        LeverageRequest::new(Category::Linear, "BTCUSDT", 10)
    }
}

/// Response structure for leverage setting requests.
///
/// Returned by the `/v5/position/set-leverage` endpoint, this struct confirms the result of setting leverage for a trading pair. Bots use this to verify successful leverage adjustments and handle errors.
#[derive(Serialize, Deserialize, Clone, Debug)]
#[serde(rename_all = "camelCase")]
pub struct LeverageResponse {
    /// The return code indicating the success or failure of the request.
    ///
    /// A `0` indicates success. Non-zero codes require error handling for issues like invalid leverage values. Bots should implement retry logic or parameter adjustments.
    pub ret_code: i32,

    /// A human-readable message describing the result or error.
    ///
    /// Provides context for the `ret_code`, such as `"OK"` or an error description. Bots should log this for debugging.
    pub ret_msg: String,

    /// The result of the leverage setting (typically empty).
    ///
    /// Usually an `Empty` struct, as Bybit does not return additional data for this endpoint. Bots can ignore this unless verifying response structure.
    pub result: Empty,

    /// Additional information, typically an empty object.
    ///
    /// Usually an `Empty` struct and can be ignored unless verifying response structure.
    pub ret_ext_info: Empty,

    /// The timestamp of the response in milliseconds.
    ///
    /// Indicates when the response was generated. Bots can use this to ensure data freshness and measure latency.
    pub time: u64,
}

/// Parameters for changing margin settings for a position.
///
/// Used to construct a request to the `/v5/position/switch-margin` endpoint to switch between cross and isolated margin modes or adjust leverage. Bots use this to optimize margin usage and manage risk in perpetual futures.
#[derive(Default, Clone)]
pub struct ChangeMarginRequest<'a> {
    /// The product category (e.g., Linear, Inverse).
    ///
    /// Specifies the instrument type. Bots must set this to target the correct contract type.
    pub category: Category,

    /// The trading pair symbol (e.g., "BTCUSDT").
    ///
    /// Identifies the perpetual futures contract for which margin settings are being changed. Bots must specify a valid symbol.
    pub symbol: Cow<'a, str>,

    /// The trade mode (0 for cross margin, 1 for isolated margin).
    ///
    /// Specifies whether to use cross margin (shared across positions) or isolated margin (specific to this position). Bots use this to control margin allocation.
    pub trade_mode: i8,

    /// The leverage value (e.g., 10 for 10x).
    ///
    /// The desired leverage multiplier. Bots should ensure this complies with Bybit’s limits for the symbol and trade mode.
    pub leverage: i8,
}

impl<'a> ChangeMarginRequest<'a> {
    /// Constructs a new ChangeMargin request with specified parameters.
    ///
    /// Allows customization of the margin change request. Bots should use this to specify the exact symbol, category, trade mode, and leverage.
    pub fn new(category: Category, symbol: &'a str, trade_mode: i8, leverage: i8) -> Self {
        Self {
            category,
            symbol: Cow::Borrowed(symbol),
            trade_mode: match trade_mode {
                1 => 1,
                0 => 0,
                _ => 0,
            },
            leverage,
        }
    }

    /// Creates a default ChangeMargin request.
    ///
    /// Returns a request with `category` set to `Linear`, `symbol` set to `"BTCUSDT"`, `trade_mode` set to `0` (cross margin), and `leverage` set to `10`. Suitable for testing but should be customized for production.
    pub fn default() -> ChangeMarginRequest<'a> {
        ChangeMarginRequest::new(Category::Linear, "BTCUSDT", 0, 10)
    }
}

/// Response structure for margin change requests.
///
/// Returned by the `/v5/position/switch-margin` endpoint, this struct confirms the result of changing margin settings for a position. Bots use this to verify successful margin adjustments and handle errors.
#[derive(Serialize, Deserialize, Clone, Debug)]
#[serde(rename_all = "camelCase")]
pub struct ChangeMarginResponse {
    /// The return code indicating the success or failure of the request.
    ///
    /// A `0` indicates success. Non-zero codes require error handling for issues like invalid trade modes. Bots should implement retry logic or parameter adjustments.
    pub ret_code: i32,

    /// A human-readable message describing the result or error.
    ///
    /// Provides context for the `ret_code`, such as `"OK"` or an error description. Bots should log this for debugging.
    pub ret_msg: String,

    /// The result of the margin change (typically empty).
    ///
    /// Usually an `Empty` struct, as Bybit does not return additional data for this endpoint. Bots can ignore this unless verifying response structure.
    pub result: Empty,

    /// Additional information, typically an empty object.
    ///
    /// Usually an `Empty` struct and can be ignored unless verifying response structure.
    pub ret_ext_info: Empty,

    /// The timestamp of the response in milliseconds.
    ///
    /// Indicates when the response was generated. Bots can use this to ensure data freshness and measure latency.
    pub time: u64,
}

/// Parameters for setting margin mode for an account or symbol.
///
/// Used to construct a request to the `/v5/account/set-margin-mode` endpoint to set the margin mode (cross or isolated) for an account or specific symbol. Bots use this to control margin allocation strategies across positions.
#[derive(Clone, Default)]
pub struct MarginModeRequest<'a> {
    /// The product category (e.g., Linear, Inverse).
    ///
    /// Specifies the instrument type. Bots must set this to target the correct contract type.
    pub category: Category,

    /// The margin mode (0 for cross margin, 1 for isolated margin).
    ///
    /// Specifies whether to use cross margin (shared across positions) or isolated margin (specific to each position). Bots use this to optimize margin usage.
    pub mode: i8,

    /// The trading pair symbol (e.g., "BTCUSDT") (optional).
    ///
    /// If specified, sets the margin mode for a specific symbol. If unset, applies to the entire account. Bots should specify this for targeted margin mode changes.
    pub symbol: Option<Cow<'a, str>>,

    /// The coin (e.g., "USDT") (optional).
    ///
    /// Optionally specifies the settlement currency. For `Linear` perpetuals, this is typically "USDT". Bots can use this to filter margin mode settings by currency.
    pub coin: Option<Cow<'a, str>>,
}

impl<'a> MarginModeRequest<'a> {
    /// Constructs a new MarginMode request with specified parameters.
    ///
    /// Allows customization of the margin mode request. Bots should use this to specify the category, mode, symbol, and coin as needed.
    pub fn new(
        category: Category,
        mode: i8,
        symbol: Option<&'a str>,
        coin: Option<&'a str>,
    ) -> Self {
        Self {
            category,
            mode,
            symbol: symbol.map(Cow::Borrowed),
            coin: coin.map(Cow::Borrowed),
        }
    }

    /// Creates a default MarginMode request.
    ///
    /// Returns a request with `category` set to `Linear`, `mode` set to `1` (isolated margin), and no symbol or coin specified. Suitable for testing but should be customized for production.
    pub fn default() -> MarginModeRequest<'a> {
        MarginModeRequest::new(Category::Linear, 1, None, None)
    }
}

/// Response structure for margin mode setting requests.
///
/// Returned by the `/v5/account/set-margin-mode` endpoint, this struct confirms the result of setting the margin mode. Bots use this to verify successful mode changes and handle errors.
#[derive(Serialize, Deserialize, Clone, Debug)]
#[serde(rename_all = "camelCase")]
pub struct MarginModeResponse {
    /// The return code indicating the success or failure of the request.
    ///
    /// A `0` indicates success. Non-zero codes require error handling for issues like invalid modes. Bots should implement retry logic or parameter adjustments.
    pub ret_code: i32,

    /// A human-readable message describing the result or error.
    ///
    /// Provides context for the `ret_code`, such as `"OK"` or an error description. Bots should log this for debugging.
    pub ret_msg: String,

    /// The result of the margin mode setting (typically empty).
    ///
    /// Usually an `Empty` struct, as Bybit does not return additional data for this endpoint. Bots can ignore this unless verifying response structure.
    pub result: Empty,

    /// Additional information, typically an empty object.
    ///
    /// Usually an `Empty` struct and can be ignored unless verifying response structure.
    pub ret_ext_info: Empty,

    /// The timestamp of the response in milliseconds.
    ///
    /// Indicates when the response was generated. Bots can use this to ensure data freshness and measure latency.
    pub time: u64,
}

/// Parameters for setting risk limits for a position.
///
/// Used to construct a request to the `/v5/position/set-risk-limit` endpoint to adjust risk limits for a specific symbol. Bots use this to control maximum exposure and manage liquidation risk in perpetual futures.
#[derive(Clone, Default)]
pub struct SetRiskLimit<'a> {
    /// The product category (e.g., Linear, Inverse).
    ///
    /// Specifies the instrument type. Bots must set this to target the correct contract type.
    pub category: Category,

    /// The trading pair symbol (e.g., "BTCUSDT").
    ///
    /// Identifies the perpetual futures contract for which risk limits are being set. Bots must specify a valid symbol.
    pub symbol: Cow<'a, str>,

    /// The risk ID to apply.
    ///
    /// Identifies the risk limit tier to use, corresponding to specific margin and exposure limits. Bots should select a risk ID that aligns with their risk management strategy.
    pub risk_id: i8,

    /// The position index (optional).
    ///
    /// Specifies the position type (e.g., 0 for one-way mode, 1 or 2 for hedge mode). Bots should set this for hedge mode positions to target the correct side.
    pub position_idx: Option<i32>,
}

impl<'a> SetRiskLimit<'a> {
    /// Constructs a new SetRiskLimit request with specified parameters.
    ///
    /// Allows customization of the risk limit request. Bots should use this to specify the category, symbol, risk ID, and position index as needed.
    pub fn new(
        category: Category,
        symbol: &'a str,
        risk_id: i8,
        position_idx: Option<i32>,
    ) -> Self {
        Self {
            category,
            symbol: Cow::Borrowed(symbol),
            risk_id,
            position_idx,
        }
    }

    /// Creates a default SetRiskLimit request.
    ///
    /// Returns a request with `category` set to `Linear`, `symbol` set to `"BTCUSDT"`, `risk_id` set to `1`, and no position index. Suitable for testing but should be customized for production.
    pub fn default() -> SetRiskLimit<'a> {
        SetRiskLimit::new(Category::Linear, "BTCUSDT", 1, None)
    }
}

/// Response structure for risk limit setting requests.
///
/// Returned by the `/v5/position/set-risk-limit` endpoint, this struct confirms the result of setting risk limits for a position. Bots use this to verify successful risk limit adjustments and handle errors.
#[derive(Serialize, Deserialize, Clone, Debug)]
#[serde(rename_all = "camelCase")]
pub struct SetRiskLimitResponse {
    /// The return code indicating the success or failure of the request.
    ///
    /// A `0` indicates success. Non-zero codes require error handling for issues like invalid risk IDs. Bots should implement retry logic or parameter adjustments.
    pub ret_code: i32,

    /// A human-readable message describing the result or error.
    ///
    /// Provides context for the `ret_code`, such as `"OK"` or an error description. Bots should log this for debugging.
    pub ret_msg: String,

    /// The result of the risk limit setting.
    ///
    /// Contains details of the applied risk limit, including the risk ID and limit value. Bots use this to confirm the new risk settings.
    pub result: SetRiskLimitResult,

    /// Additional information, typically an empty object.
    ///
    /// Usually an `Empty` struct and can be ignored unless verifying response structure.
    pub ret_ext_info: Empty,

    /// The timestamp of the response in milliseconds.
    ///
    /// Indicates when the response was generated. Bots can use this to ensure data freshness and measure latency.
    pub time: u64,
}

/// Details the result of setting a risk limit.
///
/// Part of the `SetRiskLimitResponse`, this struct provides the applied risk limit details. Bots use this to confirm the new risk settings for a position.
#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct SetRiskLimitResult {
    /// The applied risk ID.
    ///
    /// Confirms the risk limit tier applied to the position. Bots should verify this matches the requested `risk_id`.
    pub risk_id: i32,

    /// The risk limit value.
    ///
    /// The maximum exposure allowed for the position, in the settlement currency. Bots use this to ensure compliance with risk management settings.
    #[serde(with = "string_to_u64")]
    pub risk_limit_value: u64,

    /// The product category (e.g., "linear").
    ///
    /// Indicates the instrument type. Bots should verify this matches the requested `category`.
    pub category: String,
}

/// Parameters for setting trading stop conditions (take-profit/stop-loss).
///
/// Used to construct a request to the `/v5/position/trading-stop` endpoint to set take-profit and stop-loss conditions for a position. Bots use this to implement automated exit strategies and manage risk in perpetual futures trading. This struct supports partial take-profit/stop-loss modes, allowing precise control over position exits.
#[derive(Clone, Default)]
pub struct TradingStopRequest<'a> {
    /// The product category (e.g., Linear, Inverse).
    ///
    /// Specifies the instrument type, such as `Linear` for USDT-margined perpetual futures. Bots must set this correctly to target the desired contract type.
    pub category: Category,

    /// The trading pair symbol (e.g., "BTCUSDT").
    ///
    /// Identifies the perpetual futures contract for which trading stops are being set. Bots must specify a valid symbol to ensure the request targets the correct position.
    pub symbol: Cow<'a, str>,

    /// The take-profit price (optional).
    ///
    /// The price at which the position will close for a profit. Bots use this to lock in gains automatically, typically based on technical indicators or predefined targets.
    pub take_profit: Option<f64>,

    /// The stop-loss price (optional).
    ///
    /// The price at which the position will close to limit losses. Bots use this to manage downside risk, protecting capital during adverse market movements.
    pub stop_loss: Option<f64>,

    /// The trigger type for take-profit (e.g., "LastPrice", "MarkPrice") (optional).
    ///
    /// Specifies the price type used to trigger the take-profit order (e.g., `LastPrice` for the last traded price, `MarkPrice` for the mark price). Bots should choose a trigger type that aligns with their strategy to balance responsiveness and stability.
    pub tp_trigger_by: Option<Cow<'a, str>>,

    /// The trigger type for stop-loss (e.g., "LastPrice", "MarkPrice") (optional).
    ///
    /// Specifies the price type used to trigger the stop-loss order. Bots should select a trigger type that minimizes slippage while ensuring timely execution in volatile markets.
    pub sl_trigger_by: Option<Cow<'a, str>>,

    /// The take-profit/stop-loss mode (e.g., "Full", "Partial") (optional).
    ///
    /// Specifies whether the trading stops apply to the entire position (`Full`) or a portion (`Partial`). Bots use this to implement granular exit strategies, such as scaling out of positions.
    pub tpsl_mode: Option<Cow<'a, str>>,

    /// The order type for take-profit (optional).
    ///
    /// Specifies whether the take-profit order is a `Limit` or `Market` order. Bots can use `Limit` orders to target specific exit prices, reducing slippage in less volatile markets.
    pub tp_order_type: Option<OrderType>,

    /// The order type for stop-loss (optional).
    ///
    /// Specifies whether the stop-loss order is a `Limit` or `Market` order. Bots typically use `Market` orders for stop-losses to ensure execution during rapid price declines.
    pub sl_order_type: Option<OrderType>,

    /// The size of the take-profit order (optional).
    ///
    /// The quantity of the position to close when the take-profit is triggered, used in `Partial` mode. Bots use this to scale out of positions incrementally, optimizing profit capture.
    pub tp_size: Option<f64>,

    /// The size of the stop-loss order (optional).
    ///
    /// The quantity of the position to close when the stop-loss is triggered, used in `Partial` mode. Bots use this to limit losses on specific portions of a position.
    pub sl_size: Option<f64>,

    /// The limit price for the take-profit order (optional).
    ///
    /// The specific price for a `Limit` take-profit order. Bots use this to ensure the take-profit order executes at a favorable price, avoiding slippage in stable markets.
    pub tp_limit_price: Option<f64>,

    /// The limit price for the stop-loss order (optional).
    ///
    /// The specific price for a `Limit` stop-loss order. Bots use this cautiously, as limit orders may not execute in fast-moving markets, increasing risk exposure.
    pub sl_limit_price: Option<f64>,

    /// The position index (e.g., 0 for one-way mode, 1 or 2 for hedge mode).
    ///
    /// Specifies the position type in Bybit’s position management system. Bots must set this correctly to target the intended position (e.g., long or short in hedge mode).
    pub position_idx: i32,
}

impl<'a> TradingStopRequest<'a> {
    /// Constructs a new TradingStop request with specified parameters.
    ///
    /// Allows full customization of the trading stop request. Bots should use this to define the exact symbol, category, and trading stop parameters to align with their risk management strategy.
    pub fn new(
        category: Category,
        symbol: &'a str,
        take_profit: Option<f64>,
        stop_loss: Option<f64>,
        tp_trigger_by: Option<&'a str>,
        sl_trigger_by: Option<&'a str>,
        tpsl_mode: Option<&'a str>,
        tp_order_type: Option<OrderType>,
        sl_order_type: Option<OrderType>,
        tp_size: Option<f64>,
        sl_size: Option<f64>,
        tp_limit_price: Option<f64>,
        sl_limit_price: Option<f64>,
        position_idx: i32,
    ) -> Self {
        Self {
            category,
            symbol: Cow::Borrowed(symbol),
            take_profit,
            stop_loss,
            tp_trigger_by: tp_trigger_by.map(Cow::Borrowed),
            sl_trigger_by: sl_trigger_by.map(Cow::Borrowed),
            tpsl_mode: tpsl_mode.map(Cow::Borrowed),
            tp_order_type,
            sl_order_type,
            tp_size,
            sl_size,
            tp_limit_price,
            sl_limit_price,
            position_idx,
        }
    }

    /// Creates a default TradingStop request.
    ///
    /// Returns a request with `category` set to `Linear`, `symbol` set to `"BTCUSDT"`, `position_idx` set to `1`, and all other fields unset. Suitable for testing but should be customized for production to match specific trading needs.
    pub fn default() -> TradingStopRequest<'a> {
        TradingStopRequest::new(
            Category::Linear,
            "BTCUSDT",
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            None,
            1,
        )
    }
}

/// Response structure for trading stop setting requests.
///
/// Returned by the `/v5/position/trading-stop` endpoint, this struct confirms the result of setting take-profit and stop-loss conditions for a position. Bots use this to verify successful configuration and handle errors, ensuring risk management strategies are correctly implemented.
#[derive(Serialize, Deserialize, Clone, Debug)]
#[serde(rename_all = "camelCase")]
pub struct TradingStopResponse {
    /// The return code indicating the success or failure of the request.
    ///
    /// A `0` indicates success, while non-zero values indicate errors (e.g., `10001` for invalid parameters). Bots should check this and implement error handling, such as retrying or logging issues.
    pub ret_code: i32,

    /// A human-readable message describing the result or error.
    ///
    /// Typically `"OK"` for success or an error description (e.g., `"invalid symbol"`). Bots should log this for debugging and user feedback, especially when `ret_code` is non-zero.
    pub ret_msg: String,

    /// The result of the trading stop setting (typically empty).
    ///
    /// Usually an `Empty` struct, as Bybit does not return additional data for this endpoint. Bots can ignore this unless verifying response structure.
    pub result: Empty,

    /// Additional information, typically an empty object.
    ///
    /// Usually an `Empty` struct and can be ignored unless verifying response structure for error handling.
    pub ret_ext_info: Empty,

    /// The timestamp of the response in milliseconds.
    ///
    /// Indicates when the response was generated by Bybit’s server. Bots can use this to ensure data freshness and measure latency, critical for real-time risk management.
    pub time: u64,
}

/// Parameters for enabling or disabling auto-add margin for a position.
///
/// Used to construct a request to the `/v5/position/set-auto-add-margin` endpoint to enable or disable automatic margin addition for a specific position. Bots use this to control margin behavior, preventing unwanted margin calls or optimizing capital allocation in perpetual futures.
#[derive(Clone, Default)]
pub struct AddMarginRequest<'a> {
    /// The product category (e.g., Linear, Inverse).
    ///
    /// Specifies the instrument type. Bots must set this to target the correct contract type, such as `Linear` for USDT-margined perpetuals.
    pub category: Category,

    /// The trading pair symbol (e.g., "BTCUSDT").
    ///
    /// Identifies the perpetual futures contract for which auto-add margin is being configured. Bots must specify a valid symbol.
    pub symbol: Cow<'a, str>,

    /// Whether to enable auto-add margin.
    ///
    /// If `true`, Bybit will automatically add margin to prevent liquidation when margin levels are low. If `false`, no automatic margin addition occurs, increasing liquidation risk. Bots should set this based on their risk tolerance and capital management strategy.
    pub auto_add: bool,

    /// The position index (optional, e.g., 0 for one-way mode, 1 or 2 for hedge mode).
    ///
    /// Specifies the position type. Bots should set this for hedge mode positions to target the correct side (e.g., long or short). If unset, applies to the default position.
    pub position_idx: Option<i32>,
}

impl<'a> AddMarginRequest<'a> {
    /// Constructs a new AddMargin request with specified parameters.
    ///
    /// Allows customization of the auto-add margin request. Bots should use this to specify the exact symbol, category, and auto-add setting to align with their margin management strategy.
    pub fn new(
        category: Category,
        symbol: &'a str,
        auto_add: bool,
        position_idx: Option<i32>,
    ) -> Self {
        Self {
            category,
            symbol: Cow::Borrowed(symbol),
            auto_add,
            position_idx,
        }
    }

    /// Creates a default AddMargin request.
    ///
    /// Returns a request with `category` set to `Linear`, `symbol` set to `"BTCUSDT"`, `auto_add` set to `false`, and no position index. Suitable for testing but should be customized for production.
    pub fn default() -> AddMarginRequest<'a> {
        AddMarginRequest::new(Category::Linear, "BTCUSDT", false, None)
    }
}

/// Response structure for auto-add margin setting requests.
///
/// Returned by the `/v5/position/set-auto-add-margin` endpoint, this struct confirms the result of enabling or disabling auto-add margin. Bots use this to verify successful configuration and handle errors, ensuring proper margin management.
#[derive(Serialize, Deserialize, Clone, Debug)]
#[serde(rename_all = "camelCase")]
pub struct AddMarginResponse {
    /// The return code indicating the success or failure of the request.
    ///
    /// A `0` indicates success. Non-zero codes require error handling for issues like invalid symbols. Bots should implement retry logic or parameter adjustments.
    pub ret_code: i32,

    /// A human-readable message describing the result or error.
    ///
    /// Provides context for the `ret_code`, such as `"OK"` or an error description. Bots should log this for debugging and user feedback.
    pub ret_msg: String,

    /// The result of the auto-add margin setting (typically empty).
    ///
    /// Usually an `Empty` struct, as Bybit does not return additional data for this endpoint. Bots can ignore this unless verifying response structure.
    pub result: Empty,

    /// Additional information, typically an empty object.
    ///
    /// Usually an `Empty` struct and can be ignored unless verifying response structure.
    pub ret_ext_info: Empty,

    /// The timestamp of the response in milliseconds.
    ///
    /// Indicates when the response was generated. Bots can use this to ensure data freshness and measure latency.
    pub time: u64,
}

/// Parameters for manually adding or reducing margin for a position.
///
/// Used to construct a request to the `/v5/position/add-margin` endpoint to manually adjust the margin allocated to a specific position. Bots use this to increase margin to avoid liquidation or reduce margin to free up capital in perpetual futures trading.
#[derive(Clone, Default)]
pub struct AddReduceMarginRequest<'a> {
    /// The product category (e.g., Linear, Inverse).
    ///
    /// Specifies the instrument type. Bots must set this to target the correct contract type.
    pub category: Category,

    /// The trading pair symbol (e.g., "BTCUSDT").
    ///
    /// Identifies the perpetual futures contract for which margin is being adjusted. Bots must specify a valid symbol.
    pub symbol: Cow<'a, str>,

    /// The margin amount to add (positive) or reduce (negative).
    ///
    /// A positive value adds margin to the position, reducing liquidation risk. A negative value reduces margin, freeing up capital but increasing risk. Bots should calculate this based on position size and margin requirements.
    pub margin: f64,

    /// The position index (optional, e.g., 0 for one-way mode, 1 or 2 for hedge mode).
    ///
    /// Specifies the position type. Bots should set this for hedge mode positions to target the correct side. If unset, applies to the default position.
    pub position_idx: Option<i32>,
}

impl<'a> AddReduceMarginRequest<'a> {
    /// Constructs a new AddReduceMargin request with specified parameters.
    ///
    /// Allows customization of the margin adjustment request. Bots should use this to specify the exact symbol, category, margin amount, and position index.
    pub fn new(
        category: Category,
        symbol: &'a str,
        margin: f64,
        position_idx: Option<i32>,
    ) -> Self {
        Self {
            category,
            symbol: Cow::Borrowed(symbol),
            margin,
            position_idx,
        }
    }

    /// Creates a default AddReduceMargin request.
    ///
    /// Returns a request with `category` set to `Linear`, `symbol` set to `"BTCUSDT"`, `margin` set to `1.0`, and no position index. Suitable for testing but should be customized for production.
    pub fn default() -> AddReduceMarginRequest<'a> {
        AddReduceMarginRequest::new(Category::Linear, "BTCUSDT", 1.0, None)
    }
}

/// Response structure for margin adjustment requests.
///
/// Returned by the `/v5/position/add-margin` endpoint, this struct provides the result of adding or reducing margin for a position. Bots use this to confirm the new position state, including updated margin and risk metrics, and handle errors.
#[derive(Serialize, Deserialize, Clone, Debug)]
#[serde(rename_all = "camelCase")]
pub struct AddReduceMarginResponse {
    /// The return code indicating the success or failure of the request.
    ///
    /// A `0` indicates success. Non-zero codes require error handling for issues like insufficient margin. Bots should implement retry logic or parameter adjustments.
    pub ret_code: i32,

    /// A human-readable message describing the result or error.
    ///
    /// Provides context for the `ret_code`, such as `"OK"` or an error description. Bots should log this for debugging.
    pub ret_msg: String,

    /// The updated position details after margin adjustment.
    ///
    /// Contains the new position state, including size, margin, and P&L. Bots use this to update their position tracking systems and verify the margin change.
    pub result: AddReduceMarginResult,

    /// Additional information, typically an empty object.
    ///
    /// Usually an `Empty` struct and can be ignored unless verifying response structure.
    pub ret_ext_info: Empty,

    /// The timestamp of the response in milliseconds.
    ///
    /// Indicates when the response was generated. Bots can use this to ensure data freshness and measure latency.
    pub time: u64,
}

/// Details the result of a margin adjustment for a position.
///
/// Part of the `AddReduceMarginResponse`, this struct provides updated position metrics after adding or reducing margin. Bots use this to confirm the new position state and update risk management calculations.
#[derive(Serialize, Deserialize, Clone, Debug)]
#[serde(rename_all = "camelCase")]
pub struct AddReduceMarginResult {
    /// The product category (e.g., Linear).
    ///
    /// Indicates the instrument type of the position. Bots should verify this matches the requested `category`.
    pub category: Category,

    /// The trading pair symbol (e.g., "BTCUSDT").
    ///
    /// Identifies the perpetual futures contract. Bots should confirm this matches the requested symbol.
    pub symbol: String,

    /// The position index (e.g., 0 for one-way mode, 1 or 2 for hedge mode).
    ///
    /// Indicates the position type. Bots use this to distinguish between long and short positions in hedge mode.
    pub position_idx: i32,

    /// The risk ID associated with the position.
    ///
    /// Identifies the risk limit tier applied to the position. Bots use this to verify compliance with risk management settings.
    pub risk_id: i32,

    /// The risk limit value for the position.
    ///
    /// The maximum exposure allowed for the position, in the settlement currency. Bots use this to ensure positions stay within risk limits.
    #[serde(with = "string_to_float")]
    pub risk_limit_value: f64,

    /// The position size (in base asset).
    ///
    /// The quantity of the base asset held in the position. Bots use this to calculate position value and risk exposure.
    #[serde(with = "string_to_float")]
    pub size: f64,

    /// The position value.
    ///
    /// The monetary value of the position (`size` * `avg_price`). Bots use this to calculate margin requirements and exposure.
    #[serde(with = "string_to_float")]
    pub position_value: f64,

    /// The average entry price of the position.
    ///
    /// The average price at which the position was opened. Bots use this to calculate unrealized P&L and assess profitability.
    #[serde(with = "string_to_float")]
    pub avg_price: f64,

    /// The liquidation price.
    ///
    /// The price at which the position will be liquidated. Bots use this to set stop-loss orders or trigger risk management actions.
    #[serde(with = "string_to_float")]
    pub liq_price: f64,

    /// The bankruptcy price.
    ///
    /// The price at which the position would result in account bankruptcy. Bots use this as a critical risk threshold.
    #[serde(with = "string_to_float")]
    pub bust_price: f64,

    /// The mark price of the position.
    ///
    /// The current mark price used for P&L calculations in perpetual futures. Bots use this to calculate unrealized P&L and assess position health.
    #[serde(with = "string_to_float")]
    pub mark_price: f64,

    /// The leverage applied to the position.
    ///
    /// The leverage multiplier (e.g., "10" for 10x). Bots use this to calculate margin requirements and assess risk exposure.
    pub leverage: String,

    /// Auto-margin addition status (0 or 1).
    ///
    /// Indicates whether auto-margin addition is enabled (`1`) or disabled (`0`). Bots use this to monitor margin settings.
    pub auto_add_margin: i32,

    /// The position status (e.g., "Normal", "Liq").
    ///
    /// Indicates the current state of the position, such as active or in liquidation. Bots use this to trigger risk management actions if needed.
    pub position_status: String,

    /// The initial margin for the position.
    ///
    /// The initial margin required to maintain the position. Bots use this to calculate leverage and margin utilization.
    #[serde(rename = "positionIM")]
    pub position_im: String,

    /// The maintenance margin for the position.
    ///
    /// The minimum margin required to avoid liquidation. Bots use this to calculate margin ratios and manage risk.
    #[serde(rename = "positionMM")]
    pub position_mm: String,

    /// The unrealized profit and loss.
    ///
    /// The current unrealized P&L for the position, based on the mark price. Bots use this to monitor position profitability in real time.
    pub unrealised_pnl: String,

    /// The cumulative realized profit and loss.
    ///
    /// The total realized P&L for the position from all executions. Bots use this to track historical performance.
    pub cum_realised_pnl: String,

    /// The stop-loss price (optional).
    ///
    /// The price at which the position will automatically close to limit losses. Bots use this to verify stop-loss settings.
    #[serde(with = "string_to_float_optional")]
    pub stop_loss: Option<f64>,

    /// The take-profit price (optional).
    ///
    /// The price at which the position will automatically close for a profit. Bots use this to verify take-profit settings.
    #[serde(with = "string_to_float_optional")]
    pub take_profit: Option<f64>,

    /// The trailing stop value.
    ///
    /// The trailing stop offset, if enabled. Bots use this to verify dynamic stop-loss settings that follow market movements.
    pub trailing_stop: String,

    /// The timestamp when the position was created.
    ///
    /// Indicates when the position was opened. Bots use this to calculate position duration and align with other time-series data.
    #[serde(with = "string_to_u64")]
    pub created_time: u64,

    /// The timestamp of the last position update.
    ///
    /// Indicates when the position was last modified (e.g., margin or size changes). Bots use this to track position changes in real time.
    #[serde(with = "string_to_u64")]
    pub updated_time: u64,
}

/// Parameters for requesting closed profit and loss (P&L) data.
///
/// Used to construct a request to the `/v5/position/closed-pnl` endpoint to retrieve historical P&L data for closed positions. Bots use this to analyze trading performance, calculate realized profits, and refine strategies for perpetual futures.
#[derive(Clone, Default)]
pub struct ClosedPnlRequest<'a> {
    /// The product category (e.g., Linear, Inverse).
    ///
    /// Specifies the instrument type. Bots must set this to fetch P&L data for the correct contract type.
    pub category: Category,

    /// The trading pair symbol (e.g., "BTCUSDT") (optional).
    ///
    /// Optionally filters P&L data by symbol. If unset, data for all symbols in the category is returned. Bots should specify this for targeted performance analysis.
    pub symbol: Option<Cow<'a, str>>,

    /// The start time for the P&L data (Unix timestamp in milliseconds) (optional).
    ///
    /// Defines the beginning of the time range. Bots should set this to focus on a specific historical period, such as a trading session or month.
    pub start_time: Option<u64>,

    /// The end time for the P&L data (Unix timestamp in milliseconds) (optional).
    ///
    /// Defines the end of the time range. Bots should set this to limit data to a specific period, optimizing performance.
    pub end_time: Option<u64>,

    /// The maximum number of P&L records to return (optional).
    ///
    /// Controls the number of records returned (e.g., max 50). Bots should set a reasonable limit to balance data completeness with performance.
    pub limit: Option<u64>,
}

impl<'a> ClosedPnlRequest<'a> {
    /// Constructs a new ClosedPnl request with specified parameters.
    ///
    /// Allows customization of the P&L request. Bots should use this to specify the exact symbol, category, time range, and limit to align with their analysis needs.
    pub fn new(
        category: Category,
        symbol: Option<&'a str>,
        start_time: Option<u64>,
        end_time: Option<u64>,
        limit: Option<u64>,
    ) -> Self {
        Self {
            category,
            symbol: symbol.map(Cow::Borrowed),
            start_time,
            end_time,
            limit,
        }
    }

    /// Creates a default ClosedPnl request.
    ///
    /// Returns a request with `category` set to `Linear` and all other fields unset. Suitable for broad queries but should be customized for specific analysis needs.
    pub fn default() -> ClosedPnlRequest<'a> {
        ClosedPnlRequest::new(Category::Linear, None, None, None, None)
    }
}

/// Response structure for closed P&L data requests.
///
/// Returned by the `/v5/position/closed-pnl` endpoint, this struct provides historical P&L data for closed positions. Bots use this to analyze realized profits and losses, enabling performance evaluation and strategy optimization.
#[derive(Serialize, Deserialize, Clone, Debug)]
#[serde(rename_all = "camelCase")]
pub struct ClosedPnlResponse {
    /// The return code indicating the success or failure of the request.
    ///
    /// A `0` indicates success. Non-zero codes require error handling for issues like invalid symbols. Bots should implement retry logic or parameter adjustments.
    pub ret_code: i32,

    /// A human-readable message describing the result or error.
    ///
    /// Provides context for the `ret_code`, such as `"OK"` or an error description. Bots should log this for debugging.
    pub ret_msg: String,

    /// The closed P&L data summary.
    ///
    /// Contains the actual P&L records, including realized profits and trade details. Bots use this for performance analysis and strategy refinement.
    pub result: ClosedPnlResult,

    /// Additional information, typically an empty object.
    ///
    /// Usually an `Empty` struct and can be ignored unless verifying response structure.
    pub ret_ext_info: Empty,

    /// The timestamp of the response in milliseconds.
    ///
    /// Indicates when the response was generated. Bots can use this to ensure data freshness and align with other time-series data.
    pub time: u64,
}

/// Summarizes closed P&L data for closed positions.
///
/// Part of the `ClosedPnlResponse`, this struct organizes P&L data by category, pagination cursor, and a list of P&L records. Bots use this to process realized P&L and calculate performance metrics.
#[derive(Serialize, Deserialize, Clone, Debug)]
#[serde(rename_all = "camelCase")]
pub struct ClosedPnlResult {
    /// The cursor for pagination (optional).
    ///
    /// Indicates the next page of results for large datasets. Bots should use this for paginated requests to fetch additional P&L data when `limit` is reached.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_page_cursor: Option<String>,

    /// The product category (e.g., "linear").
    ///
    /// Indicates the instrument type. Bots should verify this matches the requested `category` to ensure data relevance.
    pub category: String,

    /// A list of closed P&L records.
    ///
    /// Contains detailed P&L data for each closed position, such as realized profit and trade size. Bots use this to calculate performance metrics and refine strategies.
    pub list: Vec<ClosedPnlItem>,
}

/// Represents a single closed P&L record.
///
/// Details the realized P&L for a closed position, including trade details and profit/loss metrics. Bots use this to analyze individual trade outcomes and assess strategy effectiveness in perpetual futures.
#[derive(Serialize, Deserialize, Clone, Debug)]
#[serde(rename_all = "camelCase")]
pub struct ClosedPnlItem {
    /// The trading pair symbol (e.g., "BTCUSDT").
    ///
    /// Identifies the perpetual futures contract for the closed position. Bots should verify this matches the requested symbol.
    pub symbol: String,

    /// The order type (e.g., "Limit", "Market").
    ///
    /// Indicates whether the closing trade was executed via a limit or market order. Bots use this to analyze execution strategy effectiveness.
    pub order_type: String,

    /// The leverage used for the position.
    ///
    /// The leverage multiplier (e.g., "10" for 10x). Bots use this to assess the impact of leverage on realized P&L.
    pub leverage: String,

    /// The timestamp of the last update to the P&L record.
    ///
    /// Indicates when the position was closed or P&L was finalized. Bots use this to align P&L data with other time-series data.
    #[serde(with = "string_to_u64")]
    pub updated_time: u64,

    /// The trade side ("Buy" or "Sell").
    ///
    /// Indicates whether the position was long (Buy) or short (Sell). Bots use this to track position direction and calculate net exposure.
    pub side: String,

    /// The unique order ID.
    ///
    /// Identifies the order that closed the position. Bots use this to correlate P&L with specific orders in their tracking systems.
    pub order_id: String,

    /// The realized profit and loss for the position.
    ///
    /// The net profit or loss from the closed position, in the settlement currency. Bots use this to calculate overall performance and profitability.
    #[serde(with = "string_to_float")]
    pub closed_pnl: f64,

    /// The average entry price of the position.
    ///
    /// The average price at which the position was opened. Bots use this to calculate the profit/loss relative to the exit price.
    #[serde(with = "string_to_float")]
    pub avg_entry_price: f64,

    /// The total quantity of the position.
    ///
    /// The amount of the base asset in the closed position. Bots use this to calculate position size and P&L magnitude.
    #[serde(with = "string_to_float")]
    pub qty: f64,

    /// The cumulative entry value of the position.
    ///
    /// The total monetary value of the position at entry (`qty` * `avg_entry_price`). Bots use this to assess position size in the settlement currency.
    #[serde(with = "string_to_float")]
    pub cum_entry_value: f64,

    /// The timestamp when the position was created.
    ///
    /// Indicates when the position was opened. Bots use this to calculate position duration and align with other data.
    #[serde(with = "string_to_float")]
    pub created_time: f64,

    /// The order price.
    ///
    /// The price specified in the closing order (for limit orders). Bots use this to compare with `avg_exit_price` to assess slippage.
    #[serde(with = "string_to_float")]
    pub order_price: f64,

    /// The size of the closed position.
    ///
    /// The portion of the position closed, in base asset units. Bots use this to track partial or full position closures.
    #[serde(with = "string_to_float")]
    pub closed_size: f64,

    /// The average exit price of the position.
    ///
    /// The average price at which the position was closed. Bots use this to calculate realized P&L (`closed_pnl` = `closed_size` * (`avg_exit_price` - `avg_entry_price`)).
    #[serde(with = "string_to_float")]
    pub avg_exit_price: f64,

    /// The execution type (e.g., "Trade", "Funding").
    ///
    /// Indicates the nature of the closing execution (e.g., regular trade or funding fee). Bots use this to filter P&L calculations.
    pub exec_type: String,

    /// The number of fills for the closing trade.
    ///
    /// Indicates how many partial executions occurred to close the position. Bots use this to analyze execution efficiency.
    pub fill_count: String,

    /// The cumulative exit value of the position.
    ///
    /// The total monetary value of the position at exit (`closed_size` * `avg_exit_price`). Bots use this to verify P&L calculations.
    #[serde(with = "string_to_float")]
    pub cum_exit_value: f64,
}

/// Parameters for moving a position between accounts.
///
/// Used to construct a request to the `/v5/position/move-position` endpoint to transfer a position from one Bybit account (UID) to another. Bots use this for portfolio management, such as consolidating positions or transferring risk between accounts in perpetual futures trading.
#[derive(Clone, Default, Serialize)]
pub struct MovePositionRequest<'a> {
    /// The source account UID.
    ///
    /// The unique identifier of the account from which the position is being transferred. Bots must ensure this UID has sufficient permissions and position size.
    pub from_uid: u64,

    /// The destination account UID.
    ///
    /// The unique identifier of the account to which the position is being transferred. Bots must verify the destination account is eligible to receive the position.
    pub to_uid: u64,

    /// A list of positions to move.
    ///
    /// Contains the details of each position to transfer, including symbol, price, side, and quantity. Bots should populate this with valid `PositionItem` structs to specify the exact positions to move.
    pub list: Vec<PositionItem<'a>>,
}

/// Represents a single position to be moved between accounts.
///
/// Part of the `MovePositionRequest`, this struct details the position to transfer, including its category, symbol, and trade parameters. Bots use this to specify which positions to move and at what price.
#[derive(Clone, Default, Serialize)]
pub struct PositionItem<'a> {
    /// The product category (e.g., Linear, Inverse).
    ///
    /// Specifies the instrument type of the position. Bots must set this to match the position’s contract type.
    pub category: Category,

    /// The trading pair symbol (e.g., "BTCUSDT").
    ///
    /// Identifies the perpetual futures contract for the position. Bots must specify a valid symbol.
    pub symbol: Cow<'a, str>,

    /// The transfer price.
    ///
    /// The price at which the position is transferred, used for valuation between accounts. Bots should set this based on the current mark price or a mutually agreed value to ensure fair transfer.
    pub price: f64,

    /// The position side (Buy or Sell).
    ///
    /// Indicates whether the position is long (Buy) or short (Sell). Bots use this to ensure the correct position direction is transferred.
    pub side: Side,

    /// The quantity of the position to move.
    ///
    /// The amount of the base asset to transfer. Bots should ensure this does not exceed the available position size in the source account.
    pub qty: f64,
}

impl<'a> MovePositionRequest<'a> {
    /// Constructs a new MovePosition request with specified parameters.
    ///
    /// Allows customization of the position transfer request. Bots should use this to specify the source and destination UIDs and the list of positions to move.
    pub fn new(from_uid: u64, to_uid: u64, list: Vec<PositionItem<'a>>) -> Self {
        Self {
            from_uid,
            to_uid,
            list,
        }
    }

    /// Creates a default MovePosition request.
    ///
    /// Returns a request with `from_uid` and `to_uid` set to `0` and an empty position list. Suitable for testing but should be customized with valid UIDs and positions for production.
    pub fn default() -> MovePositionRequest<'a> {
        MovePositionRequest::new(0, 0, vec![])
    }
}

impl<'a> PositionItem<'a> {
    /// Constructs a new PositionItem with specified parameters.
    ///
    /// Allows customization of the position to move. Bots should use this to specify the category, symbol, price, side, and quantity of the position.
    pub fn new(category: Category, symbol: &'a str, price: f64, side: Side, qty: f64) -> Self {
        Self {
            category,
            symbol: Cow::Borrowed(symbol),
            price,
            side,
            qty,
        }
    }

    /// Creates a default PositionItem.
    ///
    /// Returns a position item with `category` set to `Linear`, `symbol` set to `"BTCUSDT"`, `price` and `qty` set to `0.0`, and `side` set to `Buy`. Suitable for testing but should be customized for production.
    pub fn default() -> PositionItem<'a> {
        PositionItem::new(Category::Linear, "BTCUSDT", 0.0, Side::Buy, 0.0)
    }
}

/// Response structure for position move requests.
///
/// Returned by the `/v5/position/move-position` endpoint, this struct confirms the result of moving a position between accounts. Bots use this to verify successful transfers and handle errors, ensuring accurate portfolio management.
#[derive(Deserialize, Serialize, Clone, Debug)]
pub struct MovePositionResponse {
    /// The return code indicating the success or failure of the request.
    ///
    /// A `0` indicates success. Non-zero codes require error handling for issues like invalid UIDs or insufficient position size. Bots should implement retry logic or parameter adjustments.
    pub ret_code: i32,

    /// A human-readable message describing the result or error.
    ///
    /// Provides context for the `ret_code`, such as `"OK"` or an error description. Bots should log this for debugging.
    pub ret_msg: String,

    /// The result of the position move.
    ///
    /// Contains details of the transfer, including the block trade ID and status. Bots use this to confirm the transfer and update their position tracking systems.
    pub result: MovePositionResult,
}

/// Details the result of a position move between accounts.
///
/// Part of the `MovePositionResponse`, this struct provides the outcome of the position transfer, including identifiers and status. Bots use this to confirm the transfer and track its execution.
#[derive(Deserialize, Serialize, Clone, Debug)]
pub struct MovePositionResult {
    /// The block trade ID for the position move.
    ///
    /// A unique identifier for the transfer, treated as a block trade by Bybit. Bots use this to track the specific transfer event.
    pub block_trade_id: String,

    /// The status of the position move.
    ///
    /// Indicates whether the transfer was successful (e.g., "Filled") or encountered issues (e.g., "Rejected"). Bots should check this to confirm transfer completion.
    pub status: String,

    /// The party that rejected the move, if applicable.
    ///
    /// Identifies the account (source or destination) that caused a rejection, if any. Bots use this for error handling and to diagnose transfer failures.
    pub reject_party: String,
}

/// Parameters for requesting position move history.
///
/// Used to construct a request to the `/v5/position/move-history` endpoint to retrieve historical data on position transfers between accounts. Bots use this to audit past transfers, verify portfolio changes, and ensure compliance with trading rules.
#[derive(Serialize, Clone, Default)]
pub struct MoveHistoryRequest<'a> {
    /// The product category (e.g., Linear, Inverse) (optional).
    ///
    /// Optionally filters transfer history by instrument type. If unset, data for all categories is returned. Bots should specify this for targeted analysis.
    pub category: Option<Category>,

    /// The trading pair symbol (e.g., "BTCUSDT") (optional).
    ///
    /// Optionally filters transfer history by symbol. If unset, data for all symbols is returned. Bots should specify this to focus on specific contracts.
    pub symbol: Option<Cow<'a, str>>,

    /// The start time for the transfer history (Unix timestamp in milliseconds) (optional).
    ///
    /// Defines the beginning of the time range. Bots should set this to focus on a specific historical period.
    pub start_time: Option<u64>,

    /// The end time for the transfer history (Unix timestamp in milliseconds) (optional).
    ///
    /// Defines the end of the time range. Bots should set this to limit data to a specific period, optimizing performance.
    pub end_time: Option<u64>,

    /// The status of the transfers (e.g., "Filled", "Rejected") (optional).
    ///
    /// Optionally filters transfers by status. Bots can use this to analyze successful or failed transfers separately.
    pub status: Option<Cow<'a, str>>,

    /// The block trade ID (optional).
    ///
    /// Optionally filters transfers by a specific block trade ID. Bots can use this to retrieve details of a particular transfer event.
    pub block_trade_id: Option<Cow<'a, str>>,

    /// The maximum number of transfer records to return (optional).
    ///
    /// Controls the number of records returned as a string (e.g., "50"). Bots should set a reasonable limit to balance data completeness with performance.
    pub limit: Option<Cow<'a, str>>,
}

impl<'a> MoveHistoryRequest<'a> {
    /// Constructs a new MoveHistory request with specified parameters.
    ///
    /// Allows customization of the transfer history request. Bots should use this to specify the exact category, symbol, time range, and filters to align with their analysis needs.
    pub fn new(
        category: Option<Category>,
        symbol: Option<&'a str>,
        start_time: Option<u64>,
        end_time: Option<u64>,
        status: Option<&'a str>,
        block_trade_id: Option<&'a str>,
        limit: Option<&'a str>,
    ) -> Self {
        Self {
            category,
            symbol: symbol.map(Cow::Borrowed),
            start_time,
            end_time,
            status: status.map(Cow::Borrowed),
            block_trade_id: block_trade_id.map(Cow::Borrowed),
            limit: limit.map(Cow::Borrowed),
        }
    }

    /// Creates a default MoveHistory request.
    ///
    /// Returns a request with all fields unset. Suitable for broad queries but should be customized for specific analysis needs.
    pub fn default() -> MoveHistoryRequest<'a> {
        MoveHistoryRequest::new(None, None, None, None, None, None, None)
    }
}

/// Response structure for position move history requests.
///
/// Returned by the `/v5/position/move-history` endpoint, this struct provides historical data on position transfers between accounts. Bots use this to audit transfers and verify portfolio changes.
#[derive(Serialize, Deserialize, Clone, Debug)]
#[serde(rename_all = "camelCase")]
pub struct MoveHistoryResponse {
    /// The return code indicating the success or failure of the request.
    ///
    /// A `0` indicates success. Non-zero codes require error handling for issues like invalid parameters. Bots should implement retry logic or parameter adjustments.
    pub ret_code: i32,

    /// A human-readable message describing the result or error.
    ///
    /// Provides context for the `ret_code`, such as `"OK"` or an error description. Bots should log this for debugging.
    pub ret_msg: String,

    /// The position move history data summary.
    ///
    /// Contains the actual transfer records, including trade details and status. Bots use this to analyze past transfers and ensure compliance.
    pub result: MoveHistoryResult,

    /// Additional information, typically an empty object.
    ///
    /// Usually an `Empty` struct and can be ignored unless verifying response structure.
    pub ret_ext_info: Empty,

    /// The timestamp of the response in milliseconds.
    ///
    /// Indicates when the response was generated. Bots can use this to ensure data freshness and align with other time-series data.
    pub time: u64,
}

/// Summarizes position move history data.
///
/// Part of the `MoveHistoryResponse`, this struct organizes transfer history by pagination cursor and a list of transfer records. Bots use this to process and audit position transfers.
#[derive(Serialize, Deserialize, Clone, Debug)]
#[serde(rename_all = "camelCase")]
pub struct MoveHistoryResult {
    /// A list of position move records.
    ///
    /// Contains detailed transfer data, such as symbol, price, and status. Bots use this to audit transfers and verify portfolio changes.
    pub list: Vec<MoveHistoryEntry>,

    /// The cursor for pagination.
    ///
    /// Indicates the next page of results for large datasets. Bots should use this for paginated requests to fetch additional transfer history.
    #[serde(rename = "nextPageCursor")]
    pub next_page_cursor: String,
}

/// Represents a single position move history record.
///
/// Details a specific position transfer between accounts, including trade parameters and status. Bots use this to audit individual transfers and diagnose issues.
#[derive(Serialize, Deserialize, Clone, Debug)]
#[serde(rename_all = "camelCase")]
pub struct MoveHistoryEntry {
    /// The block trade ID for the transfer.
    ///
    /// A unique identifier for the position move, treated as a block trade. Bots use this to track specific transfer events.
    pub block_trade_id: String,

    /// The product category (e.g., "linear").
    ///
    /// Indicates the instrument type of the transferred position. Bots should verify this matches the requested category.
    pub category: String,

    /// The unique order ID.
    ///
    /// Identifies the order associated with the transfer. Bots use this to correlate transfers with specific orders.
    pub order_id: String,

    /// The user ID of the account involved.
    ///
    /// Indicates the account (source or destination) associated with the transfer. Bots use this to verify the correct accounts were involved.
    #[serde(rename = "userId")]
    pub user_id: u64,

    /// The trading pair symbol (e.g., "BTCUSDT").
    ///
    /// Identifies the perpetual futures contract for the transferred position. Bots should confirm this matches the requested symbol.
    pub symbol: String,

    /// The trade side ("Buy" or "Sell").
    ///
    /// Indicates whether the transferred position was long (Buy) or short (Sell). Bots use this to verify position direction.
    pub side: String,

    /// The transfer price.
    ///
    /// The price at which the position was transferred, used for valuation. Bots use this to verify the fairness of the transfer price.
    #[serde(with = "string_to_float")]
    pub price: f64,

    /// The quantity of the transferred position.
    ///
    /// The amount of the base asset transferred. Bots use this to verify the correct position size was moved.
    #[serde(with = "string_to_float")]
    pub qty: f64,

    /// The execution fee for the transfer.
    ///
    /// The fee charged for the transfer, in the settlement currency. Bots use this to calculate the net cost of the transfer.
    #[serde(with = "string_to_float")]
    pub exec_fee: f64,

    /// The status of the transfer (e.g., "Filled", "Rejected").
    ///
    /// Indicates whether the transfer was successful or encountered issues. Bots should check this to confirm transfer completion.
    pub status: String,

    /// The unique execution ID.
    ///
    /// A unique identifier for the transfer execution on Bybit’s exchange. Bots use this to track specific transfer events and avoid duplicates.
    pub exec_id: String,

    /// The result code for the transfer.
    ///
    /// A code indicating the outcome of the transfer (e.g., `0` for success). Bots should check this to identify issues with specific transfers.
    pub result_code: i16,

    /// A message describing the transfer result.
    ///
    /// Provides details about the transfer’s status, such as success or error reasons. Bots should log this for debugging and error handling.
    pub result_message: String,

    /// The timestamp when the transfer was created.
    ///
    /// Indicates when the transfer request was initiated. Bots use this to align transfer data with other time-series data.
    pub created_at: u64,

    /// The timestamp when the transfer was last updated.
    ///
    /// Indicates when the transfer status was last modified (e.g., completed or rejected). Bots use this to track transfer progress.
    pub updated_at: u64,

    /// The party that rejected the transfer, if applicable.
    ///
    /// Identifies the account (source or destination) that caused a rejection. Bots use this to diagnose transfer failures.
    pub reject_party: String,
}

// = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
//
//  ACCOUNT STRUCTS AND RESPONSES
//
// = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =

/// Response structure for wallet balance requests.
///
/// Returned by the `/v5/account/wallet-balance` endpoint, this struct provides the current wallet balance and margin details for an account. Bots use this to monitor account health, calculate available margin, and manage risk in perpetual futures trading.
#[derive(Deserialize, Serialize, Clone, Debug)]
#[serde(rename_all = "camelCase")]
pub struct WalletResponse {
    /// The return code indicating the success or failure of the request.
    ///
    /// A `0` indicates success. Non-zero codes require error handling for issues like invalid accounts. Bots should implement retry logic or parameter adjustments.
    pub ret_code: i32,

    /// A human-readable message describing the result or error.
    ///
    /// Provides context for the `ret_code`, such as `"OK"` or an error description. Bots should log this for debugging.
    pub ret_msg: String,

    /// The wallet balance data summary.
    ///
    /// Contains the actual balance and margin details for the account. Bots use this to calculate available capital and monitor margin ratios.
    pub result: WalletList,

    /// Additional information, typically an empty object.
    ///
    /// Usually an `Empty` struct and can be ignored unless verifying response structure.
    #[serde(rename = "retExtInfo")]
    pub ret_ext_info: Empty,

    /// The timestamp of the response in milliseconds.
    ///
    /// Indicates when the response was generated. Bots can use this to ensure data freshness and measure latency, critical for real-time account management.
    pub time: u64,
}

/// Summarizes wallet balance data for an account.
///
/// Part of the `WalletResponse`, this struct contains a list of wallet data entries for different account types or currencies. Bots use this to monitor overall account health and margin availability.
#[derive(Deserialize, Serialize, Clone, Debug)]
pub struct WalletList {
    /// A list of wallet data entries.
    ///
    /// Contains detailed balance and margin information for each account type or currency. Bots use this to calculate available margin and manage risk across assets.
    pub list: Vec<WalletData>,
}

/// Response structure for Unified Trading Account (UTA) status updates.
///
/// Returned by the `/v5/account/set-unified-margin` endpoint, this struct confirms the result of updating the UTA status (e.g., enabling or disabling unified margin). Bots use this to verify successful configuration and handle errors, ensuring proper account settings for perpetual futures trading.
#[derive(Deserialize, Serialize, Clone, Debug)]
#[serde(rename_all = "camelCase")]
pub struct UTAResponse {
    /// The return code indicating the success or failure of the request.
    ///
    /// A `0` indicates success. Non-zero codes require error handling for issues like invalid settings. Bots should implement retry logic or parameter adjustments.
    pub ret_code: i32,

    /// A human-readable message describing the result or error.
    ///
    /// Provides context for the `ret_code`, such as `"OK"` or an error description. Bots should log this for debugging.
    pub ret_msg: String,

    /// The UTA update status.
    ///
    /// Contains details of the unified margin status change, including any messages. Bots use this to confirm the new account configuration.
    pub result: UTAUpdateStatus,

    /// Additional information, typically an empty object.
    ///
    /// Usually an `Empty` struct and can be ignored unless verifying response structure.
    pub ret_ext_info: Empty,

    /// The timestamp of the response in milliseconds.
    ///
    /// Indicates when the response was generated. Bots can use this to ensure data freshness and measure latency.
    pub time: u64,
}

/// Details the result of a UTA status update.
///
/// Part of the `UTAResponse`, this struct provides the updated unified margin status and any associated messages. Bots use this to confirm the account’s margin configuration.
#[derive(Deserialize, Serialize, Clone, Debug)]
#[serde(rename_all = "camelCase")]
pub struct UTAUpdateStatus {
    /// The unified margin update status.
    ///
    /// Indicates the new status of the unified margin setting (e.g., "Enabled"). Bots should verify this matches the requested configuration.
    pub unified_update_status: String,

    /// Additional messages related to the update.
    ///
    /// Contains any warnings or informational messages about the status change. Bots should log these for auditing and debugging.
    pub unified_update_msg: UnifiedUpdateMsg,
}

/// Contains messages related to a UTA status update.
///
/// Part of the `UTAUpdateStatus`, this struct holds a list of messages providing context for the unified margin update. Bots use this to diagnose issues or confirm successful configuration.
#[derive(Deserialize, Serialize, Clone, Debug)]
pub struct UnifiedUpdateMsg {
    /// A list of update messages.
    ///
    /// Contains human-readable messages describing the update outcome or any warnings. Bots should log these for auditing and user feedback.
    pub msg: Vec<String>,
}

/// Parameters for requesting borrow history data.
///
/// Used to construct a request to the `/v5/account/borrow-history` endpoint to retrieve historical borrowing records for an account. Bots use this to audit borrowing activity, calculate interest costs, and manage leverage in perpetual futures trading.
#[derive(Clone, Debug, Default)]
pub struct BorrowHistoryRequest<'a> {
    /// The currency to filter borrow history (e.g., "USDT") (optional).
    ///
    /// Optionally filters borrowing records by currency. If unset, data for all currencies is returned. Bots should specify this to focus on specific margin types.
    pub coin: Option<Cow<'a, str>>,

    /// The start time for the borrow history (Unix timestamp in milliseconds) (optional).
    ///
    /// Defines the beginning of the time range. Bots should set this to focus on a specific historical period.
    pub start_time: Option<u64>,

    /// The end time for the borrow history (Unix timestamp in milliseconds) (optional).
    ///
    /// Defines the end of the time range. Bots should set this to limit data to a specific period, optimizing performance.
    pub end_time: Option<u64>,

    /// The maximum number of borrow records to return (optional).
    ///
    /// Controls the number of records returned as a string (e.g., "50"). Bots should set a reasonable limit to balance data completeness with performance.
    pub limit: Option<Cow<'a, str>>,
}

impl<'a> BorrowHistoryRequest<'a> {
    /// Constructs a new BorrowHistory request with specified parameters.
    ///
    /// Allows customization of the borrow history request. Bots should use this to specify the currency, time range, and limit to align with their analysis needs.
    pub fn new(
        coin: Option<&'a str>,
        start_time: Option<u64>,
        end_time: Option<u64>,
        limit: Option<&'a str>,
    ) -> Self {
        Self {
            coin: coin.map(Cow::Borrowed),
            start_time,
            end_time,
            limit: limit.map(Cow::Borrowed),
        }
    }

    /// Creates a default BorrowHistory request.
    ///
    /// Returns a request with all fields unset. Suitable for broad queries but should be customized for specific analysis needs.
    pub fn default() -> BorrowHistoryRequest<'a> {
        BorrowHistoryRequest::new(None, None, None, None)
    }
}

/// Response structure for borrow history requests.
///
/// Returned by the `/v5/account/borrow-history` endpoint, this struct provides historical borrowing data for an account. Bots use this to analyze borrowing costs and manage leverage effectively.
#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct BorrowHistoryResponse {
    /// The return code indicating the success or failure of the request.
    ///
    /// A `0` indicates success. Non-zero codes require error handling for issues like invalid parameters. Bots should implement retry logic or parameter adjustments.
    pub ret_code: i32,

    /// A human-readable message describing the result or error.
    ///
    /// Provides context for the `ret_code`, such as `"OK"` or an error description. Bots should log this for debugging.
    pub ret_msg: String,

    /// The borrow history data summary.
    ///
    /// Contains the actual borrowing records, including amounts and interest rates. Bots use this to calculate borrowing costs and optimize leverage.
    pub result: BorrowHistory,

    /// Additional information, typically an empty object.
    ///
    /// Usually an `Empty` struct and can be ignored unless verifying response structure.
    pub ret_ext_info: Empty,

    /// The timestamp of the response in milliseconds.
    ///
    /// Indicates when the response was generated. Bots can use this to ensure data freshness and align with other time-series data.
    pub time: u64,
}

/// Summarizes borrow history data for an account.
///
/// Part of the `BorrowHistoryResponse`, this struct organizes borrowing data by pagination cursor and a list of borrowing records. Bots use this to process borrowing activity and calculate interest costs.
#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct BorrowHistory {
    /// The cursor for pagination.
    ///
    /// Indicates the next page of results for large datasets. Bots should use this for paginated requests to fetch additional borrowing history.
    pub next_page_cursor: String,

    /// A list of borrowing records.
    ///
    /// Contains detailed borrowing data, such as amounts, interest rates, and timestamps. Bots use this to audit borrowing activity and manage leverage.
    pub rows: Vec<BorrowHistoryEntry>,
}

/// Represents a single borrowing record.
///
/// Details a specific borrowing event, including the amount borrowed and associated costs. Bots use this to calculate interest expenses and optimize leverage strategies.
#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct BorrowHistoryEntry {
    /// The amount borrowed.
    ///
    /// The quantity of the currency borrowed (e.g., USDT). Bots use this to track borrowing activity and calculate interest costs.
    #[serde(with = "string_to_float")]
    pub borrow_amount: f64,

    /// The cost exemption status.
    ///
    /// Indicates any exemptions applied to borrowing costs (e.g., promotional rates). Bots can use this to adjust cost calculations if applicable.
    pub cost_exemption: String,

    /// The free borrowed amount.
    ///
    /// The portion of the borrowed amount that is interest-free, if any. Bots use this to optimize borrowing strategies by prioritizing free borrowing.
    #[serde(with = "string_to_float")]
    pub free_borrowed_amount: f64,

    /// The timestamp when the borrowing occurred.
    ///
    /// Indicates when the borrowing event took place. Bots use this to align borrowing data with other time-series data.
    pub created_time: u64,

    /// The interest-bearing borrow size.
    ///
    /// The portion of the borrowed amount that incurs interest. Bots use this to calculate interest expenses accurately.
    #[serde(with = "string_to_float")]
    pub interest_bearing_borrow_size: f64,

    /// The currency of the borrowed amount (e.g., "USDT").
    ///
    /// Specifies the currency used for borrowing. Bots should verify this matches the expected currency for their margin type.
    pub currency: String,

    /// The unrealized loss from borrowing.
    ///
    /// Any unrealized losses associated with the borrowed funds, typically due to market movements. Bots use this to assess the impact of borrowing on account health.
    #[serde(with = "string_to_float")]
    pub unrealised_loss: f64,

    /// The hourly borrow rate.
    ///
    /// The interest rate applied to the borrowed amount per hour, as a decimal (e.g., 0.0001 for 0.01%). Bots use this to calculate borrowing costs over time.
    #[serde(with = "string_to_float")]
    pub hourly_borrow_rate: f64,

    /// The total borrow cost.
    ///
    /// The cumulative interest cost for the borrowed amount. Bots use this to track expenses and optimize leverage usage.
    #[serde(with = "string_to_float")]
    pub borrow_cost: f64,
}

/// Response structure for repaying borrowed liabilities.
///
/// Returned by the `/v5/account/repay-liability` endpoint, this struct confirms the result of repaying borrowed funds for an account. Bots use this to verify successful repayments and update account balance tracking.
#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct RepayLiabilityResponse {
    /// The return code indicating the success or failure of the request.
    ///
    /// A `0` indicates success. Non-zero codes require error handling for issues like insufficient funds. Bots should implement retry logic or parameter adjustments.
    pub ret_code: i32,

    /// A human-readable message describing the result or error.
    ///
    /// Provides context for the `ret_code`, such as `"OK"` or an error description. Bots should log this for debugging.
    pub ret_msg: String,

    /// The repayment details.
    ///
    /// Contains the amounts repaid for each currency. Bots use this to confirm repayment completion and update liability tracking.
    pub result: LiabilityQty,

    /// Additional information, typically an empty object.
    ///
    /// Usually an `Empty` struct and can be ignored unless verifying response structure.
    pub ret_ext_info: Empty,

    /// The timestamp of the response in milliseconds.
    ///
    /// Indicates when the response was generated. Bots can use this to ensure data freshness and measure latency.
    pub time: u64,
}

/// Summarizes repayment quantities for borrowed liabilities.
///
/// Part of the `RepayLiabilityResponse`, this struct contains a list of repayment details for each currency. Bots use this to confirm the amounts repaid and update account status.
#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct LiabilityQty {
    /// A list of repayment records.
    ///
    /// Contains details of the repaid amounts for each currency. Bots use this to verify repayment completion and update liability tracking.
    pub list: Vec<LiabilityQtyData>,
}

/// Represents a single repayment record for a currency.
///
/// Details the amount repaid for a specific currency. Bots use this to confirm repayment amounts and update account balance calculations.
#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct LiabilityQtyData {
    /// The currency of the repayment (e.g., "USDT").
    ///
    /// Specifies the currency used for the repayment. Bots should verify this matches the expected currency.
    pub coin: String,

    /// The quantity repaid.
    ///
    /// The amount of the currency repaid to reduce the borrowed liability. Bots use this to update liability tracking and account balances.
    #[serde(with = "string_to_float")]
    pub repayment_qty: f64,
}

/// Response structure for setting collateral coin status.
///
/// Returned by the `/v5/account/set-collateral-coin` endpoint, this struct confirms the result of enabling or disabling a coin as collateral for margin trading. Bots use this to verify successful configuration and handle errors, ensuring proper collateral management.
#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct SetCollateralCoinResponse {
    /// The return code indicating the success or failure of the request.
    ///
    /// A `0` indicates success. Non-zero codes require error handling for issues like invalid coins. Bots should implement retry logic or parameter adjustments.
    pub ret_code: i32,

    /// A human-readable message describing the result or error.
    ///
    /// Provides context for the `ret_code`, such as `"OK"` or an error description. Bots should log this for debugging.
    pub ret_msg: String,

    /// The result of the collateral coin setting (typically empty).
    ///
    /// Usually an `Empty` struct, as Bybit does not return additional data for this endpoint. Bots can ignore this unless verifying response structure.
    pub result: Empty,

    /// Additional information, typically an empty object.
    ///
    /// Usually an `Empty` struct and can be ignored unless verifying response structure.
    pub ret_ext_info: Empty,

    /// The timestamp of the response in milliseconds.
    ///
    /// Indicates when the response was generated. Bots can use this to ensure data freshness and measure latency.
    pub time: u64,
}

/// Response structure for batch setting collateral coin statuses.
///
/// Returned by the `/v5/account/batch-set-collateral-coin` endpoint, this struct confirms the result of enabling or disabling multiple coins as collateral. Bots use this to verify successful batch configuration and handle errors.
#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct BatchSetCollateralCoinResponse {
    /// The return code indicating the success or failure of the request.
    ///
    /// A `0` indicates success. Non-zero codes require error handling for issues like invalid coins. Bots should implement retry logic or parameter adjustments.
    pub ret_code: i32,

    /// A human-readable message describing the result or error.
    ///
    /// Provides context for the `ret_code`, such as `"OK"` or an error description. Bots should log this for debugging.
    pub ret_msg: String,

    /// The batch collateral coin setting results.
    ///
    /// Contains the status of each coin’s collateral setting. Bots use this to confirm which coins were successfully configured.
    pub result: SwitchList,

    /// Additional information, typically an empty object.
    ///
    /// Usually an `Empty` struct and can be ignored unless verifying response structure.
    pub ret_ext_info: Empty,

    /// The timestamp of the response in milliseconds.
    ///
    /// Indicates when the response was generated. Bots can use this to ensure data freshness and measure latency.
    pub time: u64,
}

/// Summarizes batch collateral coin setting results.
///
/// Part of the `BatchSetCollateralCoinResponse`, this struct contains a list of coins and their updated collateral statuses. Bots use this to confirm batch configuration outcomes.
#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct SwitchList {
    /// A list of collateral coin status updates.
    ///
    /// Contains details of each coin’s collateral setting (enabled or disabled). Bots use this to verify the new collateral configuration.
    pub list: Vec<SwitchListData>,
}

/// Represents a single collateral coin status update.
///
/// Details the collateral status for a specific coin in a batch setting request. Bots use this to confirm the outcome for each coin.
#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct SwitchListData {
    /// The currency of the coin (e.g., "USDT").
    ///
    /// Specifies the coin whose collateral status was updated. Bots should verify this matches the requested coin.
    pub coin: String,

    /// The collateral switch status (e.g., "ON", "OFF").
    ///
    /// Indicates whether the coin is enabled (`ON`) or disabled (`OFF`) as collateral. Bots use this to confirm the new collateral setting.
    pub collateral_switch: String,
}

/// Response structure for collateral information requests.
///
/// Returned by the `/v5/account/collateral-info` endpoint, this struct provides details about coins available as collateral for margin trading. Bots use this to assess collateral eligibility, borrowing limits, and margin requirements.
#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct CollateralInfoResponse {
    /// The return code indicating the success or failure of the request.
    ///
    /// A `0` indicates success. Non-zero codes require error handling for issues like invalid requests. Bots should implement retry logic or parameter adjustments.
    pub ret_code: i32,

    /// A human-readable message describing the result or error.
    ///
    /// Provides context for the `ret_code`, such as `"OK"` or an error description. Bots should log this for debugging.
    pub ret_msg: String,

    /// The collateral information summary.
    ///
    /// Contains details of coins available as collateral, including borrowing limits and rates. Bots use this to manage collateral and optimize margin usage.
    pub result: CollateralInfoList,

    /// Additional information, typically an empty object.
    ///
    /// Usually an `Empty` struct and can be ignored unless verifying response structure.
    pub ret_ext_info: Empty,

    /// The timestamp of the response in milliseconds.
    ///
    /// Indicates when the response was generated. Bots can use this to ensure data freshness and measure latency.
    pub time: u64,
}

/// Summarizes collateral information for an account.
///
/// Part of the `CollateralInfoResponse`, this struct contains a list of collateral details for each coin. Bots use this to assess collateral eligibility and borrowing capabilities.
#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct CollateralInfoList {
    /// A list of collateral information records.
    ///
    /// Contains detailed data for each coin, such as borrowing limits and collateral status. Bots use this to optimize collateral allocation and manage margin.
    pub list: Vec<CollateralInfo>,
}

/// Represents collateral information for a single coin.
///
/// Details the collateral eligibility, borrowing limits, and rates for a specific coin. Bots use this to determine which coins to use as collateral and manage borrowing costs.
#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct CollateralInfo {
    /// The amount available to borrow for the coin.
    ///
    /// The total borrowing capacity for the coin, in the coin’s units. Bots use this to assess borrowing potential for margin trading.
    pub available_to_borrow: String,

    /// The free borrowing amount available.
    ///
    /// The portion of the borrowing capacity that is interest-free, if any. Bots use this to optimize borrowing by prioritizing free borrowing.
    #[serde(with = "string_to_float")]
    pub free_borrowing_amount: f64,

    /// The free borrow amount limit.
    ///
    /// The maximum interest-free borrowing limit for the coin. Bots use this to plan borrowing strategies within free limits.
    #[serde(with = "string_to_float")]
    pub free_borrow_amount: f64,

    /// The maximum borrowing amount for the coin.
    ///
    /// The total borrowing limit for the coin, including interest-bearing amounts. Bots use this to ensure borrowing stays within account limits.
    #[serde(with = "string_to_float")]
    pub max_borrowing_amount: f64,

    /// The hourly borrow rate for the coin.
    ///
    /// The interest rate applied to borrowed amounts per hour, as a decimal (e.g., 0.0001 for 0.01%). Bots use this to calculate borrowing costs.
    #[serde(with = "string_to_float")]
    pub hourly_borrow_rate: f64,

    /// The borrow usage rate.
    ///
    /// The percentage of the borrowing limit currently utilized. Bots use this to monitor borrowing capacity and avoid over-leveraging.
    #[serde(with = "string_to_float")]
    pub borrow_usage_rate: f64,

    /// Whether the coin is enabled as collateral.
    ///
    /// `true` if the coin can be used as collateral for margin trading, `false` otherwise. Bots use this to select appropriate collateral assets.
    pub collateral_switch: bool,

    /// The current borrowed amount for the coin.
    ///
    /// The total amount of the coin currently borrowed. Bots use this to track liabilities and calculate interest costs.
    #[serde(with = "string_to_float")]
    pub borrow_amount: f64,

    /// Whether the coin is borrowable.
    ///
    /// `true` if the coin can be borrowed for margin trading, `false` otherwise. Bots use this to determine borrowing eligibility.
    pub borrowable: bool,

    /// The currency of the coin (e.g., "USDT").
    ///
    /// Specifies the coin type. Bots should verify this matches the expected currency for their margin type.
    pub currency: String,

    /// Whether the coin is used as margin collateral.
    ///
    /// `true` if the coin is actively used as collateral, `false` otherwise. Bots use this to confirm collateral allocation.
    pub margin_collateral: bool,

    /// The free borrowing limit as a string.
    ///
    /// The maximum interest-free borrowing limit for the coin, represented as a string. Bots can use this for precise borrowing calculations.
    pub free_borrowing_limit: String,

    /// The collateral ratio for the coin.
    ///
    /// The ratio at which the coin contributes to margin requirements (e.g., "0.9" for 90%). Bots use this to calculate effective collateral value.
    pub collateral_ratio: String,
}

/// Response structure for fee rate requests.
///
/// Returned by the `/v5/account/fee-rate` endpoint, this struct provides the maker and taker fee rates for trading pairs. Bots use this to calculate trading costs and optimize execution strategies in perpetual futures trading.
#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct FeeRateResponse {
    /// The return code indicating the success or failure of the request.
    ///
    /// A `0` indicates success. Non-zero codes require error handling for issues like invalid requests. Bots should implement retry logic or parameter adjustments.
    pub ret_code: i32,

    /// A human-readable message describing the result or error.
    ///
    /// Provides context for the `ret_code`, such as `"OK"` or an error description. Bots should log this for debugging.
    pub ret_msg: String,

    /// The fee rate data summary.
    ///
    /// Contains the maker and taker fee rates for each trading pair. Bots use this to calculate trading costs and prioritize maker orders for lower fees.
    pub result: FeeRateList,

    /// Additional information, typically an empty object.
    ///
    /// Usually an `Empty` struct and can be ignored unless verifying response structure.
    pub ret_ext_info: Empty,

    /// The timestamp of the response in milliseconds.
    ///
    /// Indicates when the response was generated. Bots can use this to ensure data freshness and measure latency.
    pub time: u64,
}

/// Summarizes fee rate data for trading pairs.
///
/// Part of the `FeeRateResponse`, this struct contains a list of fee rate records for each trading pair. Bots use this to optimize trading strategies based on fee structures.
#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct FeeRateList {
    /// A list of fee rate records.
    ///
    /// Contains maker and taker fee rates for each trading pair. Bots use this to calculate trading costs and optimize order placement.
    pub list: Vec<FeeRate>,
}

/// Represents the fee rates for a trading pair on Bybit.
///
/// This struct is used to store the maker and taker fee rates for a specific symbol, which are critical for calculating trading costs in perpetual futures trading. Fees impact the profitability of trading strategies, especially for high-frequency trading bots.
///
/// # Bybit API Reference
/// According to the Bybit API documentation (https://bybit-exchange.github.io/docs/v5/intro), fee rates are provided per symbol and differ between maker (adding liquidity) and taker (removing liquidity) orders. These rates are typically expressed as percentages (e.g., "0.0002" for 0.02%).
///
/// # Perpetual Futures Context
/// In perpetual futures, fees are charged on each trade and can significantly affect profitability, especially for strategies with thin margins. Maker fees are generally lower to incentivize liquidity provision, while taker fees are higher. Trading bots must account for these fees in cost calculations to optimize profit and loss (PnL).
#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct FeeRate {
    /// The trading pair symbol (e.g., "BTCUSDT").
    ///
    /// This identifies the specific market to which the fee rates apply. For trading bots, this field is essential for mapping fee structures to specific markets, ensuring accurate cost calculations per trade.
    pub symbol: String,

    /// The fee rate charged for maker orders (as a string, e.g., "0.0001" for 0.01%).
    ///
    /// Maker orders add liquidity to the order book by placing limit orders that are not immediately matched. Lower maker fees incentivize bots to provide liquidity, which can be a strategy for reducing trading costs. Bots should monitor this rate to optimize order placement strategies, especially in market-making algorithms.
    pub maker_fee_rate: String,

    /// The fee rate charged for taker orders (as a string, e.g., "0.0006" for 0.06%).
    ///
    /// Taker orders remove liquidity by matching existing orders (e.g., market orders). Higher taker fees mean bots executing immediate trades pay more, impacting profitability. Bots should compare maker vs. taker fees to decide whether to place limit or market orders based on strategy goals.
    pub taker_fee_rate: String,
}

/// Response structure for account information requests.
///
/// Returned by the `/v5/account/info` endpoint, this struct provides details about the account's margin mode, unified margin status, and other configuration settings. Bots use this to verify account settings, manage margin modes, and ensure compliance with trading strategies in perpetual futures trading.
#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct AccountInfoResponse {
    /// The return code indicating the success or failure of the request.
    ///
    /// A `0` indicates success. Non-zero codes require error handling for issues like invalid accounts. Bots should implement retry logic or parameter adjustments based on the error code.
    pub ret_code: i32,

    /// A human-readable message describing the result or error.
    ///
    /// Provides context for the `ret_code`, such as `"OK"` or an error description (e.g., `"Invalid account type"`). Bots should log this for debugging and user feedback.
    pub ret_msg: String,

    /// The account configuration details.
    ///
    /// Contains the account's margin mode, unified margin status, and other settings. Bots use this to confirm the account's setup aligns with their trading strategy, such as isolated or cross margin.
    pub result: AccountInfo,

    /// Additional information, typically an empty object.
    ///
    /// Usually an `Empty` struct and can be ignored unless verifying response structure for error handling.
    #[serde(default)]
    pub ret_ext_info: Empty,

    /// The timestamp of the response in milliseconds (optional).
    ///
    /// Indicates when the response was generated by Bybit’s server. Bots can use this to ensure data freshness and measure latency, critical for real-time account management.
    #[serde(default)]
    pub time: Option<u64>,
}

/// Details the account configuration and status.
///
/// Part of the `AccountInfoResponse`, this struct provides specific account settings, such as margin mode and unified margin status. Bots use this to verify account configuration and adjust trading strategies accordingly.
#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct AccountInfo {
    /// The margin mode of the account (e.g., "ISOLATED_MARGIN", "REGULAR_MARGIN").
    ///
    /// Indicates whether the account uses isolated margin (per-position margin) or cross margin (shared margin across positions). Bots use this to manage risk and margin allocation in perpetual futures trading.
    pub margin_mode: String,

    /// The timestamp of the last account update in milliseconds.
    ///
    /// Indicates when the account settings were last modified. Bots use this to track configuration changes and ensure data freshness.
    #[serde(with = "string_to_u64")]
    pub updated_time: u64,

    /// The unified margin status (e.g., 1 for enabled, 0 for disabled).
    ///
    /// Indicates whether the account uses Bybit’s Unified Trading Account (UTA) for cross-asset margin sharing. Bots use this to determine margin flexibility and optimize capital allocation.
    pub unified_margin_status: i8,

    /// The Discounted Commission Plan (DCP) status.
    ///
    /// Indicates whether the account is enrolled in a discounted fee plan. Bots can use this to calculate trading costs more accurately if special fee structures apply.
    pub dcp_status: String,

    /// The time window for certain account restrictions (in seconds).
    ///
    /// Specifies the duration of any temporary restrictions, such as withdrawal limits after enabling UTA. Bots should monitor this to comply with account constraints.
    pub time_window: i32,

    /// The Self-Managed Portfolio (SMP) group ID.
    ///
    /// Identifies the SMP group for the account, used for copy trading or portfolio management. Bots use this to manage group-specific trading rules and restrictions.
    pub smp_group: i8,

    /// Whether the account is a master trader.
    ///
    /// If `true`, the account is a master trader in Bybit’s copy trading system. Bots use this to enable or restrict copy trading features based on account role.
    pub is_master_trader: bool,

    /// The spot hedging status (e.g., "ENABLED", "DISABLED").
    ///
    /// Indicates whether spot hedging is enabled, allowing offsetting positions between spot and futures. Bots use this to implement hedging strategies across markets.
    pub spot_hedging_status: String,
}

/// Parameters for requesting transaction log data.
///
/// Used to construct a request to the `/v5/account/transaction-log` endpoint to retrieve historical transaction records, such as trades, fees, and funding. Bots use this to audit trading activity, calculate costs, and analyze performance in perpetual futures trading.
#[derive(Clone, Default)]
pub struct TransactionLogRequest<'a> {
    /// The account type to filter logs (e.g., "UNIFIED", "SPOT") (optional).
    ///
    /// Optionally filters transactions by account type. If unset, data for all account types is returned. Bots should specify this to focus on specific account activities.
    pub account_type: Option<Cow<'a, str>>,

    /// The product category (e.g., Linear, Inverse) (optional).
    ///
    /// Optionally filters transactions by instrument type. If unset, data for all categories is returned. Bots should specify this to analyze specific contract types.
    pub category: Option<Category>,

    /// The currency to filter logs (e.g., "USDT") (optional).
    ///
    /// Optionally filters transactions by settlement currency. If unset, data for all currencies is returned. Bots should specify this for targeted financial analysis.
    pub currency: Option<Cow<'a, str>>,

    /// The base coin to filter logs (e.g., "BTC") (optional).
    ///
    /// Optionally filters transactions by base asset. If unset, data for all base coins is returned. Bots should specify this to focus on specific trading pairs.
    pub base_coin: Option<Cow<'a, str>>,

    /// The transaction type to filter logs (e.g., "TRADE", "FUNDING") (optional).
    ///
    /// Optionally filters transactions by type, such as trades or funding fees. If unset, all transaction types are returned. Bots should specify this to analyze specific activities.
    pub log_type: Option<Cow<'a, str>>,

    /// The start time for the transaction log (Unix timestamp in milliseconds) (optional).
    ///
    /// Defines the beginning of the time range. Bots should set this to focus on a specific historical period, such as a trading session.
    pub start_time: Option<u64>,

    /// The end time for the transaction log (Unix timestamp in milliseconds) (optional).
    ///
    /// Defines the end of the time range. Bots should set this to limit data to a specific period, optimizing performance.
    pub end_time: Option<u64>,

    /// The maximum number of transaction records to return (optional).
    ///
    /// Controls the number of records returned (e.g., max 50). Bots should set a reasonable limit to balance data completeness with performance.
    pub limit: Option<u32>,
}

impl<'a> TransactionLogRequest<'a> {
    /// Constructs a new TransactionLog request with specified parameters.
    ///
    /// Allows customization of the transaction log request. Bots should use this to specify the exact filters and time range to align with their analysis needs.
    pub fn new(
        account_type: Option<&'a str>,
        category: Option<Category>,
        currency: Option<&'a str>,
        base_coin: Option<&'a str>,
        log_type: Option<&'a str>,
        start_time: Option<u64>,
        end_time: Option<u64>,
        limit: Option<u32>,
    ) -> Self {
        Self {
            account_type: account_type.map(Cow::Borrowed),
            category,
            currency: currency.map(Cow::Borrowed),
            base_coin: base_coin.map(Cow::Borrowed),
            log_type: log_type.map(Cow::Borrowed),
            start_time,
            end_time,
            limit,
        }
    }

    /// Creates a default TransactionLog request.
    ///
    /// Returns a request with all fields unset. Suitable for broad queries but should be customized for specific analysis needs in production.
    pub fn default() -> Self {
        Self::new(None, None, None, None, None, None, None, None)
    }
}

/// Represents a single transaction log entry.
///
/// Details a specific transaction, such as a trade, funding fee, or margin adjustment, including associated costs and quantities. Bots use this to audit trading activity and calculate net performance in perpetual futures trading.
#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct TransactionLogEntry {
    /// The unique identifier for the transaction.
    ///
    /// A unique ID assigned by Bybit to track the transaction. Bots use this to correlate transactions with other data, such as orders or executions.
    pub id: String,

    /// The trading pair symbol (e.g., "BTCUSDT").
    ///
    /// Identifies the perpetual futures contract or asset involved in the transaction. Bots use this to filter transactions by market.
    pub symbol: String,

    /// The trade side ("Buy" or "Sell").
    ///
    /// Indicates whether the transaction was a buy or sell action. Bots use this to track position direction and calculate net exposure.
    pub side: String,

    /// The funding fee (optional).
    ///
    /// The funding fee applied to the transaction, if applicable, in the settlement currency. Bots use this to calculate funding costs for perpetual futures positions.
    pub funding: Option<String>,

    /// The user-defined order link ID (optional).
    ///
    /// A custom identifier for the order, if set by the bot. Bots use this to track specific orders across transactions.
    pub order_link_id: Option<String>,

    /// The unique order ID.
    ///
    /// The Bybit-assigned ID for the order associated with the transaction. Bots use this to correlate transactions with specific orders.
    pub order_id: String,

    /// The transaction fee.
    ///
    /// The fee charged for the transaction, in the settlement currency. Bots use this to calculate trading costs and optimize fee-efficient strategies.
    #[serde(with = "string_to_float")]
    pub fee: f64,

    /// The balance change caused by the transaction.
    ///
    /// The net change in account balance due to the transaction, as a string (e.g., "+100.50" or "-50.25"). Bots use this to track account balance updates.
    pub change: String,

    /// The cash flow of the transaction.
    ///
    /// The net cash flow (positive or negative) resulting from the transaction, in the settlement currency. Bots use this to calculate liquidity impacts.
    #[serde(with = "string_to_float")]
    pub cash_flow: f64,

    /// The timestamp of the transaction.
    ///
    /// The time when the transaction occurred, as a string (e.g., "2025-05-19T13:07:00Z"). Bots use this to align transactions with market events.
    pub transaction_time: String,

    /// The type of transaction (e.g., "TRADE", "FUNDING").
    ///
    /// Specifies the nature of the transaction, such as trade execution or funding fee. Bots use this to categorize transactions for analysis.
    pub type_field: String,

    /// The fee rate applied to the transaction.
    ///
    /// The fee rate (e.g., "0.00075" for 0.075%) applied to the transaction. Bots use this to verify fee calculations and optimize trading costs.
    pub fee_rate: String,

    /// The bonus change, if any (optional).
    ///
    /// Any bonus or promotional balance changes applied to the transaction, in the settlement currency. Bots use this to account for special incentives.
    pub bonus_change: Option<String>,

    /// The position size affected by the transaction.
    ///
    /// The size of the position involved in the transaction, in base asset units. Bots use this to track position changes and calculate exposure.
    #[serde(with = "string_to_float")]
    pub size: f64,

    /// The quantity traded in the transaction.
    ///
    /// The amount of the base asset traded, in base asset units. Bots use this to verify trade execution details.
    #[serde(with = "string_to_float")]
    pub qty: f64,

    /// The resulting cash balance after the transaction.
    ///
    /// The account’s cash balance after the transaction, in the settlement currency. Bots use this to monitor available funds for trading.
    #[serde(with = "string_to_float")]
    pub cash_balance: f64,

    /// The currency of the transaction (e.g., "USDT").
    ///
    /// The settlement currency used for the transaction. Bots use this to ensure correct currency handling in multi-currency accounts.
    pub currency: String,

    /// The product category (e.g., "linear").
    ///
    /// The instrument type of the transaction, such as `linear` for USDT-margined perpetuals. Bots use this to filter transactions by contract type.
    pub category: String,

    /// The trade price.
    ///
    /// The price at which the trade was executed, as a string (e.g., "50000.00"). Bots use this to verify execution prices and calculate P&L.
    pub trade_price: String,

    /// The unique trade ID.
    ///
    /// A unique identifier for the trade execution associated with the transaction. Bots use this to track specific trade events.
    pub trade_id: String,
}

/// Summarizes transaction log data for an account.
///
/// Part of the `TransactionLogResponse`, this struct organizes transaction data by pagination cursor and a list of transaction records. Bots use this to process and audit trading activity.
#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct TransactionLogResult {
    /// The cursor for pagination.
    ///
    /// Indicates the next page of results for large datasets. Bots should use this for paginated requests to fetch additional transaction logs.
    pub next_page_cursor: String,

    /// A list of transaction log entries.
    ///
    /// Contains detailed transaction data, such as trades, fees, and funding. Bots use this to analyze trading activity and calculate performance metrics.
    pub list: Vec<TransactionLogEntry>,
}

/// Response structure for transaction log requests.
///
/// Returned by the `/v5/account/transaction-log` endpoint, this struct provides historical transaction data for an account. Bots use this to audit trades, calculate costs, and optimize strategies.
#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct TransactionLogResponse {
    /// The return code indicating the success or failure of the request.
    ///
    /// A `0` indicates success. Non-zero codes require error handling for issues like invalid parameters. Bots should implement retry logic or parameter adjustments.
    pub ret_code: i32,

    /// A human-readable message describing the result or error.
    ///
    /// Provides context for the `ret_code`, such as `"OK"` or an error description. Bots should log this for debugging.
    pub ret_msg: String,

    /// The transaction log data summary.
    ///
    /// Contains the actual transaction records, including trades and fees. Bots use this to analyze trading activity and performance.
    pub result: TransactionLogResult,

    /// Additional information, typically an empty object.
    ///
    /// Usually an `Empty` struct and can be ignored unless verifying response structure.
    pub ret_ext_info: Empty,

    /// The timestamp of the response in milliseconds.
    ///
    /// Indicates when the response was generated. Bots can use this to ensure data freshness and align with other time-series data.
    pub time: u64,
}

/// Response structure for Self-Managed Portfolio (SMP) group requests.
///
/// Returned by the `/v5/account/smp-group` endpoint, this struct confirms the SMP group configuration for the account. Bots use this to verify copy trading or portfolio management settings.
#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct SmpResponse {
    /// The return code indicating the success or failure of the request.
    ///
    /// A `0` indicates success. Non-zero codes require error handling for issues like invalid SMP groups. Bots should implement retry logic or parameter adjustments.
    pub ret_code: i32,

    /// A human-readable message describing the result or error.
    ///
    /// Provides context for the `ret_code`, such as `"OK"` or an error description. Bots should log this for debugging.
    pub ret_msg: String,

    /// The SMP group configuration.
    ///
    /// Contains the SMP group ID for the account. Bots use this to manage group-specific trading rules in copy trading systems.
    pub result: SmpResult,

    /// Additional information, typically an empty object.
    ///
    /// Usually an `Empty` struct and can be ignored unless verifying response structure.
    pub ret_ext_info: Empty,

    /// The timestamp of the response in milliseconds.
    ///
    /// Indicates when the response was generated. Bots can use this to ensure data freshness and measure latency.
    pub time: u64,
}

/// Details the SMP group configuration.
///
/// Part of the `SmpResponse`, this struct provides the SMP group ID for the account. Bots use this to confirm copy trading or portfolio management settings.
#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct SmpResult {
    /// The SMP group ID.
    ///
    /// Identifies the Self-Managed Portfolio group for the account, used for copy trading or portfolio management. Bots use this to apply group-specific rules.
    pub smp_group: u8,
}

/// Response structure for setting margin mode requests.
///
/// Returned by the `/v5/account/set-margin-mode` endpoint, this struct confirms the result of changing the account’s margin mode (e.g., isolated or cross). Bots use this to verify successful configuration and handle errors.
#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct SetMarginModeResponse {
    /// The return code indicating the success or failure of the request.
    ///
    /// A `0` indicates success. Non-zero codes require error handling for issues like invalid margin modes. Bots should implement retry logic or parameter adjustments.
    pub ret_code: i32,

    /// A human-readable message describing the result or error.
    ///
    /// Provides context for the `ret_code`, such as `"OK"` or an error description. Bots should log this for debugging.
    pub ret_msg: String,

    /// The margin mode change result.
    ///
    /// Contains reasons for success or failure of the margin mode change. Bots use this to diagnose issues and confirm the new margin mode.
    pub result: MarginModeResult,

    /// Additional information, typically an empty object.
    ///
    /// Usually an `Empty` struct and can be ignored unless verifying response structure.
    pub ret_ext_info: Empty,

    /// The timestamp of the response in milliseconds.
    ///
    /// Indicates when the response was generated. Bots can use this to ensure data freshness and measure latency.
    pub time: u64,
}

/// Details the result of a margin mode change.
///
/// Part of the `SetMarginModeResponse`, this struct provides reasons for the success or failure of the margin mode change. Bots use this to diagnose configuration issues.
#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct MarginModeResult {
    /// A list of reasons for the margin mode change outcome.
    ///
    /// Contains detailed explanations for success or failure, such as restrictions due to open positions. Bots use this to handle errors and adjust settings.
    pub reason: Vec<ReasonObject>,
}

/// Represents a single reason for a margin mode change outcome.
///
/// Part of the `MarginModeResult`, this struct details a specific reason for the success or failure of the margin mode change. Bots use this for error handling and debugging.
#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct ReasonObject {
    /// The reason code for the outcome.
    ///
    /// A code indicating the specific reason for success or failure (e.g., "10001" for invalid settings). Bots use this to implement targeted error handling.
    pub reason_code: String,

    /// A human-readable message describing the reason.
    ///
    /// Provides context for the `reason_code`, such as `"Cannot change mode with open positions"`. Bots should log this for debugging and user feedback.
    pub reason_msg: String,
}

/// Response structure for spot hedging status requests.
///
/// Returned by the `/v5/account/set-spot-hedging` endpoint, this struct confirms the result of enabling or disabling spot hedging. Bots use this to verify successful configuration and handle errors for hedging strategies.
#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct SpotHedgingResponse {
    /// The return code indicating the success or failure of the request.
    ///
    /// A `0` indicates success. Non-zero codes require error handling for issues like invalid settings. Bots should implement retry logic or parameter adjustments.
    pub ret_code: i32,

    /// A human-readable message describing the result or error.
    ///
    /// Provides context for the `ret_code`, such as `"OK"` or an error description. Bots should log this for debugging.
    pub ret_msg: String,
}

// = = = = = = = = = = = = ==  = == = =  =  = = = = ==
// HEADER STRUCT FOR TRADESTREM RESPONSE
// = = = = = = = = = = = = ==  = == = =  =  = = = = ==

/// Header structure for trade stream responses.
///
/// Contains metadata for trade stream API responses, including rate limit information and timestamps. Bots use this to monitor API usage, ensure compliance with rate limits, and track response timing in real-time trading.
#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct Header {
    /// The API rate limit for the endpoint.
    ///
    /// Specifies the total number of requests allowed within the rate limit window. Bots use this to manage API request pacing and avoid rate limit errors.
    #[serde(rename = "X-Bapi-Limit")]
    pub x_bapi_limit: String,

    /// The current rate limit status.
    ///
    /// Indicates the number of remaining requests within the rate limit window. Bots use this to dynamically adjust request frequency to stay within limits.
    #[serde(rename = "X-Bapi-Limit-Status")]
    pub x_bapi_limit_status: String,

    /// The timestamp when the rate limit window resets.
    ///
    /// Specifies when the rate limit counter will reset, as a string (e.g., "1625097600000"). Bots use this to schedule requests around reset times.
    #[serde(rename = "X-Bapi-Limit-Reset-Timestamp")]
    pub x_bapi_limit_reset_timestamp: String,

    /// The unique trace ID for the request.
    ///
    /// A unique identifier for tracking the request through Bybit’s system. Bots use this for debugging and correlating requests with responses.
    #[serde(rename = "Traceid")]
    pub traceid: String,

    /// The current server timestamp.
    ///
    /// The server’s current time, as a string (e.g., "1625097599123"). Bots use this to measure latency and ensure response freshness in real-time trading.
    #[serde(rename = "Timenow")]
    pub timenow: String,
}

// = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
//
// WEBSOCKET STRUCTS AND RESPONSES
//
// = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =

/// Parameters for WebSocket subscription requests.
///
/// Used to construct a WebSocket subscription request to subscribe to real-time data streams, such as order book updates or trade events. Bots use this to configure WebSocket feeds for market monitoring and trading signals in perpetual futures trading.
#[derive(Clone, Debug, Default)]
pub struct Subscription<'a> {
    /// The operation type (e.g., "subscribe").
    ///
    /// Specifies the WebSocket operation, typically `"subscribe"` for subscribing to data streams. Bots must set this correctly to initiate subscriptions.
    pub op: &'a str,

    /// A list of subscription arguments.
    ///
    /// Specifies the data streams to subscribe to, such as `"orderbook.50.BTCUSDT"` or `"trade.BTCUSDT"`. Bots should provide valid topics to receive relevant market data.
    pub args: Vec<&'a str>,
}

impl<'a> Subscription<'a> {
    /// Constructs a new Subscription with specified parameters.
    ///
    /// Allows customization of the WebSocket subscription. Bots should use this to specify the operation and subscription arguments for their data needs.
    pub fn new(op: &'a str, args: Vec<&'a str>) -> Self {
        Self { op, args }
    }

    /// Creates a default Subscription.
    ///
    /// Returns a subscription with `op` set to `"subscribe"` and an empty argument list. Suitable for testing but should be customized with valid topics for production.
    pub fn default() -> Subscription<'a> {
        Subscription::new("subscribe", vec![])
    }
}

/// Enum representing various WebSocket event types.
///
/// Encapsulates different types of WebSocket events, such as order book updates, trades, and position changes, received from Bybit’s WebSocket API. Bots use this to handle real-time market and account data for trading strategies.
#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(untagged)]
pub enum WebsocketEvents {
    /// An order book update event.
    ///
    /// Contains real-time updates to the order book for a trading pair. Bots use this for market depth analysis and liquidity monitoring.
    OrderBookEvent(OrderBookUpdate),

    /// A trade event.
    ///
    /// Contains details of executed trades in the market. Bots use this for price discovery and trade signal generation.
    TradeEvent(TradeUpdate),

    /// A ticker event.
    ///
    /// Contains real-time ticker data, such as last price and volume. Bots use this for monitoring market conditions and technical analysis.
    TickerEvent(WsTicker),

    /// A liquidation event.
    ///
    /// Contains details of liquidation events in the market. Bots use this to assess market risk and volatility.
    LiquidationEvent(Liquidation),

    /// A kline (candlestick) event.
    ///
    /// Contains real-time candlestick data for a trading pair. Bots use this for technical analysis and trend detection.
    KlineEvent(WsKline),

    /// A position update event.
    ///
    /// Contains updates to the account’s positions. Bots use this to track position changes and manage risk in real time.
    PositionEvent(PositionEvent),

    /// An execution event.
    ///
    /// Contains details of order executions for the account. Bots use this to confirm trade executions and update order status.
    ExecutionEvent(Execution),

    /// An order update event.
    ///
    /// Contains updates to the account’s orders. Bots use this to monitor order status and implement dynamic order management.
    OrderEvent(OrderEvent),

    /// A wallet update event.
    ///
    /// Contains updates to the account’s wallet balance and margin. Bots use this to monitor account health and manage capital.
    Wallet(WalletEvent),

    /// A trade stream event.
    ///
    /// Contains real-time trade stream data, typically for high-frequency trading. Bots use this for low-latency trade monitoring.
    TradeStream(TradeStreamEvent),

    /// A fast execution event.
    ///
    /// Contains minimal execution data for low-latency processing. Bots use this for high-frequency trading and rapid execution confirmation.
    FastExecEvent(FastExecution),
}

/// Enum representing ticker data for different market types.
///
/// Encapsulates ticker data for linear perpetuals or spot markets, allowing bots to process market-specific metrics like funding rates or USD index prices. Bots use this to handle ticker updates in a type-safe manner.
#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(untagged)]
pub enum Tickers {
    /// Ticker data for linear perpetual futures.
    ///
    /// Contains metrics like funding rate and open interest for USDT-margined contracts. Bots use this for perpetual futures trading strategies.
    Linear(LinearTickerData),

    /// Ticker data for spot markets.
    ///
    /// Contains metrics like 24-hour volume and USD index price for spot trading pairs. Bots use this for spot market analysis.
    Spot(SpotTickerData),
}

/// Enum representing WebSocket pong responses.
///
/// Encapsulates pong responses for public and private WebSocket connections, used to confirm connection health. Bots use this to verify WebSocket connectivity and handle reconnection logic.
#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(untagged)]
pub enum PongResponse {
    /// A pong response for public WebSocket connections.
    ///
    /// Confirms the health of a public WebSocket connection. Bots use this to ensure market data feeds are active.
    PublicPong(PongData),

    /// A pong response for private WebSocket connections.
    ///
    /// Confirms the health of a private WebSocket connection for account data. Bots use this to ensure account feeds are active.
    PrivatePong(PongData),
}

/// Data structure for WebSocket pong responses.
///
/// Contains details of a pong response, including connection status and request metadata. Bots use this to confirm WebSocket connection health and manage reconnection logic.
#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct PongData {
    /// The return code for the pong response (optional).
    ///
    /// Indicates the status of the pong response (e.g., `0` for success). Bots should check this to verify connection health.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ret_code: Option<i32>,

    /// Whether the pong response was successful (optional).
    ///
    /// If `true`, the WebSocket connection is healthy. Bots use this to confirm successful ping-pong cycles.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub success: Option<bool>,

    /// A message describing the pong response.
    ///
    /// Typically `"pong"` or an error message. Bots should log this for debugging connection issues.
    pub ret_msg: String,

    /// The WebSocket connection ID.
    ///
    /// A unique identifier for the WebSocket connection. Bots use this to track specific connections in multi-connection setups.
    pub conn_id: String,

    /// The request ID for the ping (optional).
    ///
    /// The ID of the ping request that triggered this pong. Bots use this to correlate ping-pong pairs.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub req_id: Option<String>,

    /// Additional arguments for the pong response (optional).
    ///
    /// Contains any additional data included in the pong, typically empty. Bots can ignore this unless handling custom WebSocket protocols.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub args: Option<Vec<String>>,

    /// Additional data for the pong response (optional).
    ///
    /// Contains any extra data included in the pong, typically empty. Bots can ignore this unless handling custom WebSocket protocols.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub data: Option<Vec<String>>,

    /// The operation type (e.g., "pong").
    ///
    /// Specifies the WebSocket operation, typically `"pong"`. Bots use this to confirm the response type.
    pub op: String,
}

unsafe impl Send for PongData {}
unsafe impl Sync for PongData {}

/// Structure for trade stream events received via WebSocket.
///
/// Contains real-time trade stream data, including order status updates and API rate limit metadata. Bots use this for high-frequency trading and low-latency order monitoring in perpetual futures markets.
#[derive(Serialize, Deserialize, Debug, Clone)]
#[serde(rename_all = "camelCase")]
pub struct TradeStreamEvent {
    /// The request ID for the trade stream event (optional).
    ///
    /// A unique identifier for the request that triggered this event, if applicable. Bots use this to correlate events with specific requests.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub req_id: Option<String>,

    /// The return code for the event.
    ///
    /// Indicates the status of the event (e.g., `0` for success). Bots should check this to handle errors or confirm successful updates.
    pub ret_code: i32,

    /// A message describing the event.
    ///
    /// Provides context for the `ret_code`, such as `"OK"` or an error description. Bots should log this for debugging.
    pub ret_msg: String,

    /// The operation type (e.g., "trade").
    ///
    /// Specifies the type of trade stream event, typically `"trade"`. Bots use this to confirm the event type.
    pub op: String,

    /// The order status data for the event.
    ///
    /// Contains detailed order status updates, such as filled or cancelled orders. Bots use this to track order progress in real time.
    pub data: OrderStatus,

    /// The API response header.
    ///
    /// Contains rate limit and timing metadata for the API response. Bots use this to manage API usage and ensure compliance with rate limits.
    pub header: Header,

    /// The WebSocket connection ID.
    ///
    /// A unique identifier for the WebSocket connection. Bots use this to track specific connections in multi-connection setups.
    pub conn_id: String,
}

unsafe impl Send for TradeStreamEvent {}
unsafe impl Sync for TradeStreamEvent {}

/// Structure for WebSocket order book update events.
///
/// Contains real-time updates to the order book for a trading pair, including bids, asks, and sequence numbers. Bots use this for market depth analysis and liquidity monitoring in perpetual futures trading.
#[derive(Serialize, Deserialize, Debug, Clone)]
#[serde(rename_all = "camelCase")]
pub struct OrderBookUpdate {
    /// The WebSocket topic for the event (e.g., "orderbook.50.BTCUSDT").
    ///
    /// Specifies the data stream for the order book update, including depth and symbol. Bots use this to verify the correct market and depth level.
    #[serde(rename = "topic")]
    pub topic: String,

    /// The event type (e.g., "snapshot", "delta").
    ///
    /// Indicates whether the update is a full snapshot or incremental delta. Bots use this to initialize or update their order book state.
    #[serde(rename = "type")]
    pub event_type: String,

    /// The timestamp of the event in milliseconds.
    ///
    /// Indicates when the order book update was generated. Bots use this to ensure data freshness and align with other market data.
    #[serde(rename = "ts")]
    pub timestamp: u64,

    /// The order book data.
    ///
    /// Contains the bids, asks, and sequence numbers for the order book. Bots use this to update their internal order book representation.
    pub data: WsOrderBook,

    /// The creation timestamp in milliseconds.
    ///
    /// Indicates when the order book update was created by Bybit’s server. Bots use this to measure latency and ensure data consistency.
    pub cts: u64,
}

unsafe impl Send for OrderBookUpdate {}
unsafe impl Sync for OrderBookUpdate {}

/// Structure for WebSocket order book data.
///
/// Contains the bids, asks, and sequence numbers for a trading pair’s order book. Bots use this to maintain an up-to-date view of market depth and liquidity.
#[derive(Serialize, Deserialize, Debug, Clone)]
#[serde(rename_all = "camelCase")]
pub struct WsOrderBook {
    /// The trading pair symbol (e.g., "BTCUSDT").
    ///
    /// Identifies the perpetual futures contract for the order book. Bots use this to verify the correct market.
    #[serde(rename = "s")]
    pub symbol: String,

    /// A list of ask prices and quantities.
    ///
    /// Contains the current ask levels in the order book, sorted by price. Bots use this to assess selling pressure and liquidity on the ask side.
    #[serde(rename = "a")]
    pub asks: Vec<Ask>,

    /// A list of bid prices and quantities.
    ///
    /// Contains the current bid levels in the order book, sorted by price. Bots use this to assess buying pressure and liquidity on the bid side.
    #[serde(rename = "b")]
    pub bids: Vec<Bid>,

    /// The update ID for the order book.
    ///
    /// A unique identifier for the order book update. Bots use this to ensure updates are processed in the correct order.
    #[serde(rename = "u")]
    pub update_id: u64,

    /// The sequence number for the update.
    ///
    /// A monotonically increasing number for ordering updates. Bots use this to detect missing or out-of-order updates and maintain order book consistency.
    pub seq: u64,
}

unsafe impl Send for WsOrderBook {}
unsafe impl Sync for WsOrderBook {}

/// Structure for WebSocket trade update events.
///
/// Contains real-time updates on executed trades for a trading pair. Bots use this for price discovery, trade signal generation, and market momentum analysis in perpetual futures trading.
#[derive(Serialize, Deserialize, Debug, Clone)]
#[serde(rename_all = "camelCase")]
pub struct TradeUpdate {
    /// The WebSocket topic for the event (e.g., "trade.BTCUSDT").
    ///
    /// Specifies the data stream for the trade update. Bots use this to verify the correct market.
    pub topic: String,

    /// The event type (e.g., "snapshot").
    ///
    /// Indicates the type of trade update, typically a snapshot of recent trades. Bots use this to process trade data appropriately.
    #[serde(rename = "type")]
    pub event_type: String,

    /// The timestamp of the event in milliseconds.
    ///
    /// Indicates when the trade update was generated. Bots use this to ensure data freshness and align with other market data.
    #[serde(rename = "ts")]
    pub timestamp: u64,

    /// A list of trade details.
    ///
    /// Contains the executed trades, including price, volume, and side. Bots use this to analyze market activity and generate trading signals.
    pub data: Vec<WsTrade>,
}

unsafe impl Send for TradeUpdate {}
unsafe impl Sync for TradeUpdate {}

/// Structure for individual trade data in WebSocket trade updates.
///
/// Contains details of a single executed trade, such as price, volume, and side. Bots use this to monitor market activity and inform trading decisions.
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct WsTrade {
    /// The timestamp of the trade in milliseconds.
    ///
    /// Indicates when the trade was executed. Bots use this to align trade data with other time-series data.
    #[serde(rename = "T")]
    pub timestamp: u64,

    /// The trading pair symbol (e.g., "BTCUSDT").
    ///
    /// Identifies the perpetual futures contract for the trade. Bots use this to verify the correct market.
    #[serde(rename = "s")]
    pub symbol: String,

    /// The trade side ("Buy" or "Sell").
    ///
    /// Indicates whether the trade was initiated by a buyer or seller. Bots use this to assess market direction and momentum.
    #[serde(rename = "S")]
    pub side: String,

    /// The trade volume.
    ///
    /// The quantity of the base asset traded. Bots use this to gauge trade size and market liquidity.
    #[serde(rename = "v", with = "string_to_float")]
    pub volume: f64,

    /// The trade price.
    ///
    /// The price at which the trade was executed. Bots use this for price discovery and technical analysis.
    #[serde(rename = "p", with = "string_to_float")]
    pub price: f64,

    /// The tick direction of the trade.
    ///
    /// Indicates whether the trade was an uptick, downtick, or neutral (e.g., "PlusTick", "MinusTick"). Bots use this to analyze short-term price momentum.
    #[serde(rename = "L")]
    pub tick_direction: String,

    /// The unique trade ID.
    ///
    /// A unique identifier for the trade execution. Bots use this to track specific trades and avoid duplicates.
    #[serde(rename = "i")]
    pub id: String,

    /// Whether the buyer was the maker.
    ///
    /// If `true`, the buyer’s order was on the order book (maker); if `false`, the buyer took liquidity (taker). Bots use this to analyze market dynamics and order flow.
    #[serde(rename = "BT")]
    pub buyer_is_maker: bool,
}

unsafe impl Send for WsTrade {}
unsafe impl Sync for WsTrade {}

/// Structure for WebSocket ticker update events.
///
/// Contains real-time ticker data for a trading pair, such as last price, volume, and funding rates. Bots use this for market monitoring and technical analysis in perpetual futures trading.
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct WsTicker {
    /// The WebSocket topic for the event (e.g., "tickers.BTCUSDT").
    ///
    /// Specifies the data stream for the ticker update. Bots use this to verify the correct market.
    pub topic: String,

    /// The event type (e.g., "snapshot").
    ///
    /// Indicates the type of ticker update, typically a snapshot of current market data. Bots use this to process ticker data appropriately.
    #[serde(rename = "type")]
    pub event_type: String,

    /// The ticker data.
    ///
    /// Contains market-specific ticker metrics, such as last price and open interest. Bots use this to monitor market conditions and generate trading signals.
    pub data: Tickers,

    /// The checksum for the ticker data.
    ///
    /// A sequence number or checksum to verify data integrity. Bots use this to ensure the ticker data is consistent and not corrupted.
    pub cs: u64,

    /// The timestamp of the event in milliseconds.
    ///
    /// Indicates when the ticker update was generated. Bots use this to ensure data freshness and align with other market data.
    pub ts: u64,
}

unsafe impl Send for WsTicker {}
unsafe impl Sync for WsTicker {}

/// Structure for linear perpetual futures ticker data.
///
/// Contains ticker metrics specific to linear perpetual futures, such as funding rates and open interest. Bots use this for real-time market analysis and risk management in USDT-margined contracts.
#[derive(Serialize, Deserialize, Debug, Clone)]
#[serde(rename_all = "camelCase")]
pub struct LinearTickerData {
    /// The trading pair symbol (e.g., "BTCUSDT").
    ///
    /// Identifies the perpetual futures contract for the ticker data. Bots use this to verify the correct market.
    pub symbol: String,

    /// The tick direction of the last price change.
    ///
    /// Indicates whether the last price change was an uptick or downtick (e.g., "PlusTick"). Bots use this to analyze short-term price momentum.
    #[serde(rename = "tickDirection")]
    pub tick_direction: String,

    /// The 24-hour price change percentage.
    ///
    /// The percentage change in price over the last 24 hours. Bots use this to assess market trends and volatility.
    #[serde(rename = "price24hPcnt", with = "string_to_float")]
    pub price_24h_pcnt: f64,

    /// The last traded price.
    ///
    /// The most recent price at which the contract was traded. Bots use this for real-time price tracking and technical analysis.
    #[serde(with = "string_to_float")]
    pub last_price: f64,

    /// The price 24 hours ago.
    ///
    /// The price of the contract 24 hours prior. Bots use this to calculate price changes and validate `price_24h_pcnt`.
    #[serde(rename = "prevPrice24h", with = "string_to_float")]
    pub prev_price_24h: f64,

    /// The highest price in the last 24 hours.
    ///
    /// The peak price reached in the last 24 hours. Bots use this to identify resistance levels and assess volatility.
    #[serde(rename = "highPrice24h", with = "string_to_float")]
    pub high_price_24h: f64,

    /// The lowest price in the last 24 hours.
    ///
    /// The lowest price reached in the last 24 hours. Bots use this to identify support levels and assess volatility.
    #[serde(rename = "lowPrice24h", with = "string_to_float")]
    pub low_price_24h: f64,

    /// The price 1 hour ago.
    ///
    /// The price of the contract 1 hour prior. Bots use this to calculate short-term price changes and momentum.
    #[serde(rename = "prevPrice1h", with = "string_to_float")]
    pub prev_price_1h: f64,

    /// The current mark price.
    ///
    /// The mark price used for P&L calculations in perpetual futures. Bots use this to calculate unrealized P&L and assess position health.
    #[serde(with = "string_to_float")]
    pub mark_price: f64,

    /// The current index price.
    ///
    /// The index price, based on external spot markets, used for reference in perpetual futures. Bots use this to compare with mark price for funding rate calculations.
    #[serde(with = "string_to_float")]
    pub index_price: f64,

    /// The open interest in contracts.
    ///
    /// The total number of open contracts in the market. Bots use this to gauge market participation and liquidity.
    #[serde(with = "string_to_float")]
    pub open_interest: f64,

    /// The open interest value in settlement currency.
    ///
    /// The monetary value of open interest (`open_interest` * `mark_price`). Bots use this to assess market exposure and leverage levels.
    #[serde(with = "string_to_float")]
    pub open_interest_value: f64,

    /// The 24-hour trading turnover.
    ///
    /// The total trading value in the last 24 hours, in settlement currency. Bots use this to assess market activity and liquidity.
    #[serde(rename = "turnover24h", with = "string_to_float")]
    pub turnover_24h: f64,

    /// The 24-hour trading volume.
    ///
    /// The total quantity of contracts traded in the last 24 hours. Bots use this to analyze market activity and trading intensity.
    #[serde(rename = "volume24h", with = "string_to_float")]
    pub volume_24h: f64,

    /// The timestamp of the next funding event in milliseconds.
    ///
    /// Indicates when the next funding rate payment will occur. Bots use this to schedule funding fee calculations and position adjustments.
    #[serde(with = "string_to_u64")]
    pub next_funding_time: u64,

    /// The current funding rate.
    ///
    /// The funding rate applied to positions, as a decimal (e.g., 0.0001 for 0.01%). Bots use this to calculate funding costs or profits for long/short positions.
    #[serde(with = "string_to_float")]
    pub funding_rate: f64,

    /// The best bid price.
    ///
    /// The highest price at which someone is willing to buy. Bots use this to assess buy-side liquidity and calculate spreads.
    #[serde(rename = "bid1Price", with = "string_to_float")]
    pub bid_price: f64,

    /// The best bid size.
    ///
    /// The quantity available at the best bid price. Bots use this to evaluate buy-side liquidity and potential slippage.
    #[serde(rename = "bid1Size", with = "string_to_float")]
    pub bid_size: f64,

    /// The best ask price.
    ///
    /// The lowest price at which someone is willing to sell. Bots use this to assess sell-side liquidity and calculate spreads.
    #[serde(rename = "ask1Price", with = "string_to_float")]
    pub ask_price: f64,

    /// The best ask size.
    ///
    /// The quantity available at the best ask price. Bots use this to evaluate sell-side liquidity and potential slippage.
    #[serde(rename = "ask1Size", with = "string_to_float")]
    pub ask_size: f64,
}

unsafe impl Send for LinearTickerData {}
unsafe impl Sync for LinearTickerData {}

/// Represents spot market ticker data for a trading pair on Bybit.
///
/// This struct provides real-time market data for spot trading pairs, including price, volume, and 24-hour statistics. While the file focuses on perpetual futures, this struct is included for spot market data, which can be relevant for bots hedging or arbitraging between spot and futures markets.
///
/// # Bybit API Reference
/// The Bybit API (https://bybit-exchange.github.io/docs/v5/market/ticker) provides ticker data for spot markets, including last price, 24-hour high/low, and volume. Fields are serialized as strings but deserialized to `f64` for numerical computations.
///
/// # Perpetual Futures Context
/// Spot ticker data can be used in conjunction with perpetual futures to identify arbitrage opportunities (e.g., cash-and-carry trades) or to monitor funding rates, as spot prices often serve as a reference for futures pricing.
#[derive(Serialize, Deserialize, Debug, Clone)]
#[serde(rename_all = "camelCase")]
pub struct SpotTickerData {
    /// The trading pair symbol (e.g., "BTCUSDT").
    ///
    /// Identifies the market for which the ticker data applies. Bots use this to filter and process data for specific trading pairs.
    pub symbol: String,

    /// The most recent trade price.
    ///
    /// This is the price of the last executed trade in the spot market. For bots, this is critical for tracking market trends and triggering trades based on price thresholds.
    #[serde(with = "string_to_float")]
    pub last_price: f64,

    /// The highest price in the last 24 hours.
    ///
    /// Useful for identifying price volatility and setting upper bounds for trading strategies. Bots can use this to detect breakout patterns or avoid trading during extreme volatility.
    #[serde(with = "string_to_float")]
    pub high_price_24h: f64,

    /// The lowest price in the last 24 hours.
    ///
    /// Helps bots assess support levels and market ranges. Combined with `high_price_24h`, it provides a 24-hour price range for volatility-based strategies.
    #[serde(with = "string_to_float")]
    pub low_price_24h: f64,

    /// The price 24 hours ago.
    ///
    /// Used to calculate price changes over the last 24 hours. Bots can use this to compute momentum or mean-reversion signals.
    #[serde(with = "string_to_float")]
    pub prev_price_24h: f64,

    /// The trading volume in the last 24 hours (in base currency).
    ///
    /// Indicates market activity and liquidity. High volume suggests strong participation, which bots can use to prioritize liquid markets for lower slippage.
    #[serde(with = "string_to_float")]
    pub volume_24h: f64,

    /// The turnover (value of trades) in the last 24 hours (in quote currency).
    ///
    /// Represents the total monetary value of trades. Bots can use this to gauge market interest and correlate with volume for liquidity analysis.
    #[serde(with = "string_to_float")]
    pub turnover_24h: f64,

    /// The percentage price change over the last 24 hours.
    ///
    /// A key metric for momentum trading strategies. Bots can use this to identify trending markets or trigger mean-reversion trades based on overbought/oversold conditions.
    #[serde(with = "string_to_float")]
    pub price_24h_pcnt: f64,

    /// The USD index price for the asset.
    ///
    /// Represents the fair value of the asset based on Bybit's index calculation. For bots, this is critical for pricing perpetual futures, as it influences funding rates and mark prices.
    #[serde(with = "string_to_float")]
    pub usd_index_price: f64,
}

unsafe impl Send for SpotTickerData {}
unsafe impl Sync for SpotTickerData {}

/// Represents a liquidation event in Bybit's perpetual futures market.
///
/// Liquidation occurs when a trader's position cannot meet margin requirements, leading to forced closure. This struct is used in WebSocket streams to notify bots of liquidation events, which can signal market stress or volatility.
///
/// # Bybit API Reference
/// The Bybit API (https://bybit-exchange.github.io/docs/v5/websocket/public/liquidation) provides liquidation data via WebSocket, including symbol, side, size, and price.
///
/// # Perpetual Futures Context
/// In perpetual futures, liquidations happen when a trader's margin balance falls below the maintenance margin due to adverse price movements. Liquidation events can cause price cascades, especially in highly leveraged markets, making them critical for bots to monitor.
#[derive(Serialize, Deserialize, Debug, Clone)]
#[serde(rename_all = "camelCase")]
pub struct Liquidation {
    /// The WebSocket topic (e.g., "liquidation.BTCUSDT").
    ///
    /// Identifies the data stream and symbol for the liquidation event. Bots use this to filter relevant liquidation messages.
    #[serde(rename = "topic")]
    pub topic: String,

    /// The type of WebSocket event (e.g., "snapshot" or "delta").
    ///
    /// Indicates whether the data is a full snapshot or incremental update. Bots must handle both types to maintain an accurate state.
    #[serde(rename = "type")]
    pub event_type: String,

    /// The timestamp of the event (in milliseconds).
    ///
    /// Represents when the liquidation occurred. Bots use this for time-based analysis, such as correlating liquidations with price movements.
    #[serde(rename = "ts")]
    pub ts: u64,

    /// The liquidation details.
    ///
    /// Contains the core data about the liquidation, such as symbol, side, size, and price. Bots process this to assess market impact.
    #[serde(rename = "data")]
    pub data: LiquidationData,
}

unsafe impl Send for Liquidation {}
unsafe impl Sync for Liquidation {}

/// Contains the details of a liquidation event.
///
/// This struct provides specific information about a liquidated position, including the time, symbol, side, size, and price.
///
/// # Bybit API Reference
/// Liquidation data is part of the WebSocket liquidation stream (https://bybit-exchange.github.io/docs/v5/websocket/public/liquidation).
///
/// # Perpetual Futures Context
/// Liquidation data helps bots understand the size and direction of forced closures, which can indicate market sentiment or trigger stop-loss cascades.
#[derive(Serialize, Deserialize, Debug, Clone)]
#[serde(rename_all = "camelCase")]
pub struct LiquidationData {
    /// The timestamp when the liquidation was updated (in milliseconds).
    ///
    /// Indicates the exact time of the liquidation event. Bots can use this to align liquidation data with price or volume spikes.
    pub updated_time: u64,

    /// The trading pair symbol (e.g., "BTCUSDT").
    ///
    /// Specifies the market where the liquidation occurred. Bots filter by symbol to focus on relevant markets.
    pub symbol: String,

    /// The side of the liquidated position ("Buy" or "Sell").
    ///
    /// Indicates whether the liquidated position was long (Buy) or short (Sell). A high volume of liquidations on one side can signal a potential price reversal, which bots can exploit.
    pub side: String,

    /// The size of the liquidated position (in contracts or base currency).
    ///
    /// Represents the volume of the position closed. Large liquidations can cause significant price movements, and bots should monitor this to anticipate volatility.
    #[serde(with = "string_to_float")]
    pub size: f64,

    /// The price at which the position was liquidated.
    ///
    /// This is the market price at which the position was forcibly closed. Bots can use this to identify liquidation price levels, which often act as support or resistance zones.
    #[serde(with = "string_to_float")]
    pub price: f64,
}

unsafe impl Send for LiquidationData {}
unsafe impl Sync for LiquidationData {}

/// Represents a WebSocket k-line (candlestick) update for a trading pair.
///
/// K-lines provide historical price and volume data over a specific interval (e.g., 1 minute, 1 hour). This struct is used in Bybit's WebSocket streams to deliver real-time candlestick updates for perpetual futures.
///
/// # Bybit API Reference
/// The Bybit API (https://bybit-exchange.github.io/docs/v5/websocket/public/kline) provides k-line data via WebSocket, including open, close, high, low, volume, and turnover.
///
/// # Perpetual Futures Context
/// K-lines are fundamental for technical analysis in futures trading. Bots use candlestick patterns to generate trading signals, such as breakouts, reversals, or trend continuations.
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct WsKline {
    /// The WebSocket topic (e.g., "kline.1m.BTCUSDT").
    ///
    /// Identifies the k-line stream and interval. Bots use this to subscribe to specific timeframes and symbols.
    pub topic: String,

    /// The k-line data for the update.
    ///
    /// Contains a vector of candlestick data points. Bots process this to update technical indicators or chart patterns.
    pub data: Vec<KlineData>,

    /// The timestamp of the update (in milliseconds).
    ///
    /// Indicates when the k-line data was sent. Bots use this to ensure data is processed in chronological order.
    #[serde(rename = "ts")]
    pub timestamp: u64,

    /// The type of WebSocket event (e.g., "snapshot" or "delta").
    ///
    /// Specifies whether the data is a full snapshot or incremental update. Bots must handle both to maintain accurate k-line history.
    #[serde(rename = "type")]
    pub event_type: String,
}

unsafe impl Send for WsKline {}
unsafe impl Sync for WsKline {}

/// Represents a single k-line (candlestick) data point.
///
/// This struct contains the price, volume, and time data for a single candlestick, used for technical analysis in trading bots.
///
/// # Bybit API Reference
/// Part of the k-line WebSocket stream (https://bybit-exchange.github.io/docs/v5/websocket/public/kline).
///
/// # Perpetual Futures Context
/// Candlestick data is critical for strategies like moving averages, RSI, or Bollinger Bands. Bots rely on this data to make real-time trading decisions.
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct KlineData {
    /// The start time of the candlestick (in milliseconds).
    ///
    /// Marks the beginning of the k-line interval. Bots use this to align candlesticks with other time-based data.
    pub start: u64,

    /// The end time of the candlestick (in milliseconds).
    ///
    /// Marks the end of the k-line interval. Bots verify this to ensure data continuity.
    pub end: u64,

    /// The time interval of the candlestick (e.g., "1m", "1h").
    ///
    /// Specifies the timeframe (e.g., 1 minute, 1 hour). Bots select intervals based on strategy requirements (e.g., short-term vs. long-term trading).
    pub interval: String,

    /// The opening price of the candlestick.
    ///
    /// The price at the start of the interval. Bots use this for calculating price changes and patterns.
    #[serde(with = "string_to_float")]
    pub open: f64,

    /// The closing price of the candlestick.
    ///
    /// The price at the end of the interval. Critical for determining candlestick direction (bullish or bearish).
    #[serde(with = "string_to_float")]
    pub close: f64,

    /// The highest price during the interval.
    ///
    /// Used to identify resistance levels or breakout points in technical analysis.
    #[serde(with = "string_to_float")]
    pub high: f64,

    /// The lowest price during the interval.
    ///
    /// Used to identify support levels or reversal points.
    #[serde(with = "string_to_float")]
    pub low: f64,

    /// The trading volume during the interval (in base currency).
    ///
    /// Indicates market activity. High volume on price movements can confirm trends for bots.
    #[serde(with = "string_to_float")]
    pub volume: f64,

    /// The turnover (value of trades) during the interval (in quote currency).
    ///
    /// Represents the monetary value of trades. Bots use this to assess liquidity and market interest.
    #[serde(with = "string_to_float")]
    pub turnover: f64,

    /// Whether the candlestick is confirmed (closed).
    ///
    /// A `true` value indicates the candlestick is finalized. Bots should wait for confirmation before acting on signals to avoid premature trades.
    pub confirm: bool,

    /// The timestamp of the candlestick (in milliseconds).
    ///
    /// Typically aligns with `end`. Bots use this for precise timing in strategies.
    pub timestamp: u64,
}

unsafe impl Send for KlineData {}
unsafe impl Sync for KlineData {}

/// Represents a position event in Bybit's perpetual futures market.
///
/// This struct is used in WebSocket streams to provide updates about a user's open positions, including size, leverage, and profit/loss.
///
/// # Bybit API Reference
/// The Bybit API (https://bybit-exchange.github.io/docs/v5/websocket/private/position) provides position data via WebSocket.
///
/// # Perpetual Futures Context
/// Positions in perpetual futures represent a trader's exposure to a market. Bots monitor position updates to manage risk, adjust leverage, or trigger stop-loss/take-profit orders.
#[derive(Serialize, Deserialize, Debug, Clone)]
#[serde(rename_all = "camelCase")]
pub struct PositionEvent {
    /// The unique identifier for the position event.
    ///
    /// Used to track specific position updates. Bots can use this to correlate events with internal state.
    pub id: String,

    /// The WebSocket topic (e.g., "position").
    ///
    /// Identifies the position data stream. Bots use this to filter relevant messages.
    pub topic: String,

    /// The timestamp when the event was created (in milliseconds).
    ///
    /// Indicates when the position update occurred. Bots use this for time-based analysis.
    pub creation_time: u64,

    /// The position data for the event.
    ///
    /// Contains details about the user's positions. Bots process this to manage open trades.
    pub data: Vec<PositionData>,
}

unsafe impl Send for PositionEvent {}
unsafe impl Sync for PositionEvent {}

/// Represents detailed data about a single position in Bybit's perpetual futures market.
///
/// This struct contains comprehensive information about a position, including size, leverage, profit/loss, and risk parameters.
///
/// # Bybit API Reference
/// Part of the position WebSocket stream (https://bybit-exchange.github.io/docs/v5/websocket/private/position).
///
/// # Perpetual Futures Context
/// Position data is critical for risk management in futures trading. Bots use this to monitor margin requirements, unrealized PnL, and liquidation risks.
#[derive(Serialize, Deserialize, Debug, Clone)]
#[serde(rename_all = "camelCase")]
pub struct PositionData {
    /// The position index (0 for one-way mode, 1 for buy-side hedge, 2 for sell-side hedge).
    ///
    /// Indicates the position mode. Bots must handle different indices for hedged vs. one-way positions to manage risk accurately.
    pub position_idx: u8,

    /// The trading mode (0 for regular, 1 for isolated margin).
    ///
    /// Specifies whether the position uses cross or isolated margin. Bots need to adjust margin calculations based on this mode.
    pub trade_mode: u8,

    /// The risk ID for the position's risk limit.
    ///
    /// Corresponds to Bybit's risk limit tiers, which define margin requirements. Bots should monitor this to ensure compliance with risk limits.
    pub risk_id: u8,

    /// The risk limit value (as a string, e.g., "1000000").
    ///
    /// Represents the maximum exposure allowed for the risk tier. Bots use this to cap position sizes and avoid margin violations.
    pub risk_limit_value: String,

    /// The trading pair symbol (e.g., "BTCUSDT").
    ///
    /// Identifies the market for the position. Bots filter by symbol to manage specific markets.
    pub symbol: String,

    /// The side of the position ("Buy" for long, "Sell" for short).
    ///
    /// Indicates the direction of the position. Bots use this to calculate exposure and hedge positions.
    pub side: String,

    /// The size of the position (in contracts or base currency).
    ///
    /// Represents the volume of the position. Bots monitor this to manage exposure and ensure it aligns with strategy limits.
    #[serde(with = "string_to_float")]
    pub size: f64,

    /// The average entry price of the position.
    ///
    /// The price at which the position was opened. Bots use this to calculate unrealized PnL and set stop-loss/take-profit levels.
    #[serde(with = "string_to_float")]
    pub entry_price: f64,

    /// The leverage used for the position (as a string, e.g., "10").
    ///
    /// Indicates the leverage multiplier (e.g., 10x). Higher leverage increases potential returns but also liquidation risk. Bots must adjust position sizes based on leverage to manage risk.
    pub leverage: String,

    /// The total value of the position (in quote currency).
    ///
    /// Calculated as size * entry price. Bots use this to assess exposure and margin requirements.
    #[serde(with = "string_to_float")]
    pub position_value: f64,

    /// The margin allocated to the position.
    ///
    /// Represents the funds reserved for the position. Bots monitor this to ensure sufficient margin and avoid liquidation.
    #[serde(with = "string_to_float")]
    pub position_balance: f64,

    /// The current mark price of the position.
    ///
    /// The fair value of the asset, used for PnL and margin calculations. Bots use this to track unrealized PnL and liquidation risks.
    #[serde(with = "string_to_float")]
    pub mark_price: f64,

    /// The initial margin requirement (as a string, e.g., "1000").
    ///
    /// The minimum margin needed to open the position. Bots use this to calculate capital requirements and optimize margin usage.
    #[serde(rename = "positionIM")]
    pub position_im: String,

    /// The maintenance margin requirement (as a string, e.g., "500").
    ///
    /// The minimum margin needed to maintain the position. Falling below this triggers liquidation. Bots must monitor this closely to avoid forced closures.
    #[serde(rename = "positionMM")]
    pub position_mm: String,

    /// The take-profit price for the position.
    ///
    /// The price at which the position will automatically close for a profit. Bots can set this to lock in gains and automate exits.
    #[serde(with = "string_to_float")]
    pub take_profit: f64,

    /// The stop-loss price for the position.
    ///
    /// The price at which the position will automatically close to limit losses. Bots use this to manage downside risk.
    #[serde(with = "string_to_float")]
    pub stop_loss: f64,

    /// The trailing stop price (optional).
    ///
    /// A dynamic stop-loss that follows the market price. Bots can use this for trend-following strategies to lock in profits while allowing upside potential.
    #[serde(with = "string_to_float_optional")]
    pub trailing_stop: Option<f64>,

    /// The unrealized profit and loss (as a string, e.g., "100.50").
    ///
    /// The current profit or loss based on the mark price. Bots use this to monitor performance and make real-time adjustments.
    #[serde(rename = "unrealisedPnl")]
    pub unrealised_pnl: String,

    /// The cumulative realized profit and loss (as a string, e.g., "500.75").
    ///
    /// The total profit or loss from closed portions of the position. Bots use this to track overall performance.
    #[serde(rename = "cumRealisedPnl")]
    pub cum_realised_pnl: String,

    /// The timestamp when the position was created (in milliseconds).
    ///
    /// Indicates when the position was opened. Bots use this for position aging and strategy timing.
    #[serde(with = "string_to_u64")]
    pub created_time: u64,

    /// The timestamp when the position was last updated (in milliseconds).
    ///
    /// Indicates the most recent change to the position. Bots use this to track updates and ensure data freshness.
    #[serde(with = "string_to_u64")]
    pub updated_time: u64,

    /// The take-profit/stop-loss mode (e.g., "Full" or "Partial").
    ///
    /// Specifies how TP/SL orders are applied. Bots must handle different modes to execute correct exit strategies.
    #[serde(rename = "tpslMode")]
    pub tpsl_mode: String,

    /// The liquidation price for the position.
    ///
    /// The price at which the position will be forcibly closed due to insufficient margin. Bots must monitor this to avoid unexpected liquidations, especially in volatile markets.
    #[serde(with = "string_to_float")]
    pub liq_price: f64,

    /// The bankruptcy price for the position (optional).
    ///
    /// The price at which the position's margin is completely depleted, leading to a total loss. This is critical for bots to monitor, as it represents the worst-case scenario. Bots should use this to set conservative stop-losses and avoid catastrophic losses.
    #[serde(with = "string_to_float_optional")]
    pub bust_price: Option<f64>,

    /// The category of the position (e.g., "linear" for USDT-margined futures).
    ///
    /// Specifies the contract type. Bots must handle different categories (e.g., linear vs. inverse) due to differences in margin and settlement.
    pub category: String,

    /// The status of the position (e.g., "Normal").
    ///
    /// Indicates whether the position is active or in a special state (e.g., liquidation). Bots use this to filter active positions for management.
    pub position_status: String,

    /// The auto-deleveraging (ADL) rank indicator (0-4).
    ///
    /// Indicates the likelihood of the position being auto-deleveraged in extreme market conditions. Higher ranks mean higher risk. Bots should monitor this to reduce exposure in volatile markets.
    pub adl_rank_indicator: u8,

    /// Whether auto-margin addition is enabled (0 for disabled, 1 for enabled).
    ///
    /// If enabled, Bybit automatically adds margin to prevent liquidation. Bots should account for this in margin management to avoid unexpected changes.
    pub auto_add_margin: u8,

    /// The timestamp when the maintenance margin rate was last updated (optional, in milliseconds).
    ///
    /// Indicates when margin requirements changed. Bots can use this to track margin updates and adjust strategies.
    #[serde(with = "string_to_u64_optional")]
    pub mmr_sys_updated_time: Option<u64>,

    /// The timestamp when the leverage was last updated (optional, in milliseconds).
    ///
    /// Indicates when leverage settings changed. Bots should monitor this to ensure leverage aligns with risk parameters.
    #[serde(with = "string_to_u64_optional")]
    pub leverage_sys_updated_time: Option<u64>,

    /// The sequence number for the position update.
    ///
    /// Used to ensure updates are processed in order. Bots should validate sequence numbers to avoid missing or duplicate updates.
    pub seq: u64,

    /// Whether the position is reduce-only.
    ///
    /// If `true`, the position can only reduce size (e.g., close trades). Bots must respect this to avoid placing invalid orders.
    pub is_reduce_only: bool,
}

unsafe impl Send for PositionData {}
unsafe impl Sync for PositionData {}

/// Represents an execution event in Bybit's perpetual futures market.
///
/// This struct is used in WebSocket streams to provide details about trade executions, such as price, quantity, and fees.
///
/// # Bybit API Reference
/// The Bybit API (https://bybit-exchange.github.io/docs/v5/websocket/private/execution) provides execution data via WebSocket.
///
/// # Perpetual Futures Context
/// Executions represent filled orders or partial fills. Bots use this data to track trade performance, calculate costs, and update position states.
#[derive(Serialize, Deserialize, Debug, Clone)]
#[serde(rename_all = "camelCase")]
pub struct Execution {
    /// The unique identifier for the execution event.
    ///
    /// Used to track specific executions. Bots can use this to correlate events with internal trade records.
    pub id: String,

    /// The WebSocket topic (e.g., "execution").
    ///
    /// Identifies the execution data stream. Bots use this to filter relevant messages.
    pub topic: String,

    /// The timestamp when the event was created (in milliseconds).
    ///
    /// Indicates when the execution occurred. Bots use this for time-based analysis.
    pub creation_time: u64,

    /// The execution data for the event.
    ///
    /// Contains details about the executed trades. Bots process this to update trade logs and positions.
    pub data: Vec<ExecutionData>,
}

unsafe impl Send for Execution {}
unsafe impl Sync for Execution {}

/// Represents detailed data about a single trade execution.
///
/// This struct contains comprehensive information about a trade, including price, quantity, fees, and order details.
///
/// # Bybit API Reference
/// Part of the execution WebSocket stream (https://bybit-exchange.github.io/docs/v5/websocket/private/execution).
///
/// # Perpetual Futures Context
/// Execution data is critical for tracking trade performance and costs. Bots use this to update position sizes, calculate realized PnL, and monitor fees.
#[derive(Serialize, Deserialize, Debug, Clone)]
#[serde(rename_all = "camelCase")]
pub struct ExecutionData {
    /// The category of the execution (e.g., "linear").
    ///
    /// Specifies the contract type (e.g., USDT-margined futures). Bots must handle different categories due to varying margin and settlement rules.
    pub category: String,

    /// The trading pair symbol (e.g., "BTCUSDT").
    ///
    /// Identifies the market for the execution. Bots filter by symbol to process relevant trades.
    pub symbol: String,

    /// The fee charged for the execution.
    ///
    /// Represents the trading cost for the executed trade. Bots must include this in PnL calculations to ensure accurate profitability tracking.
    #[serde(with = "string_to_float")]
    pub exec_fee: f64,

    /// The unique identifier for the execution.
    ///
    /// Used to track individual trades. Bots can use this to match executions with orders.
    pub exec_id: String,

    /// The price at which the trade was executed.
    ///
    /// The actual price of the filled order. Bots use this to update position entry prices and calculate PnL.
    #[serde(with = "string_to_float")]
    pub exec_price: f64,

    /// The quantity executed in the trade.
    ///
    /// The volume of the trade (in contracts or base currency). Bots use this to update position sizes and track order fills.
    #[serde(with = "string_to_float")]
    pub exec_qty: f64,

    /// The type of execution (e.g., "Trade", "Bust").
    ///
    /// Indicates the nature of the execution (e.g., normal trade or liquidation). Bots must handle different types appropriately.
    pub exec_type: String,

    /// The value of the executed trade (in quote currency).
    ///
    /// Calculated as `exec_price * exec_qty`. Bots use this to assess trade size and impact on margin.
    #[serde(with = "string_to_float")]
    pub exec_value: f64,

    /// Whether the execution was a maker order.
    ///
    /// If `true`, the trade added liquidity and likely incurred a lower fee. Bots can use this to optimize order placement for cost efficiency.
    pub is_maker: bool,

    /// The fee rate applied to the execution.
    ///
    /// The percentage fee charged (e.g., 0.0006 for 0.06%). Bots use this to verify fee calculations and optimize trading costs.
    #[serde(rename = "feeRate", with = "string_to_float")]
    pub fee_rate: f64,

    /// The implied volatility for the trade (as a string).
    ///
    /// Relevant for options trading. For futures bots, this may be less critical but can indicate market expectations of volatility.
    #[serde(rename = "tradeIv")]
    pub trade_iv: String,

    /// The mark implied volatility (as a string).
    ///
    /// The implied volatility based on the mark price. Bots can use this for volatility-based strategies in options or futures.
    #[serde(rename = "markIv")]
    pub mark_iv: String,

    /// The ID of the block trade (if applicable).
    ///
    /// Identifies large trades executed off the order book. Bots can monitor this for institutional activity that may impact prices.
    #[serde(rename = "blockTradeId")]
    pub block_trade_id: String,

    /// The current mark price at the time of execution.
    ///
    /// Used for PnL and margin calculations. Bots use this to track unrealized PnL and liquidation risks.
    #[serde(with = "string_to_float")]
    pub mark_price: f64,

    /// The index price at the time of execution.
    ///
    /// The reference price for the asset. Bots use this to calculate funding rates and fair value.
    #[serde(with = "string_to_float")]
    pub index_price: f64,

    /// The underlying price at the time of execution.
    ///
    /// The price of the underlying asset (e.g., spot price). Bots use this for arbitrage or hedging strategies.
    #[serde(with = "string_to_float")]
    pub underlying_price: f64,

    /// The remaining quantity to be filled for the order.
    ///
    /// Indicates how much of the order is still open. Bots use this to track partial fills and manage open orders.
    #[serde(with = "string_to_float")]
    pub leaves_qty: f64,

    /// The ID of the order associated with the execution.
    ///
    /// Links the execution to the original order. Bots use this to track order status and fills.
    pub order_id: String,

    /// The user-defined ID for the order.
    ///
    /// Allows bots to assign custom identifiers to orders for internal tracking.
    pub order_link_id: String,

    /// The price specified in the order.
    ///
    /// The target price for the order (e.g., limit order price). Bots use this to verify execution prices against order prices.
    #[serde(with = "string_to_float")]
    pub order_price: f64,

    /// The total quantity specified in the order.
    ///
    /// The full size of the order. Bots use this to calculate fill percentages and manage order execution.
    #[serde(with = "string_to_float")]
    pub order_qty: f64,

    /// The type of order (e.g., "Limit", "Market").
    ///
    /// Specifies the order placement method. Bots use this to determine execution behavior and strategy alignment.
    pub order_type: String,

    /// The type of stop order (if applicable, e.g., "StopLoss").
    ///
    /// Indicates if the order was a conditional stop order. Bots use this to manage risk and automate exits.
    #[serde(rename = "stopOrderType")]
    pub stop_order_type: String,

    /// The side of the order ("Buy" or "Sell").
    ///
    /// Indicates the direction of the trade. Bots use this to update position direction and exposure.
    pub side: String,

    /// The timestamp when the execution occurred (in milliseconds).
    ///
    /// Indicates the exact time of the trade. Bots use this for precise timing and correlation with market data.
    #[serde(with = "string_to_u64")]
    pub exec_time: u64,

    /// Whether leverage was used (as a string, e.g., "1").
    ///
    /// Indicates if the trade used borrowed funds. Bots use this to adjust margin and risk calculations.
    pub is_leverage: String,

    /// The size of the position closed by the execution (as a string).
    ///
    /// Relevant for closing trades. Bots use this to update position sizes and track closures.
    pub closed_size: String,

    /// The sequence number for the execution.
    ///
    /// Used to ensure executions are processed in order. Bots validate sequence numbers to avoid missing updates.
    pub seq: u64,
}

unsafe impl Send for ExecutionData {}
unsafe impl Sync for ExecutionData {}

/// Represents a fast execution event in Bybit's perpetual futures market.
///
/// This struct is a lightweight version of the execution event, providing essential trade details for high-frequency updates.
///
/// # Bybit API Reference
/// Part of the execution WebSocket stream (https://bybit-exchange.github.io/docs/v5/websocket/private/execution).
///
/// # Perpetual Futures Context
/// Fast executions are designed for low-latency trading bots that need minimal data to process trades quickly.
#[derive(Serialize, Deserialize, Debug, Clone)]
#[serde(rename_all = "camelCase")]
pub struct FastExecution {
    /// The WebSocket topic (e.g., "execution").
    ///
    /// Identifies the fast execution data stream. Bots use this to filter relevant messages.
    pub topic: String,

    /// The timestamp when the event was created (in milliseconds).
    ///
    /// Indicates when the execution occurred. Bots use this for time-based analysis.
    pub creation_time: u64,

    /// The fast execution data for the event.
    ///
    /// Contains essential trade details. Bots process this for rapid trade updates.
    pub data: Vec<FastExecData>,
}

unsafe impl Send for FastExecution {}
unsafe impl Sync for FastExecution {}

/// Represents essential data about a single trade execution for high-frequency updates.
///
/// This struct provides a minimal set of fields for low-latency trade processing.
///
/// # Bybit API Reference
/// Part of the execution WebSocket stream (https://bybit-exchange.github.io/docs/v5/websocket/private/execution).
///
/// # Perpetual Futures Context
/// Fast execution data is optimized for bots requiring minimal latency, such as high-frequency trading strategies.
#[derive(Serialize, Deserialize, Debug, Clone)]
#[serde(rename_all = "camelCase")]
pub struct FastExecData {
    /// The category of the execution (e.g., "linear").
    ///
    /// Specifies the contract type. Bots must handle different categories due to varying margin rules.
    pub category: String,

    /// The trading pair symbol (e.g., "BTCUSDT").
    ///
    /// Identifies the market for the execution. Bots filter by symbol to process relevant trades.
    pub symbol: String,

    /// The unique identifier for the execution.
    ///
    /// Used to track individual trades. Bots use this to match executions with orders.
    pub exec_id: String,

    /// The price at which the trade was executed.
    ///
    /// The actual price of the filled order. Bots use this to update position entry prices.
    #[serde(with = "string_to_float")]
    pub exec_price: f64,

    /// The quantity executed in the trade.
    ///
    /// The volume of the trade. Bots use this to update position sizes and track fills.
    #[serde(with = "string_to_float")]
    pub exec_qty: f64,

    /// The ID of the order associated with the execution.
    ///
    /// Links the execution to the original order. Bots use this to track order status.
    pub order_id: String,

    /// The user-defined ID for the order.
    ///
    /// Allows bots to assign custom identifiers for internal tracking.
    pub order_link_id: String,

    /// The side of the order ("Buy" or "Sell").
    ///
    /// Indicates the direction of the trade. Bots use this to update position direction.
    pub side: String,

    /// The timestamp when the execution occurred (in milliseconds).
    ///
    /// Indicates the exact time of the trade. Bots use this for precise timing.
    #[serde(with = "string_to_u64")]
    pub exec_time: u64,

    /// The sequence number for the execution.
    ///
    /// Used to ensure executions are processed in order. Bots validate sequence numbers to avoid missing updates.
    pub seq: u64,
}

unsafe impl Send for FastExecData {}
unsafe impl Sync for FastExecData {}

/// Represents order data for a trading order on Bybit's perpetual futures platform.
///
/// This struct encapsulates all details of an order, including its type, status, and associated financial metrics.
/// It is used in Bybit's WebSocket and REST APIs to convey order information (https://bybit-exchange.github.io/docs/v5/websocket/private/order).
/// In the context of perpetual futures, orders are instructions to buy or sell a contract that tracks the price of an underlying asset without an expiration date.
/// For trading bots, this struct is critical for tracking order execution, managing risk, and implementing strategies like market making or arbitrage.
#[derive(Serialize, Deserialize, Debug, Clone)]
#[serde(rename_all = "camelCase")]
pub struct OrderData {
    /// The trading pair or contract symbol, e.g., "BTCUSDT" for Bitcoin/Tether perpetual futures.
    ///
    /// In Bybit, the symbol uniquely identifies the perpetual futures contract. Perpetual futures are derivatives that allow traders to speculate on asset prices with leverage, without owning the underlying asset (https://bybit-exchange.github.io/docs/v5/market/instrument).
    /// For trading bots, this field is essential for routing orders to the correct market and ensuring strategy alignment with specific contracts.
    pub symbol: String,

    /// Unique identifier for the order, assigned by Bybit.
    ///
    /// This ID is used to track and manage orders via Bybit's API (https://bybit-exchange.github.io/docs/v5/order/create-order). It allows bots to query order status, cancel orders, or amend them.
    /// In perpetual futures trading, order IDs are critical for maintaining state in high-frequency trading systems, ensuring no duplicate or lost orders.
    pub order_id: String,

    /// Indicates whether the order is a buy or sell, e.g., "Buy" or "Sell".
    ///
    /// The side determines the direction of the trade in the perpetual futures market. A "Buy" order increases exposure to the asset (long position), while a "Sell" order decreases it (short position).
    /// Bots use this field to manage position direction and ensure alignment with market signals or hedging strategies (https://bybit-exchange.github.io/docs/v5/order/order-list).
    pub side: String,

    /// Specifies the type of order, e.g., "Limit", "Market".
    ///
    /// Bybit supports various order types for perpetual futures, such as limit orders (executed at a specified price) and market orders (executed at the best available price).
    /// Bots rely on this field to implement strategies like limit order books for liquidity provision or market orders for immediate execution (https://bybit-exchange.github.io/docs/v5/order/create-order).
    pub order_type: String,

    /// Indicates the reason or type of order cancellation, if applicable.
    ///
    /// This field is relevant when an order is canceled due to conditions like insufficient margin or timeout. In perpetual futures, cancellations can occur due to rapid market movements or risk limits.
    /// For bots, monitoring this field helps diagnose issues like order rejections and adjust strategies to avoid repeated cancellations.
    pub cancel_type: String,

    /// The price at which the order is placed (for limit orders) or executed (for market orders).
    ///
    /// In perpetual futures, the price is critical for calculating entry points and potential profits. Bybit represents prices in USDT or the quote currency (https://bybit-exchange.github.io/docs/v5/order/order-list).
    /// Bots use this field to set precise entry/exit points and manage slippage in volatile markets.
    #[serde(with = "string_to_float")]
    pub price: f64,

    /// The quantity of the contract to be traded, expressed in contracts or lots.
    ///
    /// For perpetual futures on Bybit, quantity represents the size of the position. Larger quantities increase exposure and risk, especially with leverage (https://bybit-exchange.github.io/docs/v5/order/create-order).
    /// Bots use this field to scale positions based on account size, risk tolerance, andავ

    /// The quantity of the contract to be traded, expressed in contracts or lots.
    ///
    /// For perpetual futures on Bybit, quantity represents the size of the position. Larger quantities increase exposure and risk, especially with leverage (https://bybit-exchange.github.io/docs/v5/order/create-order).
    /// Bots use this field to scale positions based on account size, risk tolerance, and market conditions.
    #[serde(with = "string_to_float")]
    pub qty: f64,

    /// Implied volatility associated with the order, if applicable.
    ///
    /// This field is typically used for options or volatility-based derivatives, not standard perpetual futures. It may be empty or unused in this context.
    /// For bots, this field is generally irrelevant unless dealing with Bybit's volatility products, which are less common.
    pub order_iv: String,

    /// Specifies how long the order remains active, e.g., "GTC" (Good Till Cancel), "IOC" (Immediate or Cancel).
    ///
    /// Time in force controls order execution behavior in Bybit's perpetual futures market (https://bybit-exchange.github.io/docs/v5/order/create-order).
    /// Bots use this field to manage order persistence, balancing execution speed with market exposure.
    pub time_in_force: String,

    /// Current status of the order, e.g., "New", "Filled", "Cancelled".
    ///
    /// This field tracks the lifecycle of an order on Bybit (https://bybit-exchange.github.io/docs/v5/order/order-list). In perpetual futures, understanding order status is crucial for managing open positions and avoiding unintended exposures.
    /// Bots monitor this field to confirm executions, handle partial fills, or trigger fallback strategies.
    /// **Order Status Monitoring**: Trading bots heavily rely on real-time order status updates to manage risk and ensure accurate position tracking. For instance, a "Filled" status confirms execution, while "Rejected" may require immediate re-evaluation of the strategy.
    pub order_status: String,

    /// A custom identifier for the order, set by the user or bot.
    ///
    /// This allows bots to attach metadata to orders for internal tracking, such as strategy IDs or batch identifiers. It’s particularly useful in high-frequency trading to correlate orders with specific algorithms or events (https://bybit-exchange.github.io/docs/v5/order/create-order).
    /// **Bot Implication**: Using meaningful `order_link_id` values can streamline reconciliation and debugging, especially when handling thousands of orders daily.
    pub order_link_id: String,

    /// The market price of the symbol when the order was created.
    ///
    /// This field captures the reference price at order placement, useful for auditing and performance analysis in perpetual futures trading. It helps bots assess slippage (the difference between `last_price_on_created` and `price`) and market conditions at the time of order submission.
    /// **Bot Implication**: Bots can use this to evaluate execution quality, especially for market orders where slippage can significantly impact profitability in volatile markets like crypto futures.
    #[serde(with = "string_to_float")]
    pub last_price_on_created: f64,

    /// Indicates if the order reduces an existing position (true) or opens a new one (false).
    ///
    /// In perpetual futures, `reduce_only` orders ensure that the trade only closes or reduces a position, preventing accidental increases in exposure (https://bybit-exchange.github.io/docs/v5/order/create-order).
    /// **Bot Implication**: Bots must set this correctly to avoid unintended leverage increases, which could lead to margin calls or liquidations in highly leveraged markets=1. **Risk Management**: Using `reduce_only` orders is critical for bots managing position sizing to prevent over-leveraging, especially in volatile markets where margin requirements can change rapidly.
    pub reduce_only: bool,

    /// The remaining quantity of the order that has not yet been filled.
    ///
    /// For partially filled orders, this field tracks how much of the original `qty` remains open. In perpetual futures, partial fills are common due to market liquidity constraints (https://bybit-exchange.github.io/docs/v5/order/order-list).
    /// **Bot Implication**: Bots need to monitor `leaves_qty` to decide whether to cancel the remaining order, adjust the price, or wait for further execution, balancing execution risk with market exposure.
    #[serde(with = "string_to_float")]
    pub leaves_qty: f64,

    /// The remaining value of the order, calculated as `leaves_qty` multiplied by the order price.
    ///
    /// This provides the monetary value of the unfilled portion of the order, useful for assessing exposure in USDT or the quote currency.
    /// **Bot Implication**: Bots use `leaves_value` to quantify the capital tied up in open orders, aiding in capital allocation and risk management.
    #[serde(with = "string_to_float")]
    pub leaves_value: f64,

    /// The total quantity executed so far for this order.
    ///
    /// This tracks the cumulative filled portion of the order, critical for monitoring progress toward full execution (https://bybit-exchange.github.io/docs/v5/order/order-list).
    /// **Bot Implication**: Bots use `cum_exec_qty` to calculate position size, update risk models, and determine whether additional orders are needed to achieve the desired exposure.
    #[serde(with = "string_to_float")]
    pub cum_exec_qty: f64,

    /// The total monetary value of the executed portion, calculated as `cum_exec_qty` multiplied by the average execution price.
    ///
    /// This quantifies the capital deployed in the executed portion of the order, useful for performance tracking and cost analysis.
    /// **Bot Implication**: Bots use `cum_exec_value` to assess trade costs, including fees, and to evaluate the profitability of partially filled orders.
    #[serde(with = "string_to_float")]
    pub cum_exec_value: f64,

    /// The average price at which the executed portion of the order was filled.
    ///
    /// This is calculated as the total value of executed trades divided by `cum_exec_qty`. It provides a weighted average execution price, reflecting market conditions during filling (https://bybit-exchange.github.io/docs/v5/order/order-list).
    /// **Bot Implication**: Bots use `avg_price` to evaluate trade execution quality, compare it to `last_price_on_created`, and adjust strategies to minimize slippage in future orders.
    #[serde(with = "string_to_float")]
    pub avg_price: f64,

    /// Identifier for a block trade, if applicable.
    ///
    /// Block trades are large, negotiated trades executed outside the public order book, often used by institutional traders. This field is typically empty for retail bots (https://bybit-exchange.github.io/docs/v5/trade/block-trade).
    /// **Bot Implication**: For most retail bots, this field is unused, but large-scale bots may use it to track high-value trades separately for reporting or compliance.
    pub block_trade_id: String,

    /// Index indicating the position direction, e.g., 0 for one-way mode, 1 for buy-side hedge, 2 for sell-side hedge.
    ///
    /// Bybit’s unified margin account supports one-way or hedge modes for perpetual futures positions (https://bybit-exchange.github.io/docs/v5/account/position).
    /// **Bot Implication**: Bots must align `position_idx` with the account’s position mode to avoid position mismatches, which could lead to unintended liquidations.
    #[serde(rename = "positionIdx")]
    pub position_idx: u8,

    /// The cumulative trading fees incurred for this order.
    ///
    /// Fees in perpetual futures include maker/taker fees, which impact profitability. Bybit’s fee structure varies by VIP level and order type (https://bybit-exchange.github.io/docs/v5/account/fee).
    /// **Bot Implication**: Bots must track `cum_exec_fee` to optimize order types (e.g., maker vs. taker) and account for fees in profitability calculations, as high-frequency trading can accumulate significant costs.
    #[serde(with = "string_to_float")]
    pub cum_exec_fee: f64,

    /// Timestamp when the order was created, in milliseconds since Unix epoch.
    ///
    /// This records the exact time of order submission, critical for auditing and performance analysis (https://bybit-exchange.github.io/docs/v5/order/order-list).
    /// **Bot Implication**: Bots use `created_time` to correlate orders with market events, calculate latency, and ensure compliance with exchange timestamps.
    #[serde(with = "string_to_u64")]
    pub created_time: u64,

    /// Timestamp of the last update to the order, in milliseconds since Unix epoch.
    ///
    /// This tracks the most recent change to the order’s status, such as partial fills or cancellations (https://bybit-exchange.github.io/docs/v5/order/order-list).
    /// **Bot Implication**: Bots use `updated_time` to detect delays in execution or status changes, enabling timely adjustments to strategies or risk controls.
    #[serde(with = "string_to_u64")]
    pub updated_time: u64,

    /// Reason for order rejection, if applicable, e.g., "Insufficient margin".
    ///
    /// This field explains why an order failed to execute, helping diagnose issues like funding shortages or invalid parameters (https://bybit-exchange.github.io/docs/v5/order/order-list).
    /// **Bot Implication**: Bots must monitor `reject_reason` to handle errors programmatically, such as topping up margin or adjusting order parameters to prevent repeated failures.
    pub reject_reason: String,

    /// Type of stop order, e.g., "Stop", "TrailingStop", if applicable.
    ///
    /// Stop orders in perpetual futures are conditional orders triggered by price movements, used for risk management (https://bybit-exchange.github.io/docs/v5/order/stop-order).
    /// **Bot Implication**: Bots use `stop_order_type` to implement automated stop-loss or trailing stops, critical for limiting losses in leveraged positions.
    #[serde(rename = "stopOrderType")]
    pub stop_order_type: String,

    /// Take-profit/stop-loss mode, e.g., "Full", "Partial".
    ///
    /// This defines how take-profit and stop-loss orders are applied in Bybit’s unified margin account, either to the full position or a portion (https://bybit-exchange.github.io/docs/v5/order/tpsl-mode).
    /// **Bot Implication**: Bots must configure `tpsl_mode` to align with risk management strategies, ensuring partial or full position exits as intended.
    #[serde(rename = "tpslMode")]
    pub tpsl_mode: String,

    /// Price level that triggers a stop order.
    ///
    /// In perpetual futures, the trigger price determines when a stop-loss or other conditional order activates (https://bybit-exchange.github.io/docs/v5/order/stop-order).
    /// **Bot Implication**: Bots set `trigger_price` to automate risk controls, ensuring timely exits from losing positions to prevent margin calls or liquidations.
    #[serde(with = "string_to_float")]
    pub trigger_price: f64,

    /// Price level at which a take-profit order is triggered.
    ///
    /// Take-profit orders lock in gains by closing a position when the market reaches a favorable price (https://bybit-exchange.github.io/docs/v5/order/tpsl-order).
    /// **Bot Implication**: Bots use `take_profit` to secure profits automatically, balancing the trade-off between capturing gains and allowing room for further upside.
    #[serde(with = "string_to_float")]
    pub take_profit: f64,

    /// Price level at which a stop-loss order is triggered.
    ///
    /// Stop-loss orders limit losses by closing a position when the market moves against it (https://bybit-exchange.github.io/docs/v5/order/tpsl-order).
    /// **Bot Implication**: Bots set `stop_loss` to cap downside risk, a critical feature for leveraged perpetual futures where losses can exceed initial margin.
    #[serde(with = "string_to_float")]
    pub stop_loss: f64,

    /// Specifies the price type that triggers the take-profit order, e.g., "LastPrice", "IndexPrice".
    ///
    /// Bybit allows different price feeds for triggering orders, affecting how take-profit is calculated (https://bybit-exchange.github.io/docs/v5/order/tpsl-order).
    /// **Bot Implication**: Bots must select the appropriate `tp_trigger_by` to align with strategy logic, as different price types can lead to varying trigger points.
    #[serde(rename = "tpTriggerBy")]
    pub tp_trigger_by: String,

    /// Specifies the price type that triggers the stop-loss order, e.g., "LastPrice", "IndexPrice".
    ///
    /// Similar to `tp_trigger_by`, this determines the reference price for stop-loss activation (https://bybit-exchange.github.io/docs/v5/order/tpsl-order).
    /// **Bot Implication**: Bots need to choose `sl_trigger_by` carefully, as price feed discrepancies can cause premature or delayed stop-loss triggers.
    #[serde(rename = "slTriggerBy")]
    pub sl_trigger_by: String,

    /// Limit price for the take-profit order, if applicable.
    ///
    /// This specifies the exact price at which the take-profit order executes once triggered, allowing precise profit capture (https://bybit-exchange.github.io/docs/v5/order/tpsl-order).
    /// **Bot Implication**: Bots use `tp_limit_price` to minimize slippage on take-profit execution, ensuring profits are locked in at the desired level.
    #[serde(rename = "tpLimitPrice", with = "string_to_float")]
    pub tp_limit_price: f64,

    /// Limit price for the stop-loss order, if applicable.
    ///
    /// This sets the execution price for the stop-loss order once triggered, controlling the exit price in adverse market moves (https://bybit-exchange.github.io/docs/v5/order/tpsl-order).
    /// **Bot Implication**: Bots set `sl_limit_price` to balance loss minimization with the risk of slippage, especially in fast-moving markets.
    #[serde(rename = "slLimitPrice", with = "string_to_float")]
    pub sl_limit_price: f64,

    /// Direction of the price movement that triggers the order, e.g., 1 for rising price, 2 for falling price.
    ///
    /// This defines whether the stop or take-profit order activates on an upward or downward price move (https://bybit-exchange.github.io/docs/v5/order/stop-order).
    /// **Bot Implication**: Bots must set `trigger_direction` correctly to align with the intended risk or profit-taking logic, as incorrect settings can lead to unintended executions.
    pub trigger_direction: u8,

    /// The price type that triggers the conditional order, e.g., "LastPrice", "MarkPrice".
    ///
    /// Similar to `tp_trigger_by` and `sl_trigger_by`, this specifies the reference price for conditional orders (https://bybit-exchange.github.io/docs/v5/order/stop-order).
    /// **Bot Implication**: Bots need to ensure `trigger_by` matches the strategy’s price feed to avoid discrepancies in trigger timing.
    pub trigger_by: String,

    /// Indicates if the order closes the position when triggered.
    ///
    /// When `true`, the order ensures the position is fully closed upon trigger, used in stop-loss or take-profit scenarios (https://bybit-exchange.github.io/docs/v5/order/tpsl-order).
    /// **Bot Implication**: Bots use `close_on_trigger` to enforce complete position exits, critical for risk management in leveraged perpetual futures.
    pub close_on_trigger: bool,

    /// The product category, e.g., "linear", "inverse".
    ///
    /// Bybit offers linear (USDT-margined) and inverse (coin-margined) perpetual futures, each with different margin and settlement mechanics (https://bybit-exchange.github.io/docs/v5/market/instrument).
    /// **Bot Implication**: Bots must align `category` with the account’s margin type to ensure correct position and margin calculations.
    pub category: String,

    /// Indicates how the order was placed, e.g., "Normal", "Adl" (Auto-Deleveraging).
    ///
    /// This field distinguishes standard orders from those triggered by Bybit’s risk management processes, like ADL (https://bybit-exchange.github.io/docs/v5/account/position#auto-deleveraging-adl).
    /// **Bot Implication**: Bots should monitor `place_type` to identify non-standard orders, which may indicate risk events like forced liquidations.
    pub place_type: String,

    /// Self-Match Prevention (SMP) type, if applicable.
    ///
    /// SMP prevents orders from the same account matching each other, reducing wash trading risks (https://bybit-exchange.github.io/docs/v5/order/smp).
    /// **Bot Implication**: Bots in multi-strategy setups should track `smp_type` to ensure compliance with Bybit’s trading rules and avoid penalties.
    pub smp_type: String,

    /// Group ID for SMP, if applicable.
    ///
    /// This identifies the SMP group to which the order belongs, used to enforce self-match prevention (https://bybit-exchange.github.io/docs/v5/order/smp).
    /// **Bot Implication**: Bots managing multiple sub-accounts or strategies use `smp_group` to coordinate orders and prevent internal matching.
    pub smp_group: u8,

    /// Order ID of the matching order in an SMP scenario, if applicable.
    ///
    /// This links the order to its counterpart in an SMP event, aiding in audit trails (https://bybit-exchange.github.io/docs/v5/order/smp).
    /// **Bot Implication**: Bots use `smp_order_id` for reconciliation and compliance reporting, ensuring transparency in SMP events.
    pub smp_order_id: String,

    /// The currency used for fees, e.g., "USDT".
    ///
    /// This specifies the currency in which trading fees are charged, impacting cost calculations (https://bybit-exchange.github.io/docs/v5/account/fee).
    /// **Bot Implication**: Bots must account for `fee_currency` in profitability models, as fees in volatile currencies like USDT can affect net returns.
    pub fee_currency: String,
}

unsafe impl Send for OrderData {}
unsafe impl Sync for OrderData {}

/// Represents an event containing order updates from Bybit’s WebSocket API.
///
/// This struct is used to receive real-time order updates via Bybit’s private WebSocket stream (https://bybit-exchange.github.io/docs/v5/websocket/private/order).
/// In perpetual futures trading, real-time order events are critical for bots to react to market changes, manage positions, and execute strategies dynamically.
#[derive(Serialize, Deserialize, Debug, Clone)]
#[serde(rename_all = "camelCase")]
pub struct OrderEvent {
    /// Unique identifier for the WebSocket event.
    ///
    /// This ID allows bots to track and correlate WebSocket messages, ensuring no events are missed or duplicated.
    /// **Bot Implication**: Bots use `id` to maintain message integrity and debug WebSocket connectivity issues.
    pub id: String,

    /// The WebSocket topic, e.g., "order".
    ///
    /// This identifies the type of data in the event, allowing bots to route messages to the appropriate handler (https://bybit-exchange.github.io/docs/v5/websocket/private/order).
    /// **Bot Implication**: Bots filter on `topic` to process order updates efficiently, ignoring irrelevant streams.
    pub topic: String,

    /// Timestamp of the event, in milliseconds since Unix epoch.
    ///
    /// This records when the event was generated by Bybit, critical for latency analysis and event sequencing (https://bybit-exchange.github.io/docs/v5/websocket/private/order).
    /// **Bot Implication**: Bots use `creation_time` to measure system performance and ensure timely processing of order updates.
    pub creation_time: u64,

    /// List of order data updates included in the event.
    ///
    /// This contains one or more `OrderData` structs, each representing an updated order (https://bybit-exchange.github.io/docs/v5/websocket/private/order).
    /// **Bot Implication**: Bots iterate through `data` to process multiple order updates in a single event, optimizing performance in high-frequency trading.
    pub data: Vec<OrderData>,
}

unsafe impl Send for OrderEvent {}
unsafe impl Sync for OrderEvent {}

/// Represents an event containing wallet updates from Bybit’s WebSocket API.
///
/// This struct delivers real-time wallet balance and margin updates via Bybit’s private WebSocket stream (https://bybit-exchange.github.io/docs/v5/websocket/private/wallet).
/// In perpetual futures, wallet events are essential for monitoring account health, margin levels, and funding requirements, especially in leveraged trading.
#[derive(Serialize, Deserialize, Debug, Clone)]
#[serde(rename_all = "camelCase")]
pub struct WalletEvent {
    /// Unique identifier for the WebSocket event.
    ///
    /// Similar to `OrderEvent.id`, this tracks the event for debugging and message integrity.
    /// **Bot Implication**: Bots use `id` to ensure all wallet updates are processed and to troubleshoot WebSocket issues.
    pub id: String,

    /// The WebSocket topic, e.g., "wallet".
    ///
    /// This identifies the event as a wallet update, allowing bots to route it to the appropriate handler (https://bybit-exchange.github.io/docs/v5/websocket/private/wallet).
    /// **Bot Implication**: Bots filter on `topic` to prioritize wallet updates, critical for margin and risk management.
    pub topic: String,

    /// Timestamp of the event, in milliseconds since Unix epoch.
    ///
    /// This records when the wallet update was generated, aiding in latency and sequencing analysis (https://bybit-exchange.github.io/docs/v5/websocket/private/wallet).
    /// **Bot Implication**: Bots use `creation_time` to ensure timely margin adjustments and to monitor system performance.
    pub creation_time: u64,

    /// List of wallet data updates included in the event.
    ///
    /// This contains one or more `WalletData` structs, each representing updated wallet metrics (https://bybit-exchange.github.io/docs/v5/websocket/private/wallet).
    /// **Bot Implication**: Bots process `data` to update account balances and margin ratios, ensuring compliance with Bybit’s risk controls.
    pub data: Vec<WalletData>,
}

unsafe impl Send for WalletEvent {}
unsafe impl Sync for WalletEvent {}

/// Represents wallet data, including balances and margin metrics, for a Bybit account.
///
/// This struct provides a snapshot of the account’s financial state, used for monitoring margin, equity, and risk in perpetual futures trading (https://bybit-exchange.github.io/docs/v5/account/wallet-balance).
/// For trading bots, wallet data is critical for ensuring sufficient margin, avoiding liquidations, and optimizing capital allocation.
#[derive(Serialize, Deserialize, Debug, Clone)]
#[serde(rename_all = "camelCase")]
pub struct WalletData {
    /// Initial margin rate for the account, as a string (e.g., "0.1" for 10%).
    ///
    /// This represents the ratio of initial margin to total equity, a key risk metric in perpetual futures. A higher rate indicates greater leverage and risk (https://bybit-exchange.github.io/docs/v5/account/risk-limit).
    /// **Bot Implication**: Bots monitor `account_im_rate` to ensure compliance with Bybit’s margin requirements, adjusting positions to avoid margin calls.
    #[serde(rename = "accountIMRate")]
    pub account_im_rate: String,

    /// Maintenance margin rate for the account, as a string (e.g., "0.05" for 5%).
    ///
    /// This is the minimum margin ratio required to maintain open positions. Falling below this triggers a margin call or liquidation (https://bybit-exchange.github.io/docs/v5/account/risk-limit).
    /// **Bot Implication**: Bots prioritize `account_mm_rate` to prevent forced liquidations, especially in volatile markets where margin requirements can spike.
    #[serde(rename = "accountMMRate")]
    pub account_mm_rate: String,

    /// Total equity in the account, in USDT or the base currency.
    ///
    /// This represents the account’s net worth, including wallet balance and unrealized PNL (https://bybit-exchange.github.io/docs/v5/account/wallet-balance).
    /// **Bot Implication**: Bots use `total_equity` to assess overall account health and allocate capital across positions, ensuring sufficient buffer for market swings.
    #[serde(with = "string_to_float")]
    pub total_equity: f64,

    /// Total wallet balance, excluding unrealized PNL.
    ///
    /// This is the actual cash balance in the account, available for trading or withdrawal (https://bybit-exchange.github.io/docs/v5/account/wallet-balance).
    /// **Bot Implication**: Bots track `total_wallet_balance` to ensure liquidity for new trades and margin requirements, avoiding funding shortages.
    #[serde(with = "string_to_float")]
    pub total_wallet_balance: f64,

    /// Total margin balance, including wallet balance and unrealized PNL.
    ///
    /// This reflects the account’s total margin capacity, used to support open positions (https://bybit-exchange.github.io/docs/v5/account/wallet-balance).
    /// **Bot Implication**: Bots use `total_margin_balance` to calculate leverage limits and ensure positions are adequately margined.
    #[serde(with = "string_to_float")]
    pub total_margin_balance: f64,

    /// Total available balance for new trades or withdrawals.
    ///
    /// This is the portion of the wallet balance not tied up in margin or open positions (https://bybit-exchange.github.io/docs/v5/account/wallet-balance).
    /// **Bot Implication**: Bots rely on `total_available_balance` to determine capacity for new trades, ensuring no over-allocation of funds.
    #[serde(with = "string_to_float")]
    pub total_available_balance: f64,

    /// Total unrealized profit and loss for perpetual futures positions.
    ///
    /// This reflects the paper gains or losses on open positions, impacting equity and margin calculations (https://bybit-exchange.github.io/docs/v5/account/position).
    /// **Bot Implication**: Bots monitor `total_perp_upl` to assess position performance and adjust risk controls, as large unrealized losses can trigger liquidations.
    #[serde(rename = "totalPerpUPL", with = "string_to_float")]
    pub total_perp_upl: f64,

    /// Total initial margin required for open positions and orders.
    ///
    /// This is the collateral required to open and maintain positions, based on Bybit’s risk limits (https://bybit-exchange.github.io/docs/v5/account/risk-limit).
    /// **Bot Implication**: Bots track `total_initial_margin` to ensure sufficient margin allocation, preventing rejections or forced closures.
    #[serde(with = "string_to_float")]
    pub total_initial_margin: f64,

    /// Total maintenance margin required to keep positions open.
    ///
    /// This is the minimum collateral needed to avoid liquidation, typically lower than initial margin (https://bybit-exchange.github.io/docs/v5/account/risk-limit).
    /// **Bot Implication**: Bots prioritize `total_maintenance_margin` to maintain account stability, as falling below this triggers risk management actions.
    #[serde(with = "string_to_float")]
    pub total_maintenance_margin: f64,

    /// List of coin-specific balance data for the account.
    ///
    /// This breaks down the wallet by currency, providing granular balance and margin details (https://bybit-exchange.github.io/docs/v5/account/wallet-balance).
    /// **Bot Implication**: Bots use `coin` to manage multi-currency accounts, ensuring proper funding and collateral allocation per currency.
    pub coin: Vec<CoinData>,

    /// Loan-to-value ratio for the account, as a string (e.g., "0.2" for 20%).
    ///
    /// This measures borrowed funds relative to total equity, a leverage risk indicator in Bybit’s unified margin account (https://bybit-exchange.github.io/docs/v5/account/risk-limit).
    /// **Bot Implication**: Bots monitor `account_ltv` to control leverage risk, as high LTV increases liquidation probability in adverse markets.
    #[serde(rename = "accountLTV")]
    pub account_ltv: String,

    /// Type of account, e.g., "UNIFIED", if specified.
    ///
    /// This indicates the account’s margin mode, such as unified (cross-margin) or isolated (per-position margin) (https://bybit-exchange.github.io/docs/v5/account/margin-mode).
    /// **Bot Implication**: Bots must align strategies with `account_type`, as margin modes affect risk calculations and liquidation mechanics.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub account_type: Option<String>,
}

unsafe impl Send for WalletData {}
unsafe impl Sync for WalletData {}

/// Represents balance and margin data for a specific currency in the account.
///
/// This struct details the financial state of a single currency (e.g., USDT, BTC) within a Bybit account, used for multi-currency margin management (https://bybit-exchange.github.io/docs/v5/account/wallet-balance).
/// For trading bots, `CoinData` is critical for allocating collateral, managing borrowing, and tracking currency-specific PNL in perpetual futures.
#[derive(Serialize, Deserialize, Debug, Clone)]
#[serde(rename_all = "camelCase")]
pub struct CoinData {
    /// The currency, e.g., "USDT", "BTC".
    ///
    /// This identifies the coin for which balance and margin data is provided, critical for multi-currency accounts (https://bybit-exchange.github.io/docs/v5/account/wallet-balance).
    /// **Bot Implication**: Bots use `coin` to route funds and collateral correctly, ensuring proper currency alignment for trades and margin.
    pub coin: String,

    /// Total equity for the currency, including wallet balance and unrealized PNL.
    ///
    /// This represents the net worth of the currency in the account, used for leverage and risk calculations (https://bybit-exchange.github.io/docs/v5/account/wallet-balance).
    /// **Bot Implication**: Bots monitor `equity` to assess currency-specific financial health, guiding allocation and risk decisions.
    #[serde(with = "string_to_float")]
    pub equity: f64,

    /// USD value of the currency’s equity, converted at the current market rate.
    ///
    /// This normalizes the currency’s equity to USD for cross-currency comparisons and risk aggregation (https://bybit-exchange.github.io/docs/v5/account/wallet-balance).
    /// **Bot Implication**: Bots use `usd_value` to standardize risk exposure across currencies, simplifying account-level risk management.
    #[serde(with = "string_to_float")]
    pub usd_value: f64,

    /// Available balance for the currency, excluding margin and locked funds.
    ///
    /// This is the liquid balance available for trading or withdrawal in the specific currency (https://bybit-exchange.github.io/docs/v5/account/wallet-balance).
    /// **Bot Implication**: Bots track `wallet_balance` to ensure sufficient liquidity for new positions or margin top-ups in the currency.
    #[serde(with = "string_to_float")]
    pub wallet_balance: f64,

    /// Amount available for withdrawal in the currency, if specified.
    ///
    /// This reflects the portion of the wallet balance that can be withdrawn, accounting for restrictions like pending orders (https://bybit-exchange.github.io/docs/v5/account/wallet-balance).
    /// **Bot Implication**: Bots use `available_to_withdraw` to manage cash flow, ensuring funds are accessible when needed without disrupting trading.
    #[serde(with = "string_to_float_optional")]
    pub available_to_withdraw: Option<f64>,

    /// Amount available to borrow in the currency, if specified.
    ///
    /// This indicates the additional leverage available for the currency in Bybit’s unified margin account (https://bybit-exchange.github.io/docs/v5/account/borrow).
    /// **Bot Implication**: bots use `available_to_borrow` to expand positions, but must balance borrowing with liquidation risks in volatile markets.
    #[serde(with = "string_to_float_optional")]
    pub available_to_borrow: Option<f64>,

    /// Total borrowed amount in the currency.
    ///
    /// This tracks loans taken in the currency, impacting leverage and interest costs (https://bybit-exchange.github.io/docs/v5/account/borrow).
    /// **Bot Implication**: Bots monitor `borrow_amount` to manage interest expenses and ensure borrowed funds don’t exceed risk thresholds.
    #[serde(with = "string_to_float")]
    pub borrow_amount: f64,

    /// Accrued interest on borrowed funds in the currency.
    ///
    /// This represents the cost of borrowing, which accumulates over time and affects profitability (https://bybit-exchange.github.io/docs/v5/account/borrow).
    /// **Bot Implication**: Bots track `accrued_interest` to optimize borrowing strategies, minimizing costs while maintaining leverage.
    #[serde(with = "string_to_float")]
    pub accrued_interest: f64,

    /// Initial margin for orders in the currency.
    ///
    /// This is the collateral required for open orders in the currency, impacting available balance (https://bybit-exchange.github.io/docs/v5/account/risk-limit).
    /// **Bot Implication**: Bots use `total_order_im` to allocate margin efficiently, ensuring orders don’t overcommit funds.
    #[serde(rename = "totalOrderIM", with = "string_to_float")]
    pub total_order_im: f64,

    /// Initial margin for positions in the currency, as a string.
    ///
    /// This is the collateral tied up in open positions, expressed as a string for precision (https://bybit-exchange.github.io/docs/v5/account/risk-limit).
    /// **Bot Implication**: Bots monitor `total_position_im` to manage position margin, preventing over-leveraging or margin shortages.
    #[serde(rename = "totalPositionIM")]
    pub total_position_im: String,

    /// Maintenance margin for positions in the currency, as a string.
    ///
    /// This is the minimum collateral needed to maintain positions, critical for avoiding liquidations (https://bybit-exchange.github.io/docs/v5/account/risk-limit).
    /// **Bot Implication**: Bots prioritize `total_position_mm` to ensure positions remain funded, adjusting leverage or topping up margin as needed.
    #[serde(rename = "totalPositionMM")]
    pub total_position_mm: String,

    /// Unrealized profit and loss for positions in the currency.
    ///
    /// This reflects paper gains or losses on open positions, affecting equity and margin (https://bybit-exchange.github.io/docs/v5/account/position).
    /// **Bot Implication**: Bots use `unrealised_pnl` to evaluate position performance and adjust risk controls, as large losses can trigger margin calls.
    #[serde(with = "string_to_float")]
    pub unrealised_pnl: f64,

    /// Cumulative realized profit and loss for the currency.
    ///
    /// This tracks the net realized gains or losses from closed positions, impacting account equity (https://bybit-exchange.github.io/docs/v5/account/position).
    /// **Bot Implication**: Bots use `cum_realised_pnl` to assess strategy performance and update capital allocation based on realized outcomes.
    #[serde(with = "string_to_float")]
    pub cum_realised_pnl: f64,

    /// Bonus balance in the currency, e.g., promotional credits.
    ///
    /// This represents non-withdrawable funds, often from Bybit promotions, used for trading (https://bybit-exchange.github.io/docs/v5/account/wallet-balance).
    /// **Bot Implication**: Bots account for `bonus` in balance calculations, but must adjust for withdrawal restrictions when planning cash flow.
    pub bonus: String,

    /// Indicates if the currency can be used as collateral.
    ///
    /// When `true`, the currency is eligible for margin calculations in Bybit’s unified account (https://bybit-exchange.github.io/docs/v5/account/margin-mode).
    /// **Bot Implication**: Bots check `collateral_switch` to ensure only eligible currencies are used for margin, avoiding funding errors.
    pub collateral_switch: bool,

    /// Indicates if the currency is used as margin collateral.
    ///
    /// When `true`, the currency actively contributes to margin requirements (https://bybit-exchange.github.io/docs/v5/account/margin-mode).
    /// **Bot Implication**: Bots prioritize `margin_collateral` currencies for margin allocation, optimizing collateral efficiency.
    pub margin_collateral: bool,

    /// Amount of the currency locked, e.g., for pending orders, as a string.
    ///
    /// This represents funds tied up in non-withdrawable states, reducing available balance (https://bybit-exchange.github.io/docs/v5/account/wallet-balance).
    /// **Bot Implication**: Bots track `locked` to avoid overestimating available funds, ensuring accurate liquidity planning.
    pub locked: String,

    /// Quantity of the currency used for spot hedging.
    ///
    /// This reflects the amount allocated to spot positions for hedging futures exposure, as a string (https://bybit-exchange.github.io/docs/v5/account/position).
    /// **Bot Implication**: Bots use `spot_hedging_qty` to balance futures and spot positions, minimizing directional risk in hedging strategies.
    pub spot_hedging_qty: String,
}

unsafe impl Send for CoinData {}
unsafe impl Sync for CoinData {}

/// Module for serializing and deserializing optional u64 values as strings.
mod string_to_u64_optional {
    use serde::{Deserialize, Deserializer, Serializer};
    use std::str::FromStr;

    /// Serializes an Option<u64> as a string, using an empty string for None.
    pub fn serialize<S>(value: &Option<u64>, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        match value {
            Some(v) => serializer.serialize_str(&v.to_string()),
            None => serializer.serialize_str(""),
        }
    }

    /// Deserializes a string to an Option<u64>, returning None for empty strings.
    pub fn deserialize<'de, D>(deserializer: D) -> Result<Option<u64>, D::Error>
    where
        D: Deserializer<'de>,
    {
        let s = String::deserialize(deserializer)?;
        if s.is_empty() {
            Ok(None)
        } else {
            u64::from_str(&s)
                .map(Some)
                .map_err(serde::de::Error::custom)
        }
    }
}
